<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Garden View Ecosystem</title>
    <style>
        html, body {
    width: 100%;
    height: 100vh;
    margin: 0;
    padding: 0;
    overflow: hidden;
    font-family: Arial, sans-serif;
    touch-action: manipulation;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    position: fixed;
}
.window {
    width: 100vw !important;
    height: 100vh !important;
    margin: 0;
    padding: 0;
    overflow: hidden;
    position: absolute;
    top: 0;
    left: 0;
}
        
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.7);
            padding: 10px;
            border-radius: 5px;
            max-width: 200px;
            font-size: 12px;
            z-index: 10;
            color: #3366CC
        }
        
        .info-panel h3 {
            margin-top: 0;
        }
        
        .toggle-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10;
        }
        
        .controls-hint {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 10;
            color: #000000; /* Add this line to make text black */
        }
        
        .control-panel {
            position: absolute;
            left: 10px;
            bottom: 50px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            display: none;
            max-height: 70vh;
            overflow-y: auto;
            width: 200px; /* Add this line to make it narrower */
        }
        
        .control-group {
            margin-bottom: 10px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 50px;
        }

        .control-group h4 {
            margin: 0 0 5px 0;
            font-size: 14px;
            color: #333;
        }

        .control-panel button {
            margin: 3px;
            padding: 5px 8px;
            cursor: pointer;
            border-radius: 3px;
            border: 1px solid #ccc;
            background: #f8f8f8;
        }

        .control-panel button:hover {
            background: #e8e8e8;
        }
        
        @media (max-width: 768px) {
            .info-panel {
                max-width: 150px;
                font-size: 10px;
            }
            .toggle-panel, .curtain-toggle, .controls-hint {
                font-size: 10px;
                padding: 3px 6px;
            }
        }
        .screenshot-btn {
        margin-top: 10px;
        padding: 5px 10px;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 3px;
        cursor: pointer;
        font-size: 12px;
        width: 100%;
        transition: background 0.3s;
    }
    
    .screenshot-btn:hover {
        background: #45a049;
    }
    
    .screenshot-message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 20px;
        border-radius: 5px;
        z-index: 1000;
        display: none;
        animation: fadeInOut 2s ease-in-out;
    }
    
    @keyframes fadeInOut {
        0% { opacity: 0; }
        20% { opacity: 1; }
        80% { opacity: 1; }
        100% { opacity: 0; }
    }

    .manual-btn {
        margin-top: 5px;
        padding: 5px 10px;
        background: #2196F3;
        color: white;
        border: none;
        border-radius: 3px;
        cursor: pointer;
        font-size: 12px;
        width: 100%;
        transition: background 0.3s;
    }

    .manual-btn:hover {
        background: #0b7dda;
    }

    .mute-btn {
        margin-top: 5px;
        padding: 5px 10px;
        background: #FF9800;
        color: white;
        border: none;
        border-radius: 3px;
        cursor: pointer;
        font-size: 12px;
        width: 100%;
        transition: background 0.3s;
    }

    .mute-btn:hover {
        background: #F57C00;
    }

    .mute-btn.muted {
        background: #f44336;
    }

    .mute-btn.muted:hover {
        background: #d32f2f;
    }

    .instruction-manual {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 1001;
        display: none;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        color: #333;
    }

    .instruction-manual h2 {
        margin-top: 0;
        color: #2196F3;
        border-bottom: 2px solid #2196F3;
        padding-bottom: 10px;
    }

    .instruction-manual h3 {
        color: #4CAF50;
        margin-top: 15px;
        margin-bottom: 5px;
    }

    .instruction-manual ul {
        margin: 5px 0;
        padding-left: 20px;
    }

    .instruction-manual li {
        margin-bottom: 5px;
    }

    .instruction-manual .close-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        background: #f44336;
        color: white;
        border: none;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        cursor: pointer;
        font-size: 18px;
        line-height: 1;
    }

    .instruction-manual .close-btn:hover {
        background: #d32f2f;
    }

    .instruction-manual .section {
        margin-bottom: 15px;
        padding: 10px;
        background: rgba(240, 240, 240, 0.5);
        border-radius: 5px;
    }

    .instruction-manual .new-feature {
        background: rgba(76, 175, 80, 0.1);
        border-left: 3px solid #4CAF50;
        padding: 8px;
        margin: 5px 0;
    }

    @media (max-width: 768px) {
        .instruction-manual {
            max-width: 90vw;
            max-height: 85vh;
            padding: 15px;
            font-size: 12px;
        }
    }
</style>
</head>
<body>
    <div class="window">
        <canvas id="gardenCanvas"></canvas>
        <div class="info-panel" id="infoPanel" style="display: none;">
            <h3>Garden Ecosystem</h3>
            <div id="stats"></div>
            <div style="margin: 10px 0; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; flex-direction: column; gap: 8px;">
                <label style="cursor: pointer; user-select: none;" title="Show Real-Time Clock & Forecast">
                    <input type="checkbox" id="clockToggle" style="margin-right: 5px;">
                    🕐
                </label>
                <label style="cursor: pointer; user-select: none;" title="Show Garden Diary">
                    <input type="checkbox" id="diaryToggle" style="margin-right: 5px;">
                    📖
                </label>
            </div>
            <button id="screenshotBtn" class="screenshot-btn">📷 Take Screenshot</button>
            <button id="manualBtn" class="manual-btn">📖 Guide & Features</button>
            <button id="muteBtn" class="mute-btn">🔊 Mute</button>
        </div>
        <!-- Add missing toggle buttons -->
        <button id="toggleInfo" class="toggle-panel">ℹ️ Show Info</button>
        <button id="toggleMushroom" class="toggle-panel" style="display: none; top: 60px; background-color: #f8f8f8;">🍄 Mushroom Mode</button>
       
      
        <div class="control-panel" id="controlPanel">
            <div style="text-align: right; margin-bottom: 10px;">
                <button id="keepVisualsBtn">👁️ Close ("C" to bring panel back)</button>
            </div>
            <button id="addBirdBtn">🐦 Add Bird</button>
            <button id="addFoodBtn">🌽 Scatter Food</button>
            <button id="toggleRainBtn">☔ Toggle Rain</button>
            <button id="spawnWormBtn">🪱 Spawn Worms</button>
            <button id="spawnAntsBtn">🐜 Spawn Ants</button>
            <button id="addBabyBirdBtn">🐤 Add Baby Bird</button>
            <button id="addSquirrelBtn">🐿️ Add Squirrel</button>
            <button id="addRatKingBtn">👑🐀 Add Rat King</button>
            <button id="addSpecialTwigBtn">✨🌿 Add Special Twig</button>
            <button id="addBirdhouseBtn">🏠 Add Birdhouse</button>
            <button id="spawnOwlBtn">🦉 Spawn Owl</button>
            <button id="spawnScarecrowBtn">🧹 Create Scarecrow</button>
            <button id="toggleWindChimeBtn">🔔 Wind Chimes: OFF</button>
            <button id="toggleMushroomModeBtn">🍄 Mushroom Mode</button>
            <button id="spawnGameboyBtn">🎮 Spawn Gameboy</button>
            <button id="triggerPeckingBtn">🍽️ Trigger Pecking</button>
            <button id="testChirpBtn">🎵 Test Chirps</button>
            <button id="addRatBtn">🐀 Add Rat</button>
            <button id="spawnPondBtn">💧 Spawn Pond</button>
            <button id="spawnFrogBtn">🐸 Spawn Frog</button>
            <button id="spawnKoiBtn">🐟 Spawn Koi</button>
            <button id="triggerRainbowBtn">🌈 Trigger Rainbow</button>
        </div>

    <div id="screenshotMessage" class="screenshot-message">Screenshot saved!</div>

    <!-- Instruction Manual -->
    <div id="instructionManual" class="instruction-manual">
        <button class="close-btn" id="closeManualBtn">×</button>
        <h2>🌿 Garden View Ecosystem</h2>

        <div class="section">
            <p><em>A living, breathing ecosystem. The best way to experience it is to <strong>watch and observe</strong>.</em></p>

            <h3>⚡ Quick Start</h3>
            <ul>
                <li><strong>Click/Tap:</strong> Drop food for birds</li>
                <li><strong>Triple-click (top area):</strong> Open debug controls</li>
                <li><strong>Info button (ℹ️):</strong> See ecosystem stats and toggle clock display</li>
                <li><strong>Clock toggle:</strong> In info panel, enable real-time clock with weather forecast</li>
            </ul>

            <p><em>Want to know more? Expand the sections below:</em></p>
        </div>

        <details class="detail-section">
            <summary>🐦 Bird Behavior Systems</summary>
            <ul>
                <li><strong>States:</strong> Birds transition between Flying, Perched, Hopping, Pecking, Bathing, Feeding babies, Building nests, and Fleeing</li>
                <li><strong>Hunger:</strong> Birds actively seek food when hungry (worms, seeds, berries)</li>
                <li><strong>Nesting:</strong> Non-wild birds collect twigs to build nests in trees. Special golden twigs speed up construction</li>
                <li><strong>Parenting:</strong> Adult birds feed hungry baby birds, prioritizing critically hungry ones</li>
                <li><strong>Flocking:</strong> Birds of similar types recognize each other and coordinate behaviors</li>
                <li><strong>Ground behavior:</strong> Birds spend significant time hopping and pecking on the ground, foraging naturally</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>🎵 Musical Chirping & Communication</summary>
            <ul>
                <li><strong>Musical voices:</strong> Each bird has a unique voice (Melodic, Bright, Exotic, or Songbird)</li>
                <li><strong>Musical scales:</strong> Chirps use pentatonic, major, and minor scales for pleasant sounds</li>
                <li><strong>Ambient chirping:</strong> Birds chirp randomly while perched or idle</li>
                <li><strong>Visual notes:</strong> Musical notes appear above chirping birds</li>
                <li><strong>Chirp types:</strong>
                    <ul>
                        <li>🎵 <strong>Social</strong> - General communication</li>
                        <li>🌽 <strong>Food Call</strong> - "Found food here!"</li>
                        <li>📞 <strong>Contact Call</strong> - "Where is everyone?"</li>
                        <li>⚠️ <strong>Alert</strong> - Warning of danger</li>
                        <li>🏆 <strong>Victory</strong> - Won a territorial dispute</li>
                        <li>🛡️ <strong>Territorial</strong> - Defending territory</li>
                    </ul>
                </li>
                <li><strong>Synchronized chirping:</strong> Social chirps can trigger nearby birds to chirp back</li>
                <li><strong>Mute button:</strong> Available in info panel (🔊/🔇)</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>🌳 Trees & Environment</summary>
            <ul>
                <li><strong>Tree lifecycle:</strong> Trees age, produce flowers, and eventually fall. New trees regrow</li>
                <li><strong>Perching:</strong> Birds prefer shelter during rain/night, healthy trees during day</li>
                <li><strong>Branch traversal:</strong> Squirrels can jump between nearby trees</li>
                <li><strong>Flowers:</strong> Appear on healthy trees during the day, attract butterflies</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>💧 Water Systems & Ponds</summary>
            <ul>
                <li><strong>Puddles:</strong> Form during rain, birds bathe in them, evaporate over time</li>
                <li><strong>Ponds:</strong> Permanent water sources (10% chance to spawn on load or after 5 rains)</li>
                <li><strong>Koi fish:</strong> Swim in ponds, get excited when birds approach, and may jump out of water!</li>
                <li><strong>Frogs:</strong> Live near ponds, jump away from birds, croak warnings, catch ants</li>
                <li><strong>Bird interactions:</strong> Birds visit ponds to drink and bathe, can hop below ground to reach them</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>🐿️ Squirrels & Ground Creatures</summary>
            <ul>
                <li><strong>Squirrels:</strong> Wander, forage for nuts, climb trees, jump between branches</li>
                <li><strong>Nest raiding:</strong> Squirrels may damage bird nests if they share a tree</li>
                <li><strong>Bird interactions:</strong> Birds may chase squirrels from trees</li>
                <li><strong>Ants:</strong> Form colonies at ant hills, forage for food, frogs hunt them</li>
                <li><strong>Worms:</strong> Emerge from ground, more active at night and after rain</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>🦉 Nocturnal & Predators</summary>
            <ul>
                <li><strong>Owls:</strong> Hunt rats at night, may deliver gameboy after day 30</li>
                <li><strong>Rats:</strong> Scavenge on the ground, flee from owls and birds</li>
                <li><strong>Rat Kings:</strong> Rare, larger with crown, attract more rats and owls</li>
                <li><strong>Crows:</strong> Visit when worm population exceeds 30</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>☁️ Weather & Time</summary>
            <ul>
                <li><strong>Day/Night cycle:</strong> ~4 minutes per full cycle</li>
                <li><strong>Rain:</strong> Spawns puddles and worms, birds seek shelter</li>
                <li><strong>Thunder:</strong> Can occur during heavy rain with lightning strikes</li>
                <li><strong>Rainbow:</strong> Rare, appears after rain with right conditions</li>
                <li><strong>Night behaviors:</strong> Worms emerge, owls hunt, birds shelter in birdhouses</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>🏠 Birdhouses & Shelter</summary>
            <ul>
                <li><strong>Construction:</strong> Birds build birdhouses similar to nests using twigs</li>
                <li><strong>Shelter:</strong> During rain or night, birds seek birdhouses for protection</li>
                <li><strong>Capacity:</strong> Multiple birds can shelter together</li>
                <li><strong>Behavior:</strong> Birds sleep inside, emerge at dawn</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>📖 Garden Diary</summary>
            <ul>
                <li><strong>Auto-Generated Story:</strong> Click the 📖 button in info panel to view your garden's history</li>
                <li><strong>Event Chronicle:</strong> Major moments automatically recorded (births, nests, weather, visitors)</li>
                <li><strong>Bird Lineages:</strong> Birds receive names and track family generations (Ruby → Ruby Jr. → Ruby III)</li>
                <li><strong>Timeline View:</strong> See your garden's story unfold day by day</li>
                <li><strong>Family Trees:</strong> Watch bird families grow across generations</li>
                <li><strong>Milestone Tracking:</strong> First nest, pond formation, special events recorded</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>🎮 Special Features & Easter Eggs</summary>
            <ul>
                <li><strong>Real-Time Clock & Forecast:</strong> Toggle in info panel for a large transparent 24-hour clock with weather forecast. Birds perch on numbers! Clock chimes hourly with different melodies.</li>
                <li><strong>Gameboy:</strong> After day 30, an owl may deliver a magical gameboy. Click it to visit a 1-bit window game!</li>
                <li><strong>Mushroom Mode:</strong> Psychedelic visual mode with rainbow colors and bird trails. Find the magic mushroom to unlock!</li>
                <li><strong>Scarecrow:</strong> Birds avoid scarecrows. Stays for 1 day/night cycle</li>
                <li><strong>Butterflies:</strong> Flutter peacefully through the garden near flowers</li>
                <li><strong>Screenshots:</strong> Capture special moments with the 📷 button</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>💡 Tips & Strategies</summary>
            <ul>
                <li><strong>Building a thriving ecosystem:</strong> Add food regularly but don't overfeed. Let birds find their own rhythm</li>
                <li><strong>Nest success:</strong> Keep trees healthy, scatter twigs, minimize squirrel interference</li>
                <li><strong>Baby bird survival:</strong> Adult birds will feed babies automatically if food is available</li>
                <li><strong>Species diversity:</strong> Different bird species have different behaviors - observe closely!</li>
                <li><strong>Seasonal patterns:</strong> Watch how behavior changes with weather and time of day</li>
                <li><strong>Balance:</strong> Too many rats? Wait for owls. Too many worms? Crows will visit</li>
                <li><strong>Debug controls:</strong> Triple-click top of screen to access spawning, weather, and testing tools</li>
            </ul>
        </details>

        <details class="detail-section">
            <summary>📋 Recent Major Updates</summary>
            <ul>
                <li><strong>Hourly Musical Chimes (Latest):</strong> When clock is enabled, birds sing a different melody every hour from a rotating playlist of 24 songs. No repeats until all 24 are played!</li>
                <li><strong>Garden Diary System:</strong> Complete narrative tracking with auto-generated story entries, bird naming system with 80 names (nature + people), family lineage tracking across generations, and timeline view of major events.</li>
                <li><strong>24-Hour Clock Display:</strong> Clock now shows 24-hour format without AM/PM, double-sized for better visibility. Birds can perch on the massive numbers, which become more opaque when occupied.</li>
                <li><strong>Enhanced Ground Behaviors:</strong> Birds now land deeper into grass (40px below ground line), spend 50% more time on ground (90 seconds), and prefer resting under trees. More peaceful, natural ground activity.</li>
                <li><strong>Real-Time Clock & Weather Forecast:</strong> Large transparent clock in the sky with 3-icon weather forecast. Birds perch on clock numbers! Includes max history tracking for ponds, frogs, koi, and birdhouses.</li>
            </ul>
        </details>

        <div class="section philosophy">
            <p><strong>Relax. Watch. Enjoy. 🌿</strong></p>
        </div>
    </div>

    <!-- Garden Diary -->
    <div id="gardenDiary" class="instruction-manual" style="display: none;">
        <button class="close-btn" id="closeDiaryBtn">×</button>
        <h2>📖 Garden Diary</h2>

        <div class="section">
            <p><em>A chronicle of life in your garden ecosystem.</em></p>
            <p><strong>Day <span id="diaryDayCount">0</span></strong></p>
        </div>

        <div class="section">
            <h3>📜 Recent Events</h3>
            <div id="diaryEntries" style="max-height: 400px; overflow-y: auto; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                <p style="color: #999; font-style: italic;">Your garden story will appear here as events unfold...</p>
            </div>
        </div>

        <div class="section">
            <h3>🐦 Bird Families</h3>
            <div id="birdFamilies" style="max-height: 300px; overflow-y: auto; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                <p style="color: #999; font-style: italic;">Bird lineages will be tracked here...</p>
            </div>
        </div>

        <!-- Philosophy quote removed per user request -->
    </div>

    <script>
        // V38 // GAMEBOY BROUGHT BY OWL / 1BIT WINDOW LINK ADDED 
        //  - GROUND HOPPING wip // KING RAINBOWBIRD
        // // MUSHROOMS ADDED // need to fix mushroom mode SC drawings.... // SMALLER FOOD - LARGER LIMIT 
        // ANTS // HD SCREEN STRECH (?) // BALANCED TO BE MORE CHILL 
        // SCREEN SHOT / OWLS - NEED TO FIX OWL/RAT BEHAVIOR and WINDCHIMES 
        // SCARECROWS / RAINBOW
        // CROWS! // BUTTERFILES // STUCK BTW TWO CLOSE TREE FIX 
        // puddle fix hopefully / night worms / time added to info info / delayed birdhouse building 
        // further balance tweaks  - HAND BALANCED NUMBERS - LESS RAIN  // Addressing v25+ issues: bird movement improvements, better wing visuals, nest deterioration, 
        // adjusted squirrel and rat behaviors, wind chime refinements, and overall ecosystem balance
        
        // Debug mode with severity levels
        let debugMode = true; // Set to false in production
        let debugVisuals = false; // Start with debug visuals OFF

        const DEBUG_LEVELS = {
            INFO: 1,
            WARNING: 1,
            ERROR: 2
        };

        let currentDebugLevel = DEBUG_LEVELS.WARNING; // Only show warnings and errors by default
        
        // Limit Debug Logging with throttling
        window.debugLogThrottling = {};
        
        function debugLog(message, level = DEBUG_LEVELS.INFO) {
            if (debugMode && level >= currentDebugLevel) {
                // Add throttling for common messages to reduce console spam
                if (level === DEBUG_LEVELS.INFO) {
                    // Use message hashing to track frequency
                    const messageHash = message.split(' ')[0] + message.split(' ')[1];
                    const now = Date.now();
                    
                    // Only log this type of message once every 5 seconds
                    if (!window.debugLogThrottling[messageHash] || 
                        now - window.debugLogThrottling[messageHash] > 5000) {
                        console.log(`DEBUG: ${message}`);
                        window.debugLogThrottling[messageHash] = now;
                    }
                } else {
                    // Always log warnings and errors
                    console.log(`DEBUG: ${message}`);
                }
            }
        }

        // Info panel
        const infoPanel = document.getElementById('infoPanel');
        const toggleInfo = document.getElementById('toggleInfo');
        const statsDisplay = document.getElementById('stats');
        
        if (toggleInfo) {  // Add a safety check
            toggleInfo.addEventListener('click', () => {
                if (infoPanel.style.display === 'none') {
                    infoPanel.style.display = 'block';
                    toggleInfo.textContent = 'ℹ️ Hide Info';
                } else {
                    infoPanel.style.display = 'none';
                    toggleInfo.textContent = 'ℹ️ Show Info';
                }
            });
        }

        // Curtain toggle
        const toggleCurtains = document.getElementById('toggleCurtains');
        let showCurtains = false;
        
        if (toggleCurtains) {  // Add a safety check
            toggleCurtains.addEventListener('click', () => {
                showCurtains = !showCurtains;
                toggleCurtains.textContent = showCurtains ? '🪟 Hide Curtains' : '🪟 Show Curtains';
            });
        }

        // Debug toggle with keyboard
        function updateDebugVisuals() {
            // Update the controls hint visibility based on debug state
            const controlsHint = document.getElementById('controlsHint');
            if (controlsHint) {  // Add a safety check
                controlsHint.style.display = 'block'; // Always show the controls hint
                if (debugVisuals) {
                    controlsHint.textContent = "Debug visuals ON (T to toggle)";
                } else {
                    controlsHint.textContent = "Tap/Click to add food";
                }
            }
            
            // Show or hide control panel based on debug mode
            const controlPanel = document.getElementById('controlPanel');
            const keepVisualsActive = document.getElementById('keepVisualsActive');
            
            if (controlPanel) {  // Add a safety check
                if (debugVisuals && !keepVisualsActive) {
                    controlPanel.style.display = 'block';
                } else {
                    controlPanel.style.display = 'none';
                }
            }
        }
        
// ADD YOUR NEW FUNCTION RIGHT HERE:
function activateMushroomMode() {
    // Start mushroom mode
    mushroomMode = true;
    colorCycleTimer = 0;
    
    // Show the toggle button
    const toggleMushroom = document.getElementById('toggleMushroom');
    if (toggleMushroom) {
        toggleMushroom.style.display = 'block';
    }
    
    // Hide the mushroom object
    magicMushroom = null;
    
    // Add special effects for activation
    for (let i = 0; i < 10; i++) {
        setTimeout(() => {
            addSpecialEffect({
                type: 'sparkle',
                x: canvas.width / 2,
                y: canvas.height / 2,
                duration: 3000,
                intensity: 0.8
            });
        }, i * 300);
    }

    debugLog("🍄 Mushroom mode activated! Groovy!");
    addDiaryEntry("The magic mushroom reveals psychedelic wonders! Reality becomes a rainbow.", 'special');
}


        // Draw off-screen indicator circles in debug mode
        function drawOffscreenIndicators() {
            if (!debugVisuals) return;
            
            const margin = 30; // Distance from edge of screen
            
            // Check for off-screen birds
            for (const bird of birds) {
                if (bird.x < 0 || bird.x > canvas.width || bird.y < 0 || bird.y > canvas.height) {
                    // Determine indicator position on screen edge
                    let indicatorX = bird.x;
                    let indicatorY = bird.y;
                    
                    // Clamp to screen edge with margin
                    if (bird.x < 0) indicatorX = margin;
                    if (bird.x > canvas.width) indicatorX = canvas.width - margin;
                    if (bird.y < 0) indicatorY = margin;
                    if (bird.y > canvas.height) indicatorY = canvas.height - margin;
                    
                    // Draw indicator circle
                    ctx.beginPath();
                    ctx.arc(indicatorX, indicatorY, 10, 0, Math.PI * 2);
                    ctx.fillStyle = bird.birdType.bodyColor;
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw arrow pointing to off-screen bird
                    const angle = Math.atan2(bird.y - indicatorY, bird.x - indicatorX);
                    ctx.beginPath();
                    ctx.moveTo(indicatorX, indicatorY);
                    ctx.lineTo(
                        indicatorX + Math.cos(angle) * 8,
                        indicatorY + Math.sin(angle) * 8
                    );
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            // For other entities like rats or squirrels
            for (const rat of rats) {
                if (rat.x < 0 || rat.x > canvas.width || rat.y < 0 || rat.y > canvas.height) {
                    let indicatorX = rat.x;
                    let indicatorY = rat.y;
                    
                    if (rat.x < 0) indicatorX = margin;
                    if (rat.x > canvas.width) indicatorX = canvas.width - margin;
                    if (rat.y < 0) indicatorY = margin;
                    if (rat.y > canvas.height) indicatorY = canvas.height + margin;
                    
                    ctx.beginPath();
                    ctx.arc(indicatorX, indicatorY, 8, 0, Math.PI * 2);
                    ctx.fillStyle = rat.isRatKing ? '#4B0082' : '#696969';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            for (const squirrel of squirrels) {
                if (squirrel.x < 0 || squirrel.x > canvas.width || squirrel.y < 0 || squirrel.y > canvas.height) {
                    let indicatorX = squirrel.x;
                    let indicatorY = squirrel.y;
                    
                    if (squirrel.x < 0) indicatorX = margin;
                    if (squirrel.x > canvas.width) indicatorX = canvas.width - margin;
                    if (squirrel.y < 0) indicatorY = margin;
                    if (squirrel.y > canvas.height) indicatorY = margin;
                    
                    ctx.beginPath();
                    ctx.arc(indicatorX, indicatorY, 8, 0, Math.PI * 2);
                    ctx.fillStyle = '#B25D18';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }

        // Enhanced debugging mode toggle with 'd' key
        document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        // Escape key: close all UI elements for clean view
        const instructionManual = document.getElementById('instructionManual');
        const gardenDiary = document.getElementById('gardenDiary');
        const infoPanel = document.getElementById('infoPanel');
        const toggleInfo = document.getElementById('toggleInfo');
        const diaryToggle = document.getElementById('diaryToggle');

        // Close guide/features menu
        if (instructionManual && instructionManual.style.display === 'block') {
            instructionManual.style.display = 'none';
            debugLog("Guide menu closed with Escape");
        }

        // Close diary
        if (gardenDiary && gardenDiary.style.display === 'block') {
            gardenDiary.style.display = 'none';
            if (diaryToggle) diaryToggle.checked = false;
            debugLog("Diary closed with Escape");
        }

        // Close info panel
        if (infoPanel && infoPanel.style.display === 'block') {
            infoPanel.style.display = 'none';
            debugLog("Info panel closed with Escape");
        }

        // Hide show info button for UI-free view
        if (toggleInfo && toggleInfo.style.display !== 'none') {
            toggleInfo.style.display = 'none';
            window.showInfoButtonHidden = true;
            debugLog("Show info button hidden with Escape - click anywhere to restore");
        }
    } else if (e.key === 't' || e.key === 'T') {
        debugVisuals = !debugVisuals;
        updateDebugVisuals();
    } else if (e.key === 'd' || e.key === 'D') {
        // Toggle advanced debugging with performance stats
        debugVisuals = !debugVisuals;

        if (debugVisuals) {
            // Add additional debug info display
            let debugInfo = document.getElementById('advancedDebug');
            if (!debugInfo) {
                debugInfo = document.createElement('div');
                debugInfo.id = 'advancedDebug';
                debugInfo.style.position = 'absolute';
                debugInfo.style.top = '50px';
                debugInfo.style.right = '10px';
                debugInfo.style.background = 'rgba(0, 0, 0, 0.1)';
                debugInfo.style.color = 'white';
                debugInfo.style.padding = '10px';
                debugInfo.style.borderRadius = '5px';
                debugInfo.style.zIndex = '100';
                debugInfo.style.fontSize = '10px';
                debugInfo.style.maxWidth = '200px';
                document.body.appendChild(debugInfo);
            }
        } else {
            const debugElement = document.getElementById('advancedDebug');
            if (debugElement) debugElement.remove();
        }

        updateDebugVisuals();
    } else if (e.key === 'c' || e.key === 'C') {
        // Restore control panel functionality
        const keepVisualsElem = document.getElementById('keepVisualsActive');
        if (keepVisualsElem) {
            keepVisualsElem.remove();
            debugLog("Control panel functionality restored");
            updateDebugVisuals(); // Update UI state
        }
    }
});




function drawBirdTrails() {
    if (!mushroomMode) return; // Only draw trails in mushroom mode
    
    // Draw each trail
    for (const trail of birdTrails) {
        if (trail.positions.length < 2) continue; // Need at least 2 points for a trail
        
        // Create a gradient for the trail
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // Draw each segment with decreasing opacity
        for (let i = 1; i < trail.positions.length; i++) {
            const pos = trail.positions[i];
            const prevPos = trail.positions[i-1];
            
            // Calculate opacity based on position in trail (newer = more opaque)
            // Make trails fade more gradually by using a slower decay
            const opacity = Math.min(1, i / (trail.positions.length * 0.7)); // Slower decay
            
            // Get color based on time and position for rainbow effect
            const hue = (colorCycleTimer / 50 + i * 15) % 360;
            ctx.strokeStyle = `hsla(${hue}, 100%, 70%, ${opacity})`;
            
            // Draw line segment
            ctx.beginPath();
            ctx.moveTo(prevPos.x, prevPos.y);
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
        }
    }
    
    // Reset line properties
    ctx.lineWidth = 1;
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';
}


function updateBirdTrails() {
    if (!mushroomMode) {
        // Clear trails when not in mushroom mode to save memory
        birdTrails = [];
        return;
    }

    // PERFORMANCE OPTIMIZATION: Check if we have too many trail segments across all birds
    // Count total trail points to ensure we don't exceed a reasonable limit
    let totalTrailPoints = 0;
    for (const trail of birdTrails) {
        totalTrailPoints += trail.positions.length;
    }
    
    // If we have too many points, aggressively trim all trails
    const MAX_TOTAL_TRAIL_POINTS = 1000; // Hard cap on total trail points for performance
    if (totalTrailPoints > MAX_TOTAL_TRAIL_POINTS) {
        // Trim all trails by removing 25% of their oldest points
        for (const trail of birdTrails) {
            if (trail.positions.length > 10) { // Keep at least 10 points
                const pointsToRemove = Math.floor(trail.positions.length * 0.25);
                trail.positions.splice(0, pointsToRemove);
            }
        }
        debugLog(`Performance: Trimmed bird trails (${totalTrailPoints} points)`);
    }
    
    // Initialize trail array if needed
    if (birdTrails.length === 0) {
        for (let i = 0; i < birds.length; i++) {
            birdTrails.push({
                birdIndex: i,
                positions: []
            });
        }
    }
    
    // Make sure we have a trail for each bird
    while (birdTrails.length < birds.length) {
        birdTrails.push({
            birdIndex: birdTrails.length,
            positions: []
        });
    }
    
    // Remove trails for birds that no longer exist
    birdTrails = birdTrails.filter(trail => trail.birdIndex < birds.length);
    
    // Update each trail with current bird positions
    for (let i = 0; i < birds.length; i++) {
        const bird = birds[i];
        const trail = birdTrails.find(t => t.birdIndex === i);
        
        if (trail) {
            // Only add a new position if the bird has moved significantly
            const lastPos = trail.positions[trail.positions.length - 1];
            if (!lastPos || distance(bird.x, bird.y, lastPos.x, lastPos.y) > 2) {
                // Add current position to the end
                trail.positions.push({
                    x: bird.x,
                    y: bird.y
                });
                
                // Only limit trail length if positions exceed MAX_TRAIL_LENGTH by a lot
                // This makes trails fade away much more slowly
                if (trail.positions.length > MAX_TRAIL_LENGTH * 2) {
                    // Remove oldest positions, but keep more positions than before
                    trail.positions.splice(0, Math.floor(trail.positions.length * 0.1)); // Remove just 10% of oldest positions
                }
            }
        }
    }
}




        // Update advanced debug stats
        function updateAdvancedDebug(deltaTime) {
            if (!debugVisuals) return;
            
            const debugElement = document.getElementById('advancedDebug');
            if (!debugElement) return;
            
            // Count bird states
            const birdStates = {};
            birds.forEach(bird => {
                birdStates[bird.state] = (birdStates[bird.state] || 0) + 1;
            });
            
            // Format bird states
            let birdStateText = '';
            for (const [state, count] of Object.entries(birdStates)) {
                birdStateText += `${state}: ${count}<br>`;
            }
            
            // Compute performance metrics
            const fps = Math.round(1000 / deltaTime);
            
            debugElement.innerHTML = `
                <strong>Performance:</strong>
                <ul>
                    <li>FPS: ${fps}</li>
                    <li>Entities: ${birds.length + babyBirds.length + worms.length + twigs.length + nests.length}</li>
                </ul>
                <strong>Bird States:</strong><br>
                ${birdStateText}
                <strong>Baby Birds:</strong> ${babyBirds.length}<br>
                <strong>Nest Completion:</strong><br>
                ${nests.map(n => Math.round(n.materialsCollected / NEST_MATERIALS_NEEDED * 100) + '%').join(', ')}
            `;
        }

        function updateStats() {
        
        if (infoPanel.style.display === 'none') return;
    
        // Calculate AM/PM time from currentHour
        let displayHour12 = currentHour % 12;
        if (displayHour12 === 0) displayHour12 = 12; // 0 should display as 12 in 12-hour format
        const amPm = currentHour < 12 ? 'AM' : 'PM';
        
        // 24-hour format is just currentHour
        const displayHour24 = currentHour;
        
        // Calculate minutes (approximation based on timeOfDay)
        const timeOfDayFraction = timeOfDay < 1 ? timeOfDay * 12 : 12 + (timeOfDay - 1) * 12;
        const minuteFraction = timeOfDayFraction - Math.floor(timeOfDayFraction);
        const minutes = Math.floor(minuteFraction * 60);
        
        // Update history maxes
        maxTreesEver = Math.max(maxTreesEver, trees.length);
        maxBirdsEver = Math.max(maxBirdsEver, birds.length);
        maxSquirrelsEver = Math.max(maxSquirrelsEver, squirrels.length);
        maxRatsEver = Math.max(maxRatsEver, rats.length);
        maxWormsEver = Math.max(maxWormsEver, worms.length);
        maxFlowersEver = Math.max(maxFlowersEver, flowers.length);
        maxNestsEver = Math.max(maxNestsEver, nests.length);
        maxPondsEver = Math.max(maxPondsEver, ponds.length);
        maxFrogsEver = Math.max(maxFrogsEver, frogs.length);
        maxKoiEver = Math.max(maxKoiEver, koi.length);
        maxBirdhousesEver = Math.max(maxBirdhousesEver, birdhouses.length);

        statsDisplay.innerHTML = `
    <strong>Entities (Current / Max):</strong>
    <ul>
        <li>Trees: ${trees.length} / ${maxTreesEver}</li>
        <li>Birds: ${birds.length} / ${maxBirdsEver}</li>
        <li>Baby Birds: ${babyBirds.length} (Total Born: ${totalBabiesBorn})</li>
        <li>Nests: ${nests.length} / ${maxNestsEver}</li>
        <li>Birdhouses: ${birdhouses.length} / ${maxBirdhousesEver}</li>
        <li>Worms: ${worms.length} / ${maxWormsEver}</li>
        <li>Twigs: ${twigs.length}</li>
        <li>Rats: ${rats.length} / ${maxRatsEver}</li>
        <li>Squirrels: ${squirrels.length} / ${maxSquirrelsEver}</li>
        <li>Puddles: ${puddles.length}</li>
        <li>Ponds: ${ponds.length} / ${maxPondsEver}</li>
        <li>Frogs: ${frogs.length} / ${maxFrogsEver}</li>
        <li>Koi: ${koi.length} / ${maxKoiEver}</li>
        <li>Food: ${foodItems.length}</li>
        <li>Flowers: ${flowers.length} / ${maxFlowersEver}</li>
    </ul>
    <strong>Time:</strong> ${timeOfDay < 1 ? 'Day' : 'Night'} (${displayHour12}:${minutes.toString().padStart(2, '0')})<br>
    <strong>Weather:</strong> ${isRaining ? (isThundering ? 'Thunderstorm' : 'Raining') : 'Clear'}<br>
    <strong>Days Elapsed:</strong> ${dayNightCycleCount}<br>
    <strong>Rainbows Seen:</strong> ${rainbowsShown}
`;
    }

// Gameboy object and tracking variables
let gameboy = null;
let gameboyOwlDelivered = false;

// Function to spawn the gameboy
function spawnGameboy(x, y, byOwl = false) {
    // If no coords provided, use center of screen
    if (!x || !y) {
        x = canvas.width / 2;
        y = canvas.height * GROUND_HEIGHT_RATIO - 20;
    }
    
    gameboy = {
        x: x,
        y: y,
        width: 30,
        height: 45,
        bobTimer: 0,
        glowTimer: 0,
        byOwl: byOwl,
        clicked: false
    };
    
    // Add sparkle effect
    addSpecialEffect({
        type: 'sparkle',
        x: x,
        y: y - 20,
        duration: 2000,
        intensity: 0.7
    });
    
    debugLog(`Gameboy spawned at (${x}, ${y})${byOwl ? ' by an owl' : ''}`);
}

// Draw the gameboy
function drawGameboy() {
    if (!gameboy) return;
    
    // Simple bobbing animation
    gameboy.bobTimer += 0.03;
    const bobAmount = Math.sin(gameboy.bobTimer) * 2;
    
    // Gameboy body
    ctx.fillStyle = mushroomMode ? getMushroomColor('#333333') : '#333333';
    ctx.fillRect(
        gameboy.x - gameboy.width/2, 
        gameboy.y - gameboy.height + bobAmount, 
        gameboy.width, 
        gameboy.height
    );
    
    // Screen
    ctx.fillStyle = mushroomMode ? getMushroomColor('#7BBA71') : '#7BBA71'; // Classic greenish screen
    ctx.fillRect(
        gameboy.x - gameboy.width/2 + 5, 
        gameboy.y - gameboy.height + 5 + bobAmount, 
        gameboy.width - 10, 
        gameboy.height/2 - 5
    );
    
    // D-pad
    ctx.fillStyle = mushroomMode ? getMushroomColor('#222222') : '#222222';
    ctx.fillRect(
        gameboy.x - gameboy.width/2 + 5, 
        gameboy.y - gameboy.height/2 + 5 + bobAmount, 
        12, 
        12
    );
    
    // A/B buttons
    ctx.beginPath();
    ctx.arc(
        gameboy.x + gameboy.width/2 - 10, 
        gameboy.y - gameboy.height/2 + 8 + bobAmount, 
        4, 0, Math.PI * 2
    );
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(
        gameboy.x + gameboy.width/2 - 8, 
        gameboy.y - gameboy.height/2 + 15 + bobAmount, 
        4, 0, Math.PI * 2
    );
    ctx.fill();
    
    // Start/Select
    ctx.fillRect(
        gameboy.x - 12, 
        gameboy.y - 5 + bobAmount, 
        8, 
        3
    );
    
    ctx.fillRect(
        gameboy.x + 4, 
        gameboy.y - 5 + bobAmount, 
        8, 
        3
    );
    
    // Optional glow effect
    if (mushroomMode || gameboy.glowTimer > 0) {
        gameboy.glowTimer++;
        const glowOpacity = 0.3 + Math.sin(gameboy.glowTimer * 0.05) * 0.2;
        
        ctx.fillStyle = `rgba(200, 255, 200, ${glowOpacity})`;
        ctx.beginPath();
        ctx.arc(
            gameboy.x, 
            gameboy.y - gameboy.height/2 + bobAmount, 
            gameboy.width, 
            0, Math.PI * 2
        );
        ctx.fill();
    }
    
    // Draw debug click hint
    if (debugVisuals) {
        ctx.fillStyle = 'white';
        ctx.font = '10px Arial';
        ctx.fillText('Click to play', gameboy.x - 25, gameboy.y - gameboy.height - 10 + bobAmount);
    }
}

// Check for owl delivery of gameboy
function checkOwlGameboyDelivery() {
    // Only try to deliver if gameboy doesn't exist and hasn't been delivered yet
    if (gameboy || gameboyOwlDelivered) return;
    
    // Check if we're past day 30
    if (dayNightCycleCount >= 30) {
        // Small chance for an owl to bring the gameboy
        if (timeOfDay >= 1 && Math.random() < 0.1 && owls.length === 0) {
            // Create a special owl to deliver the gameboy
            const side = Math.random() < 0.5 ? 'left' : 'right';
            const x = side === 'left' ? -30 : canvas.width + 30;
            const y = canvas.height * 0.3 + Math.random() * 100;
            
            const owl = new Owl(x, y);
            owl.isDelivering = true; // Special property
            owls.push(owl);
            
            // Override the owl's update method to make it drop the gameboy
            const originalUpdate = owl.update;
            owl.update = function(deltaTime) {
                // If in middle of screen, drop the gameboy
                if (!gameboyOwlDelivered && 
                    this.x > canvas.width * 0.4 && 
                    this.x < canvas.width * 0.6) {
                    
                    spawnGameboy(this.x, canvas.height * GROUND_HEIGHT_RATIO - 20, true);
                    gameboyOwlDelivered = true;
                    this.isDelivering = false;

                    // Add diary entry for gameboy delivery
                    addDiaryEntry("An owl delivered a mysterious gameboy from the skies!", 'special');

                    // Play a special sound if wind chimes enabled
                    if (windChimeEnabled && audioContext) {
                        const notes = ['C4', 'G4', 'C5'];
                        for (let i = 0; i < notes.length; i++) {
                            setTimeout(() => {
                                playNote(notes[i], 0.8);
                            }, i * 150);
                        }
                    }
                }
                
                // Call original update
                return originalUpdate.call(this, deltaTime);
            }
            
            // Override the draw method to show the owl carrying something
            const originalDraw = owl.draw;
            owl.draw = function() {
                originalDraw.call(this);
                
                // Draw small package under owl if still delivering
                if (this.isDelivering) {
                    ctx.fillStyle = '#333333';
                    ctx.fillRect(
                        this.x - 15, 
                        this.y + 20, 
                        30, 
                        15
                    );
                    
                    // String connecting to owl
                    ctx.strokeStyle = '#CCCCCC';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + 5);
                    ctx.lineTo(this.x, this.y + 20);
                    ctx.stroke();
                }
            }
            
            debugLog("Special owl bringing Gameboy has appeared!");
        }
    }
}

// Check for gameboy clicks
function checkGameboyClicks(x, y) {
    if (!gameboy) return false;
    
    // Check if click is on gameboy
    if (x >= gameboy.x - gameboy.width/2 && 
        x <= gameboy.x + gameboy.width/2 && 
        y >= gameboy.y - gameboy.height && 
        y <= gameboy.y) {
        
        // List of URLs to randomly choose from
        const gameUrls = [
            "https://www.emptyspeechbubble.com/1bitcat",
            "https://www.emptyspeechbubble.com/1bitwindow",
            "https://www.emptyspeechbubble.com/bba",
            "https://www.emptyspeechbubble.com/bb2",
            
            // Add more URLs as needed
        ];
        
        // Randomly select a URL from the array
        const randomUrl = gameUrls[Math.floor(Math.random() * gameUrls.length)];
        
        // Open the randomly selected URL in a new window
        window.open(randomUrl, "_blank");
        
        // Visual feedback
        gameboy.glowTimer = 1;
        
        debugLog(`Gameboy clicked, opening ${randomUrl}`);
        return true;
    }
    
    return false;
}

// Update function to add to main loop
function updateGameboy(deltaTime) {
    // Check for owl delivery
    checkOwlGameboyDelivery();
    
    // Draw gameboy if it exists
    if (gameboy) {
        drawGameboy();
    }
}
        // Animation control
        let animationRunning = false;
        let animationTimers = [];

        // Improved timer management - helper function for adding timers with proper type tracking
        function addTimer(timer, isInterval = false) {
            const timerObj = { id: timer, isInterval: isInterval };
            animationTimers.push(timerObj);
        }
        
        // Improved stopAnimation function to handle both types properly
        function stopAnimation() {
            animationRunning = false;
            
            // Properly clear all timers based on their type
            animationTimers.forEach(timer => {
                if (timer.isInterval) {
                    clearInterval(timer.id);
                } else {
                    clearTimeout(timer.id);
                }
            });
            
            animationTimers = [];
            debugLog("Animation stopped");
        }

        // Enable full screen mode on mobile
        function enableFullscreen() {
            const elem = document.documentElement;
            
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) { /* Safari */
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) { /* IE11 */
                elem.msRequestFullscreen();
            }
        }

        // Check if mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (isMobile) {
            document.addEventListener('touchstart', function() {
                // Try to enable fullscreen on first touch
                if (!document.fullscreenElement) {
                    enableFullscreen();
                }
            }, {once: true});
        }

        // Canvas setup with error handling
        const canvas = document.getElementById('gardenCanvas');
        if (!canvas) throw new Error("Canvas element not found!");
        debugLog("Canvas element found.");

        const ctx = canvas.getContext('2d');
        if (!ctx) throw new Error("Could not get 2D rendering context!");
        debugLog("2D rendering context acquired.");

        // Initialize canvas size immediately
        function initializeCanvasSize() {
            // Immediate sizing on page load
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Set initial reference sizes
            originalWidth = window.innerWidth;
            originalHeight = window.innerHeight;
            
            debugLog(`Canvas initialized to full screen: ${canvas.width}x${canvas.height}`);
        }
        
        // Global variables
        let worms = [];
        let birdPoops = [];
        let rats = [];
        let trees = [];
        let twigs = [];
        let butterflies = [];
const MAX_BUTTERFLIES = 10;
const dayNightDuration = 240000; // 4 minutes for a full day/night cycle
let owls = []; // Array to hold owls
const MAX_OWLS = 2; // Maximum number of owls at once
const OWL_SPAWN_CHANCE = 0.008; // Base chance per check
const RAT_KING_OWL_ATTRACTION = 0.2; // Higher chance of owl spawning when rat king present
        let lightningStrikes = [];
        let birds = [];
        let babyBirds = [];
        let squirrels = [];
        let foodItems = [];
        let nests = [];
        let birdhouses = [];
        let puddles = [];
        let ponds = []; // Array for permanent ponds
        let frogs = []; // Array for frogs
        let koi = []; // Array for koi fish
        let flowers = []; // Array for flowers
        let specialEffects = []; // Added for special visual effects
        let crows = [];
let crowVisitInProgress = false;
let crowVisitTimer = 0;
const CROW_VISIT_DURATION = 60000; // 1 minute crow visit
const CROW_WORM_THRESHOLD = 30; // Spawn crows when worms exceed this number
const MAX_CROWS = 7; // Size of a murder of crows
let antHill = null;
let ants = [];

        let isTabVisible = true; // Add this line here
        let totalBabiesBorn = 0; // Track total babies born counter

        // History tracking - maximum counts ever seen
        let maxTreesEver = 0;
        let maxBirdsEver = 0;
        let maxSquirrelsEver = 0;
        let maxRatsEver = 0;
        let maxWormsEver = 0;
        let maxFlowersEver = 0;
        let maxNestsEver = 0;
        let maxPondsEver = 0;
        let maxFrogsEver = 0;
        let maxKoiEver = 0;
        let maxBirdhousesEver = 0;

        let mushroomMode = false;
let colorCycleTimer = 0;
let lastColorCycleUpdate = 0;
let magicMushroomAppeared = false;
let magicMushroom = null;
let hadRainbow = false;
let hadAnts = false
let birdTrails = []; // Will store past positions of birds
const MAX_TRAIL_LENGTH = 100; // How many past positions to remember
let mushroomEffectSpeed = 0.03; // Control speed of mushroom mode effects
let playingTheHits = false; // Flag to disable random chirps during playthehits performance

// Rainbow variables
let rainbowVisible = false;
let rainbowOpacity = 0;
let rainbowTimer = 0;
let rainbowDuration = dayNightDuration; // Rainbow lasts for a full day/night cycle instead of 60000ms

// Scarecrow variables
let scarecrow = null;
let scarecrowCreated = false;
        
        let isRaining = false;
let isThundering = false;
let wasRaining = false;  // Track rain state change
let tallTreeCount = 0;
let simulationTime = 0; // Track total simulation time for better spawning control
let lastStatsUpdate = 0; // Track when we last updated the stats display
let cloudCover = 0; // For weather transition effects
let isMuted = false; // Global mute state for all audio

// === NEW BIRD BEHAVIOR SYSTEMS ===
// Danger zone memory - shared across all birds
let dangerZones = []; // {x, y, timestamp, threatType}
const DANGER_MEMORY_DURATION = 180000; // Remember danger for 3 minutes
const DANGER_ZONE_RADIUS = 150; // How far to avoid danger zones

// Shared flock knowledge for food locations
let sharedFoodKnowledge = []; // {x, y, timestamp, discoveredBy}
const FOOD_KNOWLEDGE_DURATION = 120000; // Share food knowledge for 2 minutes

// Chirp types for different communication
const CHIRP_TYPES = {
    SOCIAL: 'social',
    FOOD_CALL: 'food_call',
    CONTACT_CALL: 'contact_call',
    ALERT: 'alert',
    TERRITORIAL: 'territorial',
    VICTORY: 'victory'
};

// Active chirps in the world
let activeChirps = []; // {x, y, type, timestamp, birdId}

// Sentinel rotation tracking
let currentSentinels = new Map(); // Maps flock groups to sentinel bird
let sentinelRotationTimers = new Map(); // Track when to rotate sentinel

// Mobbing coordination
let activeMobbings = []; // {targetX, targetY, participants: [], startTime}

// Territorial disputes tracking
let territorialDisputes = []; // {bird1, bird2, location, startTime}

// Constants for new behaviors
const SENTINEL_ROTATION_INTERVAL = 25000; // 25 seconds
const MOBBING_DURATION = 12000; // 12 seconds
const MOBBING_DIVE_FREQUENCY = 2000; // Dive every 2 seconds
const GROUND_ESCAPE_DELAY = 250; // 250ms delay for ground birds
const PECKING_INTERVAL_SOLO = 800; // Solo bird pecking speed
const PECKING_INTERVAL_GROUP = 500; // Group feeding pecking speed
const FLOCK_DISTANCE = 200; // Birds within this distance are considered flockmates
const CONTACT_CALL_DISTANCE = 150; // Call when flockmates are this far
const TERRITORIAL_DISPLAY_DURATION = 3000; // 3 seconds
const FEAR_OVERRIDE_HUNGER = 600; // Hunger level that overrides fear
let currentHour = 9; // Track the hour of day (0-23)
let lastHourlyUpdate = 0; // Track when we last updated the hourly activities
let timeOfDay = 0.75; // Track day/night cycle (0-1 = day, 1-2 = night)
let previousTimeOfDay = 0.75; // For tracking day/night transitions
let dayNightCycleCount = 0; // Count completed day/night cycles
let rainbowsShown = 0; // Track number of rainbows that have appeared
let rainsCompleted = 0; // Track number of completed rain events (for pond formation)
        
        // Wind Chime Sound Effect System
        let windChimeEnabled = false;

        // Clock and Weather Forecast System
        let clockEnabled = false;
        let weatherForecast = []; // Array of {type: 'rain'|'thunder'|'clear', time: timestamp}
        let nextWeatherEvents = []; // Next 3 upcoming events for display
        let lastHourChimed = -1; // Track last hour that played a melody
        let hourlyMelodyPlaylist = []; // Shuffled playlist of 24 melodies
        let melodyPlaylistIndex = 0; // Current position in playlist

        // Garden Diary System
        let diaryEntries = []; // Array of {day: number, event: string, timestamp: number, type: string}
        let birdNames = []; // Pool of bird names
        let birdFamilies = new Map(); // Map bird ID to family info {name, generation, parents}
        let lastDiaryUpdate = 0;

        // Bird name pools (nature names + normal people names)
        const BIRD_NAME_POOL = [
            // Nature-inspired names
            'Ruby', 'Sky', 'Pepper', 'Sunny', 'Cloud', 'Storm', 'Willow', 'Cedar',
            'Maple', 'Birch', 'Ash', 'Rowan', 'Luna', 'Sol', 'Star', 'Dawn',
            'Dusk', 'River', 'Brook', 'Meadow', 'Forest', 'Sage', 'Basil', 'Rosemary',
            'Jasper', 'Onyx', 'Pearl', 'Amber', 'Jade', 'Coral', 'Ivy', 'Fern',
            'Thistle', 'Clover', 'Poppy', 'Daisy', 'Violet', 'Lily', 'Rose', 'Iris',
            // Normal/office/real-life people names
            'Alex', 'Sam', 'Jordan', 'Taylor', 'Morgan', 'Casey', 'Riley', 'Quinn',
            'Charlie', 'Jamie', 'Blake', 'Drew', 'Parker', 'Avery', 'Reese', 'Harper',
            'Elliot', 'Skylar', 'Peyton', 'Cameron', 'Dakota', 'Rowan', 'Sage', 'River',
            'Finley', 'Hayden', 'Logan', 'Ryan', 'Jesse', 'Kelly', 'Terry', 'Robin',
            'Pat', 'Chris', 'Nico', 'Ash', 'Jules', 'Max', 'Lee', 'Ray'
        ];
        let windChimeSounds = [];
        let windChimeTimeout = null;
        let lastWindChimeTime = 0;
        let windChimeStartTime = 0; // When wind chimes were turned on
        let windChimeDuration = 15 * 60 * 1000; // 15 minutes in milliseconds
        
        // Audio system for wind chimes
        let audioContext = null;
        
        // Original viewport size to maintain proper object scale
        let originalWidth = window.innerWidth;
        let originalHeight = window.innerHeight;

        // Call this function right after getting the context
        initializeCanvasSize();

        // Update constants for better ecosystem balance
        const GROUND_HEIGHT_RATIO = 0.75;
        const BIRD_MAX_HUNGER = 800;
        const BIRD_HUNGER_RATE = 0.006; // Further reduced from 0.02 to encourage less food hunting
        const HUNGER_CRITICAL_THRESHOLD = 300;
        const BIRD_POOP_DELAY = 360000; // 6 minutes between poops
        const TREE_DEGRADATION_RATE = 0.25;
        const TREE_HEALTH_THRESHOLD = 0;
        const BIRD_VISION_RADIUS = 500;
        const BIRD_FOOD_VISION_RADIUS = 1200;
        const RAT_VISION_RADIUS = 80;
        const SQUIRREL_VISION_RADIUS = 70;
        const STAR_COUNT = 100;
        const WORM_WIGGLE_SPEED = 0.1;
        const MAX_RATS = 5; // Reduced from 6
        const RAT_KING_FORMATION_CHANCE = 0.10; // Reduced from 0.2
        const MAX_SQUIRRELS = 3; // Reduced from 4
        const TWIG_SPAWN_RATE = 10000; // Every 10 (?) seconds
        const ANT_SPEED = 0.6;
        const FOOD_CARRY_SPEED = 0.4; // Slower when carrying food
        const MAX_ANTS = 20;
        const MAX_ANT_DISTANCE = 200; // Maximum distance ants can travel from hill
        const BIRD_SPAWN_RATE = 300000; // Every 5 minutes, check if we need more birds
        const WILD_BIRD_SPAWN_RATE = 120000; // Wild birds come every 2 minutes
        const WILD_BIRD_SPAWN_CHANCE = 0.2; // Reduced from 0.25
        const TREE_REGROWTH_RATE = 180000; // Every 2 minutes
        const GUARANTEED_TREE_CHECK_RATE = 40000; // Check for minimum tree count every 40 seconds
        const POOP_WASH_RATE = 0.2;
        const RAIN_SLOWDOWN_FACTOR = 0.6;
        const PUDDLE_EVAPORATION_RATE = 0.0003; // Increased from 0.0012 for faster evaporation
        const GRAVITY = 0.015;
        const AIR_RESISTANCE = 0.98;
        const MAX_TREES = 25;
        const MIN_TREES = 3;
        const TREE_LIFESPAN = 1200000; // 20 minutes
        const BRANCH_GROWTH_INTERVAL = 540000; // 9 minutes
        const LIGHTNING_CHANCE = 0.3; // 30% chance of lightning during rain
        const LIGHTNING_TREE_DAMAGE = 70; // Damage to tree from lightning
        const SPECIAL_TWIG_CHANCE = 0.7; // 70% chance of a twig being special after lightning
        const RAIN_PROBABILITY = 0.25; // changed 
        const MAX_BIRDS = 50;
        const MAX_FOOD = 70; // Max food items
        const MAX_SPEED = 5; // Maximum speed for moving entities
        const MIN_STATE_DURATION = 1000; // Minimum time to remain in a state (to prevent rapid toggling)
        const MAX_BIRD_POOPS = 10;
        const MAX_PUDDLES = 13; // Limit puddles for performance
        const MAX_WORMS = 45; // Limit worms for performance
        const MAX_TWIGS = 20; // Limit twigs for performance
        const MAX_NEST_FIND_ATTEMPTS = 20; 
        const NEST_MATERIALS_NEEDED = 4;
        const WORM_SPAWN_RATE = 10000; // Every 10 seconds

        // Flower colors and types
        const FLOWER_COLORS = [
            "#FF5733", // Orange-red
            "#C70039", // Red
            "#900C3F", // Dark red
            "#581845", // Purple
            "#FFC300", // Yellow
            "#DAF7A6", // Light green
            "#FF5733", // Orange
            "#2980B9", // Blue
            "#8E44AD", // Purple
            "#F1C40F", // Yellow
            "#D35400", // Orange
            "#2ECC71", // Green
            "#E74C3C"  // Red
        ];

        const MAX_FLOWERS = 30; // Maximum number of flowers to display
        
        // V26: Adjusted bird behavior preferences for more perching and resting
        const BIRD_STATE_PREFERENCES = {
            PERCHING: 0.65,    // Reduced slightly to make room for more ground activity
    RESTING: 0.20,
    FLYING: 0.05,      // Decreased from 0.10 - even less flying
    FEEDING: 0.25,     // Increased for more ground foraging
    FORAGING: 0.09,
    BUILDING: 0.015,
    HOPPING: 0.70      // Increased even more for much more ground hopping
        };
        
        // V26: Increased state durations for more stable perching behaviors
        const BIRD_STATE_DURATION = {
            IDLE: 50000,        // Increased from 40000
    PERCHED: 240000,    // Reduced to 4 minutes (below baby starvation time)
    FLEEING: 5000,      // Unchanged
    SHELTERING: 25000,  // Unchanged
    RESTING: 75000,     // Increased from 60000
    BATHING: 25000,     // Unchanged
    FLYING: 10000,       // Reduced from 15000
    HOPPING: 90000      // Increased from 60000 - more ground chill time (1.5 minutes)
        };
        
        // Morning food spawn rates
        const MORNING_WORM_SPAWN_COUNT = 20;
        const MORNING_FOOD_SPAWN_COUNT = 10;
        
        // Problem areas for bird movement
        const problemAreas = [
            // Original problematic areas
            {x: 100, radius: 60},
            {x: 928, radius: 60},
            {x: 888, radius: 60},
            {x: 904, radius: 60},
            // New problem areas identified from logs
            {x: 882, radius: 70},
            {x: 877, radius: 70},
            {x: 864, radius: 70},
            {x: 873, radius: 70},
            {x: 900, radius: 70},
            {x: 866, radius: 70},
            {x: 887, radius: 70},
            {x: 859, radius: 70},
            // Screen edges
            {x: 0, radius: 50},
            {x: canvas.width, radius: 50}
        ];
        
        for (const tree of trees) {
    problemAreas.push({
        x: tree.x,
        radius: tree.trunkWidth * tree.scale * 2
    });
}



        // Bird states
        const BIRD_STATES = {
            IDLE: 'idle',
            PERCHED: 'perched',
            HUNTING: 'hunting',
            COLLECTING: 'collecting',
            BUILDING: 'building',
            FEEDING: 'feeding',
            FLEEING: 'fleeing',
            SHELTERING: 'sheltering',
            RESTING: 'resting',
            BATHING: 'bathing',
            FLYING: 'flying',
            BUILDING_BIRDHOUSE: 'building_birdhouse',
            HOPPING: 'hopping',
            SENTINEL: 'sentinel', // Standing guard while others feed
            MOBBING: 'mobbing', // Harassing predators
            PECKING: 'pecking', // Ground pecking for food
            TERRITORIAL_DISPLAY: 'territorial_display', // Showing dominance
            FLEEING_GROUND: 'fleeing_ground' // Escaping from ground (slower)
        };
        
        const BIRDHOUSE_MATERIALS_NEEDED = 5;

        // Bird types for variety
        const BIRD_TYPES = [
            {
                name: "Bluebird",
                color: "blue",
                bodyColor: "#3498db",
                bellyColor: "#a9cce3",
                wingColor: "#2980b9",
                sizeMultiplier: 1.0,
                speedMultiplier: 1.1,
                glideRatio: 0.3,
                wingFlapAmplitude: 1.0
            },
            {
                name: "Cardinal",
                color: "red",
                bodyColor: "#e74c3c",
                bellyColor: "#f5b7b1",
                wingColor: "#c0392b",
                sizeMultiplier: 1.05,
                speedMultiplier: 1.0,
                glideRatio: 0.2,
                wingFlapAmplitude: 1.2
            },
            {
                name: "Canary",
                color: "yellow",
                bodyColor: "#f1c40f",
                bellyColor: "#f9e79f",
                wingColor: "#d4ac0d",
                sizeMultiplier: 0.9,
                speedMultiplier: 1.2,
                glideRatio: 0.25,
                wingFlapAmplitude: 1.3
            },
            {
                name: "Sparrow",
                color: "brown",
                bodyColor: "#9c640c",
                bellyColor: "#d0a76a",
                wingColor: "#7e5109",
                sizeMultiplier: 0.85,
                speedMultiplier: 1.15,
                glideRatio: 0.2,
                wingFlapAmplitude: 1.4
            },
            {
                name: "Finch",
                color: "green",
                bodyColor: "#229954",
                bellyColor: "#a9dfbf",
                wingColor: "#196f3d",
                sizeMultiplier: 0.8,
                speedMultiplier: 1.25,
                glideRatio: 0.15,
                wingFlapAmplitude: 1.5
            }
        ];

        // Helper function to find safe X positions away from problem areas
        function findSafeX(problemAreas) {
            let attempts = 0;
            const maxAttempts = 10;
            let x;
            
            // Try to find a position at least 80px away from any problem area
            do {
                x = 100 + Math.random() * (canvas.width - 200);
                attempts++;
            } while (
                attempts < maxAttempts && 
                problemAreas.some(area => Math.abs(x - area.x) < 80)
            );
            
            return x;
        }

        // Generate stars
        let stars = [];
        function generateStars() {
            stars = [];
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * GROUND_HEIGHT_RATIO,
                    size: Math.random() * 2 + 1
                });
            }
        }
        generateStars();






// Create a new flower at the given position
function createFlower(x, y) {
    // Limit flower count
    if (flowers.length >= MAX_FLOWERS) {
        // Remove oldest flower
        flowers.shift();
    }
    
    // Get ground level
    const groundY = canvas.height * GROUND_HEIGHT_RATIO;
    // Allow flowers to grow anywhere in the grass area (not just at the top)
    // Calculate a position between the top of grass and halfway down the grass area
    const grassHeight = (canvas.height - groundY) * 0.5; // Use half the grass height
    y = groundY + Math.random() * grassHeight;
    
    // Pick a random color
    const color = FLOWER_COLORS[Math.floor(Math.random() * FLOWER_COLORS.length)];
    
    // Create a new flower
    flowers.push({
        x: x,
        y: y,
        color: color,
        petalCount: 5 + Math.floor(Math.random() * 4), // 5-8 petals
        size: 10 + Math.random() * 5,
        swayAngle: 0,
        swaySpeed: 0.01 + Math.random() * 0.01
    });
    
    debugLog(`New flower created at (${x}, ${y})`);
}

       




        // Draw flowers
        function drawFlowers() {
    for (const flower of flowers) {
        // Update swaying animation
        flower.swayAngle += flower.swaySpeed;
        const sway = Math.sin(flower.swayAngle) * 2;
        
        // Draw stem
        ctx.strokeStyle = mushroomMode ? 
            getMushroomColor("#2ECC71", [70, 100], [40, 70]) : 
            "#2ECC71"; // Green stem
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(flower.x, flower.y);
        ctx.lineTo(flower.x + sway, flower.y - flower.size * 2);
        ctx.stroke();
        
        // Draw center of flower
        ctx.fillStyle = mushroomMode ? 
            getMushroomColor("#F1C40F", [80, 100], [50, 70]) : 
            "#F1C40F"; // Yellow center
        ctx.beginPath();
        ctx.arc(flower.x + sway, flower.y - flower.size * 2, flower.size / 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw petals
        ctx.fillStyle = mushroomMode ? 
            getMushroomColor(flower.color, [80, 100], [50, 80]) : 
            flower.color;
        
        // In mushroom mode, add extra petals for more trippy visuals
        const petalCount = mushroomMode ? flower.petalCount * 1.5 : flower.petalCount;
        
        for (let i = 0; i < petalCount; i++) {
            const angle = (i / petalCount) * Math.PI * 2 + (mushroomMode ? colorCycleTimer / 5000 : 0);
            const distance = flower.size * (mushroomMode ? 1 + Math.sin(colorCycleTimer / 1000 + i) * 0.2 : 1);
            
            const petalX = flower.x + sway + Math.cos(angle) * distance;
            const petalY = flower.y - flower.size * 2 + Math.sin(angle) * distance;
            
            ctx.beginPath();
            ctx.ellipse(
                petalX, 
                petalY, 
                flower.size * 0.8, 
                flower.size * 0.4, 
                angle, 
                0, Math.PI * 2
            );
            ctx.fill();
            
            // In mushroom mode, add a highlight to each petal
            if (mushroomMode) {
                ctx.fillStyle = `rgba(255, 255, 255, 0.3)`;
                ctx.beginPath();
                ctx.ellipse(
                    petalX, 
                    petalY, 
                    flower.size * 0.4, 
                    flower.size * 0.2, 
                    angle, 
                    0, Math.PI * 2
                );
                ctx.fill();
            }
        }
        
        // In mushroom mode, add pulsing glow effect
        if (mushroomMode) {
            const glowSize = flower.size * (1.3 + Math.sin(colorCycleTimer / 500) * 0.3);
            const glowOpacity = 0.2 + Math.sin(colorCycleTimer / 700) * 0.1;
            
            ctx.fillStyle = `hsla(${(colorCycleTimer / 50) % 360}, 100%, 70%, ${glowOpacity})`;
            ctx.beginPath();
            ctx.arc(flower.x + sway, flower.y - flower.size * 2, glowSize, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

        function drawMagicMushroom() {
    if (!magicMushroom) return;
    
    // Update animation
    magicMushroom.pulseTimer += 0.05;
    magicMushroom.glowSize = 1 + Math.sin(magicMushroom.pulseTimer) * 0.3;
    magicMushroom.glowOpacity = 0.3 + Math.sin(magicMushroom.pulseTimer * 1.3) * 0.1;
    
    // Pulsing rainbow glow
    const gradient = ctx.createRadialGradient(
        magicMushroom.x, magicMushroom.y - magicMushroom.size * 0.3,
        0,
        magicMushroom.x, magicMushroom.y - magicMushroom.size * 0.3,
        magicMushroom.size * 2 * magicMushroom.glowSize
    );
    
    // Rainbow gradient for the glow
    const hue1 = (Date.now() / 50) % 360;
    const hue2 = (hue1 + 120) % 360;
    const hue3 = (hue1 + 240) % 360;
    
    gradient.addColorStop(0, `hsla(${hue1}, 100%, 50%, ${magicMushroom.glowOpacity})`);
    gradient.addColorStop(0.5, `hsla(${hue2}, 100%, 50%, ${magicMushroom.glowOpacity * 0.7})`);
    gradient.addColorStop(1, `hsla(${hue3}, 100%, 50%, 0)`);
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(
        magicMushroom.x, 
        magicMushroom.y - magicMushroom.size * 0.3,
        magicMushroom.size * 2 * magicMushroom.glowSize,
        0, Math.PI * 2
    );
    ctx.fill();
    
    gradient.addColorStop(0, `rgba(255, 50, 255, ${magicMushroom.glowOpacity})`);
    gradient.addColorStop(1, 'rgba(255, 50, 255, 0)');
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(
        magicMushroom.x, 
        magicMushroom.y - magicMushroom.size * 0.3,
        magicMushroom.size * 2 * magicMushroom.glowSize,
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Draw stem
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath();
    ctx.rect(
        magicMushroom.x - magicMushroom.size * 0.15, 
        magicMushroom.y - magicMushroom.size * 0.5, 
        magicMushroom.size * 0.3, 
        magicMushroom.size * 0.5
    );
    ctx.fill();
    
    // Draw cap
    ctx.fillStyle = '#FF00AA';
    ctx.beginPath();
    ctx.ellipse(
        magicMushroom.x, 
        magicMushroom.y - magicMushroom.size * 0.5, 
        magicMushroom.size * 0.7, 
        magicMushroom.size * 0.4, 
        0, 0, Math.PI * 2
    );
    ctx.fill();
    
    // Draw spots on cap
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    for (let i = 0; i < 5; i++) {
        const spotAngle = i / 5 * Math.PI * 2 + magicMushroom.pulseTimer;
        const spotDistance = magicMushroom.size * 0.3;
        ctx.beginPath();
        ctx.arc(
            magicMushroom.x + Math.cos(spotAngle) * spotDistance * 0.7, 
            magicMushroom.y - magicMushroom.size * 0.5 + Math.sin(spotAngle) * spotDistance * 0.4,
            magicMushroom.size * 0.08,
            0, Math.PI * 2
        );
        ctx.fill();
    }
}


        // Rain system
        let raindrops = [];

        function scheduleRain() {
          // Much less frequent rain
            const nextRainDelay = 480000 + Math.random() * 300000; // 8-13 minutes between rains (doubled from 4-7)

            // Store next rain time for accurate forecast
            window.nextScheduledRainTime = Date.now() + nextRainDelay;
            window.nextRainWillThunder = Math.random() < LIGHTNING_CHANCE;

            const rainTimer = setTimeout(() => {
                if (Math.random() < RAIN_PROBABILITY) {
                    // Add cloud buildup before rain starts
                    cloudCover = 0;
                    const cloudBuildupDuration = 15000; // 15 seconds
                    
                    const buildupInterval = setInterval(() => {
                        cloudCover += 0.1;
                        if (cloudCover >= 1) {
                            clearInterval(buildupInterval);
                            isRaining = true;
                            isThundering = Math.random() < LIGHTNING_CHANCE;
                            wasRaining = false; // Reset this flag
                            debugLog(`${isThundering ? "Thunderstorm" : "Rain"} started`);

                            // Add diary entry for weather
                            if (isThundering) {
                                addDiaryEntry("A thunderstorm rolls in! Lightning crackles across the sky.", 'weather');
                            }
                            
                            const rainDuration = 45000 + Math.random() * 30000; // 45-75 seconds
                            const rainStopTimer = setTimeout(() => {
                                isRaining = false;
isThundering = false;
wasRaining = true; // Set flag when rain just stopped

// Increment rain counter
rainsCompleted++;
debugLog(`Rain event completed. Total rains: ${rainsCompleted}`);

// After 5 rains, spawn a permanent pond
if (rainsCompleted >= 5 && ponds.length === 0) {
    const pondX = 100 + Math.random() * (canvas.width - 200);
    const pondWidth = 100 + Math.random() * 60;
    const pondHeight = 50 + Math.random() * 30;
    const pondY = canvas.height * GROUND_HEIGHT_RATIO;

    ponds.push({
        x: pondX,
        y: pondY,
        width: pondWidth,
        height: pondHeight,
        rippleTimer: 0,
        ripples: []
    });

    debugLog(`Natural pond formed after ${rainsCompleted} rains at (${pondX}, ${pondY})`);

    // Add diary entry for pond milestone
    addDiaryEntry("A pond has formed in the garden! Koi and frogs move in.", 'milestone');

    // Spawn a couple of koi in the pond
    koi.push({
        x: pondX,
        y: pondY,
        pondIndex: 0,
        swimAngle: Math.random() * Math.PI * 2,
        color: '#FF6B00'
    });
    koi.push({
        x: pondX,
        y: pondY,
        pondIndex: 0,
        swimAngle: Math.random() * Math.PI * 2,
        color: '#FFD700'
    });

    // Spawn a frog near the pond
    frogs.push({
        x: pondX + (Math.random() - 0.5) * 60,
        y: canvas.height * GROUND_HEIGHT_RATIO,
        jumpTimer: 0,
        tongueOut: false
    });

    debugLog(`Pond ecosystem spawned: 2 koi and 1 frog`);
}

// Only create puddles if tab is visible
if (isTabVisible) {
    createPuddles(); // Create puddles when rain stops
} else {
    debugLog("Tab not visible, skipping puddle creation");
}

                                
                                
                                // Keep wasRaining true for longer (1 minute)
                                const rainMemoryTimer = setTimeout(() => {
                                    wasRaining = false;
                                    debugLog("Birds no longer remember it rained recently");
                                }, 60000);
                                addTimer(rainMemoryTimer);
                                
                                // Store interval ID in a variable first, then pass to clearInterval
                                const clearIntervalId = setInterval(() => {
                                    cloudCover -= 0.1;
                                    if (cloudCover <= 0) {
                                        cloudCover = 0;
                                        clearInterval(clearIntervalId); // Use the local reference
                                        scheduleRain();
                                    }
                                }, 5000);
                                addTimer(clearIntervalId, true); // Mark as interval
                            }, rainDuration);
                            addTimer(rainStopTimer);
                            
                            // If thundering, schedule lightning strikes
                            if (isThundering) {
                                scheduleLightning(rainDuration);
                            }
                        }
                    }, cloudBuildupDuration / 10);
                    addTimer(buildupInterval, true); // Mark as interval
                } else {
                    // Skip this rain event
                    scheduleRain();
                }
            }, nextRainDelay);
            addTimer(rainTimer);
        }
        
        // Lightning system
        function scheduleLightning(duration) {
            // Schedule 1-3 lightning strikes during thunderstorm
            const strikeCount = Math.floor(1 + Math.random() * 2);
            
            for (let i = 0; i < strikeCount; i++) {
                const strikeDelay = Math.random() * duration;
                const lightningTimer = setTimeout(() => {
                    createLightningStrike();
                }, strikeDelay);
                addTimer(lightningTimer);
            }
        }
        
        function createLightningStrike() {
            // Choose a random position for lightning
            const strikeX = Math.random() * canvas.width;
            const groundY = canvas.height * GROUND_HEIGHT_RATIO;
            
            // Create lightning visual effect
            const newLightning = {
                x: strikeX,
                y: 0,  // Start from top of screen
                groundY: groundY,
                width: 2 + Math.random() * 2,
                segments: [],
                opacity: 1.0,
                timer: 0
            };
            
            // Generate lightning path segments
            let currentY = 0;
            const segmentCount = Math.floor(10 + Math.random() * 5);
            
            for (let i = 0; i < segmentCount; i++) {
                const segmentLength = groundY / segmentCount;
                const xOffset = (Math.random() - 0.5) * 30;
                
                newLightning.segments.push({
                    x1: strikeX + (i > 0 ? newLightning.segments[i-1].xOffset : 0),
                    y1: currentY,
                    x2: strikeX + (i > 0 ? newLightning.segments[i-1].xOffset : 0) + xOffset,
                    y2: currentY + segmentLength,
                    xOffset: xOffset
                });
                
                currentY += segmentLength;
            }
            
            lightningStrikes.push(newLightning);
            
            // Check if lightning hit a tree
            const hitTree = trees.find(tree => 
                Math.abs(tree.x - strikeX) < tree.trunkWidth * 2
            );
            
            if (hitTree) {
                // Damage tree
                hitTree.health -= LIGHTNING_TREE_DAMAGE;
                debugLog(`Lightning struck tree at ${hitTree.x}`);
                
                // Generate special twigs
                if (hitTree.health <= 0) {
                    createSpecialTwigsFromTree(hitTree);
                }
            }
            
            // Sound and screen flash effect
            const thunderSound = Math.random() < 0.5 ? '💥' : '⚡';
            debugLog(`${thunderSound} Lightning strike at ${strikeX}`);
        }
        
        function updateLightningStrikes(deltaTime) {
            for (let i = lightningStrikes.length - 1; i >= 0; i--) {
                const strike = lightningStrikes[i];
                strike.timer += deltaTime;
                
                // Fade out lightning
                strike.opacity = 1.0 - (strike.timer / 500);
                
                // Remove after it fades
                if (strike.opacity <= 0) {
                    lightningStrikes.splice(i, 1);
                }
            }
        }
        
        function drawLightningStrikes() {
            lightningStrikes.forEach(strike => {
                // Flash the screen with a subtle glow
                ctx.fillStyle = `rgba(200, 220, 255, ${strike.opacity * 0.15})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw the lightning bolt
                ctx.strokeStyle = `rgba(220, 240, 255, ${strike.opacity})`;
                ctx.lineWidth = strike.width;
                
                strike.segments.forEach(segment => {
                    ctx.beginPath();
                    ctx.moveTo(segment.x1, segment.y1);
                    ctx.lineTo(segment.x2, segment.y2);
                    ctx.stroke();
                    
                    // Add some glow to the lightning
                    ctx.shadowColor = 'rgba(200, 220, 255, 0.8)';
                    ctx.shadowBlur = 10;
                });
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            });
        }
        
        function createSpecialTwigsFromTree(tree) {
            // Create 4-8 special twigs from a lightning-struck tree
            const twigCount = 4 + Math.floor(Math.random() * 5);
            
            for (let i = 0; i < twigCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 10 + Math.random() * 60;
                
                const newTwig = {
                    x: tree.x + Math.cos(angle) * distance,
                    y: canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 10,
                    size: 15 + Math.random() * 10, // Larger special twigs
                    angle: Math.random() * Math.PI,
                    isSpecial: Math.random() < SPECIAL_TWIG_CHANCE,
                    offshoots: []
                };
                
                // Generate random offshoots
                for (let j = 0; j < 3; j++) {
                    newTwig.offshoots.push({
                        position: Math.random() * newTwig.size,
                        length: 2 + Math.random() * 5,
                        angle: (Math.random() - 0.5) * Math.PI
                    });
                }
                
                twigs.push(newTwig);
            }
            debugLog(`Created ${twigCount} twigs from lightning-struck tree`);
        }

        // Puddle system
        function createPuddles() {
            // Limit number of puddles for performance
            if (puddles.length >= MAX_PUDDLES) {
                // Sort puddles by size and remove the smallest ones
                puddles.sort((a, b) => a.size - b.size);
                puddles.splice(0, puddles.length - MAX_PUDDLES + 3); // Keep some room for new ones
            }
            
            // Create 3-7 puddles after rain
            const puddleCount = Math.floor(3 + Math.random() * 5);
            for (let i = 0; i < puddleCount; i++) {
                // Distribute across ground (positioned below ground line)
                const puddleX = Math.random() * canvas.width;
                const puddleY = canvas.height * GROUND_HEIGHT_RATIO + 15;
                
                puddles.push({
                    x: puddleX,
                    y: puddleY,
                    size: 20 + Math.random() * 40,
                    depth: 0.7 + Math.random() * 0.3, // Depth for reflection/color
                    evaporationRate: PUDDLE_EVAPORATION_RATE * (0.8 + Math.random() * 0.4), // Some variation
                    ripples: []
                });
            }
            debugLog(`Created ${puddleCount} puddles after rain`);
        }

        function updatePuddles(deltaTime) {
            // Skip if not visible
            if (puddles.length === 0) return;
            
            for (let i = puddles.length - 1; i >= 0; i--) {
                const puddle = puddles[i];
                
                // Add random ripples occasionally
                if (Math.random() < 0.02) {
                    puddle.ripples.push({
                        size: 5,
                        maxSize: 10 + Math.random() * 20,
                        speed: 0.05 + Math.random() * 0.1
                    });
                }
                
                // Update ripples
                for (let j = puddle.ripples.length - 1; j >= 0; j--) {
                    const ripple = puddle.ripples[j];
                    ripple.size += ripple.speed * deltaTime;
                    
                    if (ripple.size >= ripple.maxSize) {
                        puddle.ripples.splice(j, 1);
                    }
                }
                
                // Evaporate puddles very gradually
                puddle.size -= puddle.evaporationRate * deltaTime;
                
                // Remove puddle if too small
                if (puddle.size <= 5) {
                    puddles.splice(i, 1);
                    debugLog(`Puddle evaporated at (${puddle.x}, ${puddle.y})`);
                }
            }
        }

        function drawPuddles() {
            puddles.forEach(puddle => {
                // Main puddle shape - simplified for performance
                ctx.fillStyle = `rgba(110, 150, 230, ${puddle.depth * 0.7})`;
                ctx.beginPath();
                ctx.ellipse(
                    puddle.x, puddle.y,
                    puddle.size, puddle.size * 0.3,
                    0, 0, Math.PI * 2
                );
                ctx.fill();

                // Add center highlight for depth
                ctx.fillStyle = `rgba(150, 180, 255, ${puddle.depth * 0.4})`;
                ctx.beginPath();
                ctx.ellipse(
                    puddle.x, puddle.y,
                    puddle.size * 0.5, puddle.size * 0.15,
                    0, 0, Math.PI * 2
                );
                ctx.fill();

                // Draw ripples
                puddle.ripples.forEach(ripple => {
                    const opacity = 1 - ripple.size / ripple.maxSize;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.5})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.ellipse(
                        puddle.x, puddle.y,
                        ripple.size, ripple.size * 0.3,
                        0, 0, Math.PI * 2
                    );
                    ctx.stroke();
                });
            });
        }

        // Draw ponds (permanent water features)
        function drawPonds() {
            ponds.forEach(pond => {
                // Draw pond with top edge at ground level (center below ground)
                const drawY = pond.y + pond.height;

                // Pond base - simplified solid colors for better performance
                ctx.fillStyle = mushroomMode ? getMushroomColor('rgba(50, 110, 190, 0.85)') : 'rgba(50, 110, 190, 0.85)';
                ctx.beginPath();
                ctx.ellipse(pond.x, drawY, pond.width, pond.height, 0, 0, Math.PI * 2);
                ctx.fill();

                // Reflections/highlights
                ctx.fillStyle = mushroomMode ? getMushroomColor('rgba(200, 220, 255, 0.3)') : 'rgba(200, 220, 255, 0.3)';
                ctx.beginPath();
                ctx.ellipse(pond.x - pond.width * 0.2, drawY - pond.height * 0.3, pond.width * 0.3, pond.height * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Draw ripples - limit to visible ripples for performance
                // Apply clipping to keep ripples within pond boundaries
                ctx.save();
                ctx.beginPath();
                ctx.ellipse(pond.x, drawY, pond.width, pond.height, 0, 0, Math.PI * 2);
                ctx.clip();

                const visibleRipples = pond.ripples.slice(0, 5);
                visibleRipples.forEach(ripple => {
                    const opacity = 1 - ripple.age / ripple.maxAge;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.3})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(ripple.x, ripple.y, ripple.size, ripple.size * 0.5, 0, 0, Math.PI * 2);
                    ctx.stroke();
                });

                ctx.restore();
            });
        }

        // Update ponds
        function updatePonds(deltaTime) {
            ponds.forEach(pond => {
                // Update ripples
                pond.ripples = pond.ripples.filter(ripple => {
                    ripple.age += deltaTime;
                    ripple.size += deltaTime * 0.05;
                    return ripple.age < ripple.maxAge;
                });

                // Occasionally add ripples - reduced frequency and limit count for performance
                if (Math.random() < 0.005 && pond.ripples.length < 8) {
                    pond.ripples.push({
                        x: pond.x + (Math.random() - 0.5) * pond.width,
                        y: pond.y + (Math.random() - 0.5) * pond.height,
                        size: 5,
                        age: 0,
                        maxAge: 2000
                    });
                }
            });
        }

        // Draw koi fish
        function drawKoi() {
            koi.forEach(fish => {
                const pond = ponds[fish.pondIndex];
                if (!pond) return;

                // Use displayY if available (for jumping), otherwise use y
                const drawY = fish.displayY !== undefined ? fish.displayY : fish.y;

                // Koi body - simplified for performance
                ctx.save();
                ctx.translate(fish.x, drawY);
                ctx.rotate(fish.swimAngle);

                // Body - solid color with white belly highlight
                ctx.fillStyle = mushroomMode ? getMushroomColor(fish.color) : fish.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, 12, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // White belly highlight (simple oval)
                ctx.fillStyle = mushroomMode ? getMushroomColor('rgba(255, 255, 255, 0.6)') : 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.ellipse(0, 2, 8, 3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Tail
                ctx.fillStyle = mushroomMode ? getMushroomColor(fish.color) : fish.color;
                ctx.beginPath();
                ctx.moveTo(-12, 0);
                ctx.lineTo(-18, -6);
                ctx.lineTo(-18, 6);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            });
        }

        // Update koi
        function updateKoi(deltaTime) {
            koi.forEach(fish => {
                const pond = ponds[fish.pondIndex];
                if (!pond) return;

                // Check for nearby birds - koi get excited and swim faster
                const pondCenterY = pond.y + pond.height; // Pond center is below ground level
                const nearbyBird = birds.find(bird =>
                    distance(bird.x, bird.y, pond.x, pondCenterY) < 100 &&
                    bird.y > pond.y - 50 // Bird is close to pond level
                );

                let speedMultiplier = 1;
                if (nearbyBird) {
                    speedMultiplier = 2; // Swim faster when birds are near
                    // Occasionally jump out of water
                    if (Math.random() < 0.005) {
                        fish.jumping = true;
                        fish.jumpTimer = 0;
                        fish.jumpHeight = 0;
                        debugLog(`Koi jumped out of water near bird!`);
                    }
                }

                // Handle jumping animation
                if (fish.jumping) {
                    fish.jumpTimer += deltaTime;
                    if (fish.jumpTimer < 400) {
                        // Arc up and down
                        const progress = fish.jumpTimer / 400;
                        fish.jumpHeight = Math.sin(progress * Math.PI) * 15;
                    } else {
                        fish.jumping = false;
                        fish.jumpHeight = 0;
                        // Create splash ripple
                        pond.ripples.push({
                            x: fish.x,
                            y: fish.y,
                            size: 5,
                            age: 0,
                            maxAge: 1500
                        });
                    }
                }

              // Swim in circular pattern within pond (slowed down from 0.001 to 0.0003)
fish.swimAngle += deltaTime * 0.0003 * speedMultiplier;
const radius = Math.min(pond.width, pond.height) * 0.6;
fish.x = pond.x + Math.cos(fish.swimAngle * 2) * radius * 0.7;
fish.y = pondCenterY + Math.sin(fish.swimAngle * 2) * radius * 0.4;

                // Adjust y for jump height
                if (fish.jumping) {
                    fish.displayY = fish.y - fish.jumpHeight;
                } else {
                    fish.displayY = fish.y;
                }

                // Occasionally create ripple
                if (Math.random() < 0.02 && !fish.jumping) {
                    pond.ripples.push({
                        x: fish.x,
                        y: fish.y,
                        size: 3,
                        age: 0,
                        maxAge: 1500
                    });
                }
            });
        }

        // Draw frogs
        function drawFrogs() {
            frogs.forEach(frog => {
                // Frog body (expand slightly when croaking)
                const bodySize = frog.croaking ? 1.2 : 1;
                ctx.fillStyle = mushroomMode ? getMushroomColor('#4CAF50') : '#4CAF50';
                ctx.beginPath();
                ctx.ellipse(frog.x, frog.y, 8 * bodySize, 6 * bodySize, 0, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = mushroomMode ? getMushroomColor('#FFD700') : '#FFD700';
                ctx.beginPath();
                ctx.arc(frog.x - 3, frog.y - 4, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(frog.x + 3, frog.y - 4, 3, 0, Math.PI * 2);
                ctx.fill();

                // Pupils
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(frog.x - 3, frog.y - 4, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(frog.x + 3, frog.y - 4, 1.5, 0, Math.PI * 2);
                ctx.fill();

                // Croaking indicator (sound waves)
                if (frog.croaking) {
                    const opacity = 1 - (frog.croakTimer / 500);
                    ctx.strokeStyle = `rgba(100, 200, 100, ${opacity})`;
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 2; i++) {
                        ctx.beginPath();
                        ctx.arc(frog.x, frog.y, 15 + i * 8 + (frog.croakTimer / 20), 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                // Tongue if out
                if (frog.tongueOut && frog.tongueTarget) {
                    ctx.strokeStyle = mushroomMode ? getMushroomColor('#FF6B9D') : '#FF6B9D';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(frog.x, frog.y);
                    ctx.lineTo(frog.tongueTarget.x, frog.tongueTarget.y);
                    ctx.stroke();
                }
            });
        }

        // Update frogs
        function updateFrogs(deltaTime) {
            frogs.forEach(frog => {
                // Check for nearby birds - frogs get nervous
                const nearbyBird = birds.find(bird =>
                    distance(bird.x, bird.y, frog.x, frog.y) < 80 &&
                    bird.y > frog.y - 50
                );

                if (nearbyBird && !frog.jumping) {
                    // Jump away from bird
                    if (Math.random() < 0.05) {
                        const jumpAwayX = frog.x + (frog.x - nearbyBird.x > 0 ? 1 : -1) * (40 + Math.random() * 40);
                        frog.jumping = true;
                        frog.jumpTimer = 0;
                        frog.jumpStartX = frog.x;
                        frog.jumpStartY = frog.y;
                        frog.jumpTargetX = jumpAwayX;
                        frog.jumpTargetY = canvas.height * GROUND_HEIGHT_RATIO;
                        debugLog(`Frog jumping away from bird!`);
                    }

                    // Croak at bird (visual indicator)
                    if (Math.random() < 0.02) {
                        frog.croaking = true;
                        frog.croakTimer = 0;
                    }
                }

                // Update croaking animation
                if (frog.croaking) {
                    frog.croakTimer += deltaTime;
                    if (frog.croakTimer > 500) {
                        frog.croaking = false;
                    }
                }

                // Check for nearby ponds and jump toward them
                if (!frog.jumping && Math.random() < 0.003) {
                    let nearestPond = null;
                    let nearestDist = Infinity;

                    for (const pond of ponds) {
                        const dist = distance(frog.x, frog.y, pond.x, pond.y + pond.height);
                        if (dist < nearestDist && dist < 200) {
                            nearestDist = dist;
                            nearestPond = pond;
                        }
                    }

                    if (nearestPond && Math.random() < 0.4) {
                        // Jump toward pond
                        frog.jumping = true;
                        frog.jumpTimer = 0;
                        frog.jumpStartX = frog.x;
                        frog.jumpStartY = frog.y;
                        frog.jumpTargetX = nearestPond.x + (Math.random() - 0.5) * nearestPond.width * 0.5;
                        frog.jumpTargetY = nearestPond.y + nearestPond.height; // Jump into pond
                        debugLog(`Frog jumping into pond at (${frog.jumpTargetX.toFixed(0)}, ${frog.jumpTargetY.toFixed(0)})`);
                    } else {
                        // Jump randomly
                        frog.jumping = true;
                        frog.jumpTimer = 0;
                        frog.jumpStartX = frog.x;
                        frog.jumpStartY = frog.y;
                        frog.jumpTargetX = frog.x + (Math.random() - 0.5) * 100;
                        frog.jumpTargetY = canvas.height * GROUND_HEIGHT_RATIO;
                        debugLog(`Frog jumping from (${frog.x.toFixed(0)}, ${frog.y.toFixed(0)})`);
                    }
                }

                if (frog.jumping) {
                    frog.jumpTimer += deltaTime;
                    const progress = Math.min(1, frog.jumpTimer / 500);
                    frog.x = frog.jumpStartX + (frog.jumpTargetX - frog.jumpStartX) * progress;
                    frog.y = frog.jumpStartY + (frog.jumpTargetY - frog.jumpStartY) * progress - Math.sin(progress * Math.PI) * 20;

                    if (progress >= 1) {
                        frog.jumping = false;
                    }
                }

                // Try to catch nearby insects
                if (!frog.tongueOut && Math.random() < 0.005) {
                    const nearbyAnts = ants.filter(ant => distance(frog.x, frog.y, ant.x, ant.y) < 50);
                    if (nearbyAnts.length > 0) {
                        frog.tongueOut = true;
                        frog.tongueTarget = nearbyAnts[0];
                        frog.tongueTimer = 0;
                        frog.tongueTargetIndex = ants.indexOf(nearbyAnts[0]);
                    }
                }

                // Update tongue animation
                if (frog.tongueOut) {
                    frog.tongueTimer += deltaTime;
                    if (frog.tongueTimer >= 200) {
                        // Try to catch the ant
                        if (Math.random() < 0.3 && frog.tongueTargetIndex !== -1) {
                            if (ants[frog.tongueTargetIndex] === frog.tongueTarget) {
                                ants.splice(frog.tongueTargetIndex, 1);
                                debugLog(`Frog caught an ant!`);
                            }
                        }
                        frog.tongueOut = false;
                        frog.tongueTarget = null;
                        frog.tongueTargetIndex = -1;
                    }
                }
            });
        }

        // Canvas resize handler that preserves entities and their positions
        let resizeController = null;
        window.addEventListener('resize', () => {
            if (resizeController) clearTimeout(resizeController);
            resizeController = setTimeout(() => {
                // Just pause animation temporarily instead of stopping it
                const wasRunning = animationRunning;
                animationRunning = false;
                
                try {
                    debugLog("Adjusting canvas size");
                    resizeCanvas();
                } catch (e) {
                    console.error("Resize error:", e);
                } finally {
                    // Resume animation without recreating entities
                    animationRunning = wasRunning;
                }
                resizeController = null;
            }, 200);
        });

        // Add this visibility change event listener here
document.addEventListener('visibilitychange', function() {
    isTabVisible = !document.hidden;
    // Optional: pause rain if tab becomes hidden
    if (document.hidden && isRaining) {
        isRaining = false;
    }
});

        function resizeCanvas() {
            const prevWidth = canvas.width;
            const prevHeight = canvas.height;
            const prevGroundLevel = prevHeight * GROUND_HEIGHT_RATIO;
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const newGroundLevel = canvas.height * GROUND_HEIGHT_RATIO;
            
            // Only regenerate stars, not other entities
            generateStars();
            
            // Only apply ground-based entity adjustments if this is not the first resize
            if (prevWidth > 0 && prevHeight > 0) {
                const scaleX = canvas.width / prevWidth;
                const scaleY = canvas.height / prevHeight;
                const groundDelta = newGroundLevel - prevGroundLevel;

                // ADD THE SCARECROW POSITIONING CODE RIGHT AFTER THIS COMMENT
        if (scarecrow) {
            // Preserve x-position relative to screen width
            const xRatio = scarecrow.x / prevWidth;
            scarecrow.x = canvas.width * xRatio;
            
            // Always place on new ground level
            scarecrow.y = canvas.height * GROUND_HEIGHT_RATIO;
        }
                
                // Update all ground-based entities
                trees.forEach(tree => {
                    tree.x *= scaleX;
                    // Keep trees properly grounded at the new ground level
                    tree.y = newGroundLevel;
                });
                
                // Update other ground-based entities
                worms.forEach(worm => {
                    worm.x *= scaleX;
                    // If worm was on ground, keep it on ground
                    if (Math.abs(worm.y - prevGroundLevel) < 50) {
                        worm.y = newGroundLevel + (worm.y - prevGroundLevel);
                    } else {
                        worm.y *= scaleY;
                    }
                });
                
                twigs.forEach(twig => {
    twig.x *= scaleX;
    // If twig was on ground, keep it on ground
    if (Math.abs(twig.y - prevGroundLevel) < 50) {
        twig.y = newGroundLevel + (twig.y - prevGroundLevel);  // FIXED: twig.y instead of worm.y
    } else {
        twig.y *= scaleY;
    }
});
                
                // Update birds to maintain their height above ground if they were near it
                birds.forEach(bird => {
                    bird.x *= scaleX;
                    if (Math.abs(bird.y - prevGroundLevel) < 30) {
                        // Bird was near ground, keep it same distance from ground
                        bird.y = newGroundLevel - (prevGroundLevel - bird.y);
                    } else {
                        bird.y *= scaleY;
                    }
                });
                
                // Do the same for other entities
                birdPoops.forEach(poop => {
                    poop.x *= scaleX;
                    if (poop.grounded) {
                        poop.y = newGroundLevel;
                    } else {
                        poop.y *= scaleY;
                    }
                });
                
                foodItems.forEach(food => {
                    food.x *= scaleX;
                    if (Math.abs(food.y - prevGroundLevel) < 50) {
                        food.y = newGroundLevel + (food.y - prevGroundLevel);
                    } else {
                        food.y *= scaleY;
                    }
                });
                
                puddles.forEach(puddle => {
                    puddle.x *= scaleX;
                    puddle.y = newGroundLevel + 3; // Puddles always on ground
                });

                // Update ponds - keep them at ground level
                ponds.forEach(pond => {
                    pond.x *= scaleX;
                    pond.y = newGroundLevel; // Ponds stay at ground level
                });

                // Update frogs - keep them at ground level
                frogs.forEach(frog => {
                    frog.x *= scaleX;
                    frog.y = newGroundLevel; // Frogs stay at ground level
                    // Update jump targets if currently jumping
                    if (frog.jumping) {
                        frog.jumpTargetX *= scaleX;
                        frog.jumpTargetY = newGroundLevel;
                        frog.jumpStartX *= scaleX;
                        frog.jumpStartY = newGroundLevel;
                    }
                });

                // Koi positions are relative to pond center, will auto-update based on pond position

                nests.forEach(nest => {
            // If nest has an associated tree, adjust position relative to tree
            if (nest.tree && trees.includes(nest.tree)) {
                // Use the direct tree reference instead of searching
                const tree = nest.tree;
                
                // Scale x-position relative to tree's x-scale
                nest.x = tree.x + (nest.x - (tree.x / scaleX)) * scaleX;
                
                // Maintain fixed position at 80% up the tree trunk
                nest.y = tree.y - tree.trunkHeight * 0.8 * tree.scale;
            } else {
                // No valid tree association, scale normally
                nest.x *= scaleX;
                nest.y *= scaleY;
                
                // Clear invalid tree reference
                if (nest.tree && !trees.includes(nest.tree)) {
                    nest.tree = null;
                }
            }
        });
                
                birdhouses.forEach(birdhouse => {
                    birdhouse.x *= scaleX;
                    birdhouse.y = newGroundLevel; // Birdhouses are on ground
                });
                
                rats.forEach(rat => {
                    rat.x *= scaleX;
                    rat.y = newGroundLevel - 5 + (Math.random() * 10); // Keep rats on ground with some variation
                });
                
                squirrels.forEach(squirrel => {
                    squirrel.x *= scaleX;
                    if (Math.abs(squirrel.y - prevGroundLevel) < 30) {
                        squirrel.y = newGroundLevel - (prevGroundLevel - squirrel.y);
                    } else {
                        squirrel.y *= scaleY;
                    }
                });
                
                babyBirds.forEach(baby => {
    baby.x *= scaleX;
    
    // If baby has an associated nest, keep it with the nest
    if (baby.associatedNest && nests.includes(baby.associatedNest)) {
        baby.x = baby.associatedNest.x;
        baby.y = baby.associatedNest.y;
    } else if (Math.abs(baby.y - prevGroundLevel) < 30) {
        // If baby is near ground, keep it at same distance from ground
        baby.y = newGroundLevel - (prevGroundLevel - baby.y);
    } else {
        // Otherwise scale proportionally
        baby.y *= scaleY;
    }
});

                // Also update flowers
                flowers.forEach(flower => {
                    flower.x *= scaleX;
                    if (Math.abs(flower.y - prevGroundLevel) < 50) {
                        flower.y = newGroundLevel + (flower.y - prevGroundLevel);
                    } else {
                        flower.y *= scaleY;
                    }
                });
// Update ant hill if it exists
if (antHill) {
    antHill.x *= scaleX; // Scale X position based on canvas width change
    antHill.y = newGroundLevel + 5; // Position it at ground level with small offset
    antHill.entranceY = newGroundLevel + 2; // Update entrance position too
}
// Update ant hill position
if (antHill) {
    // Scale horizontally proportionally
    antHill.x = (antHill.x / prevWidth) * canvas.width;
    
    // Fix vertical position directly to ground level + small offset
    antHill.y = canvas.height * GROUND_HEIGHT_RATIO + 5;
    
    // Also update the entrance position
    antHill.entranceY = canvas.height * GROUND_HEIGHT_RATIO - 3;
    
    debugLog("Ant hill position fixed after resize");
}

            }
        }

   // Day/Night cycle
function updateDayNightCycle(deltaTime) {
    previousTimeOfDay = timeOfDay;
    timeOfDay = (timeOfDay + deltaTime / dayNightDuration) % 2;
    
   // Track hour of day (0-23) for morning food spawn
const oldHour = currentHour;
// Adjusted formula: Add 6 hours so noon is at timeOfDay 0.5, midnight at timeOfDay 1.5
currentHour = Math.floor(((timeOfDay < 1 ? timeOfDay * 12 : 12 + (timeOfDay - 1) * 12) + 6) % 24);
    
    // Start of new day
    if (timeOfDay < previousTimeOfDay) {
        dayNightCycleCount++;
        // No modulo operation here to ensure days keep counting past 99
        debugLog(`Day/night cycle count: ${dayNightCycleCount}`);

        // Add daily summary entry to diary
        const birdCount = birds.length;
        const nestCount = nests.filter(n => n.isComplete).length;
        const babyCount = babyBirds.length;
        let summaryText = `Day ${dayNightCycleCount} complete. `;

        if (birdCount > 0) {
            summaryText += `${birdCount} bird${birdCount !== 1 ? 's' : ''} in the garden. `;
        }
        if (nestCount > 0) {
            summaryText += `${nestCount} active nest${nestCount !== 1 ? 's' : ''}. `;
        }
        if (babyCount > 0) {
            summaryText += `${babyCount} baby bird${babyCount !== 1 ? 's' : ''} growing. `;
        }
        if (birdCount === 0 && nestCount === 0) {
            summaryText += `The garden awaits its first visitors.`;
        }

        addDiaryEntry(summaryText, 'normal');
    }
    
    // Morning food and worm spawn (around 6-7 AM)
    if ((oldHour !== currentHour) && (currentHour === 6 || currentHour === 7)) {
        if (Date.now() - lastHourlyUpdate > 30000) { // Prevent multiple updates in same hour
            spawnMorningFood();
            lastHourlyUpdate = Date.now();
        }
    }
}
        
        // Morning food and worm spawn
        function spawnMorningFood() {
            debugLog(`Morning food and worms spawning at hour ${currentHour}`);
            
            // Spawn extra worms in the morning
            for (let i = 0; i < MORNING_WORM_SPAWN_COUNT; i++) {
                if (worms.length < MAX_WORMS) {
                    const x = Math.random() * (canvas.width - 100) + 50;
                    const y = canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 20;
                    
                    worms.push({
                        x: x,
                        y: y,
                        wiggle: Math.random() * Math.PI * 2,
                        size: 5 + Math.random() * 5
                    });
                }
            }
            
            // Spawn extra food in the morning
            for (let i = 0; i < MORNING_FOOD_SPAWN_COUNT; i++) {
                const x = Math.random() * canvas.width;
                const y = canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 5;
                scatterFood(x, y, 1); // Scatter individual food items across the ground
            }
            
            debugLog(`Added ${MORNING_WORM_SPAWN_COUNT} worms and ${MORNING_FOOD_SPAWN_COUNT} food items`);
        }

        // Vector helper functions
        function distance(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function normalize(x, y) {
            const len = Math.sqrt(x * x + y * y);
            if (len === 0) return { x: 0, y: 0 };
            return { x: x / len, y: y / len };
        }

        function getMushroomColor(baseColor, saturationRange = [70, 100], lightnessRange = [50, 70]) {
    if (!mushroomMode) return baseColor;
    
    // For hex colors, convert to HSL
    let h, s, l;
    
    if (typeof baseColor === 'string' && baseColor.startsWith('#')) {
        // Convert hex to RGB
        const r = parseInt(baseColor.slice(1, 3), 16) / 255;
        const g = parseInt(baseColor.slice(3, 5), 16) / 255;
        const b = parseInt(baseColor.slice(5, 7), 16) / 255;
        
        // Convert RGB to HSL
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const d = max - min;
        
        // Calculate hue
        if (d === 0) h = 0;
        else if (max === r) h = ((g - b) / d) % 6;
        else if (max === g) h = (b - r) / d + 2;
        else h = (r - g) / d + 4;
        
        h = Math.round(h * 60);
        if (h < 0) h += 360;
        
        // Calculate lightness and saturation
        l = (max + min) / 2;
        s = d === 0 ? 0 : d / (1 - Math.abs(2 * l - 1));
        
        s = Math.round(s * 100);
        l = Math.round(l * 100);
    } else {
        // For simplicity, use a random hue if not a hex color
        h = Math.random() * 360;
        s = 80;
        l = 60;
    }
    
    // Cycle the hue based on time
    h = (h + colorCycleTimer / 50) % 360;
    
    // Randomize saturation and lightness within ranges
    s = saturationRange[0] + Math.random() * (saturationRange[1] - saturationRange[0]);
    l = lightnessRange[0] + Math.random() * (lightnessRange[1] - lightnessRange[0]);
    
    return `hsl(${h}, ${s}%, ${l}%)`;
}


        // Improved proximity check function
        function isEntityOnScreen(entity, buffer = 100) {
            return entity.x >= -buffer && 
                   entity.x <= canvas.width + buffer && 
                   entity.y >= -buffer && 
                   entity.y <= canvas.height + buffer;
        }

        // V26: Enhanced validatePosition function with even gentler boundary management
        function validatePosition(obj) {
            // Constants for boundary behavior - even gentler push now
            const visibleBuffer = 25;   // Increased from 20
            const hardBuffer = 120;     // Reduced for more aggressive recovery
            const centerPush = 0.08;    // Decreased from 0.1 for even gentler push


            function checkBirdsStuckBetweenTrees() {
    try {
        // Only run every few frames to reduce performance impact
        if (Math.random() > 0.1) return; // Only run 10% of the time
        
        for (const bird of birds) {
            // Skip birds that are intentionally perched or building
            if (bird.state === BIRD_STATES.PERCHED || 
                bird.state === BIRD_STATES.BUILDING ||
                bird.state === BIRD_STATES.RESTING) {
                continue;
            }
            
            // Check if bird is near at least two trees
            const nearbyTrees = [];
            for (const tree of trees) {
                if (tree && typeof tree.x === 'number' && typeof tree.trunkWidth === 'number') {
                    if (Math.abs(bird.x - tree.x) < tree.trunkWidth * 1.5) {
                        nearbyTrees.push(tree);
                    }
                }
            }
            
            if (nearbyTrees.length >= 2) {
                // Bird is potentially trapped between trees
                // Calculate if bird is truly trapped (trees on both sides)
                const leftTrees = [];
                const rightTrees = [];
                
                for (const tree of nearbyTrees) {
                    if (tree.x < bird.x) {
                        leftTrees.push(tree);
                    } else if (tree.x > bird.x) {
                        rightTrees.push(tree);
                    }
                }
                
                if (leftTrees.length > 0 && rightTrees.length > 0) {
                    // Bird is truly stuck between trees on both sides
                    debugLog(`Bird detected stuck between trees at (${bird.x}, ${bird.y})`);
                    
                    // Determine escape direction (simpler approach)
                    const goLeft = Math.random() < 0.5;
                    
                    if (goLeft) {
                        // Escape to the left
                        bird.velocity.x = -1;
                        bird.direction = -1;
                    } else {
                        // Escape to the right
                        bird.velocity.x = 1;
                        bird.direction = 1;
                    }
                    
                    // Also add upward velocity for better escape
                    bird.velocity.y = -1;
                    
                    // Set bird to flying state
                    bird.state = BIRD_STATES.FLYING;
                    bird.stateTimer = 0;
                }
            }
        }
    } catch (error) {
        // If any error occurs, log it but don't break the game
        console.error("Error in checkBirdsStuckBetweenTrees:", error);
    }
}
            
            // For birds specifically, use enhanced logic
            const isBird = obj.hasOwnProperty('state') && Object.values(BIRD_STATES).includes(obj.state);
            const isRat = obj.hasOwnProperty('isRatKing') !== undefined;
            const isSquirrel = obj.hasOwnProperty('tailWobble') !== undefined;
            
            // Check if entity is marked to leave screen
            const isLeavingIntentionally = 
                (isRat && obj.state === 'wandering' && obj.direction * obj.x > 0) ||
                (isSquirrel && obj.state === 'leaving') ||
                (isBird && obj.isWild && obj.stateTimer > 15000);
            
            // If entity is intentionally leaving, allow it to go off-screen
            if (isLeavingIntentionally) {
                return;
            }

            // Hard limits - still keep objects on-screen (+buffer) but with larger buffer
            if (isBird) {
                // Birds shouldn't go far off-screen - gentler limits
                obj.x = Math.max(-hardBuffer/2, Math.min(obj.x, canvas.width + hardBuffer/2));
                obj.y = Math.max(-hardBuffer/2, Math.min(obj.y, canvas.height + hardBuffer/2));
                
                // If bird is off-screen, use gentle recovery
                if (obj.x < 0 || obj.x > canvas.width || 
                    obj.y < 0 || obj.y > canvas.height) {
                    obj.isOffscreen = true;
                    
                    // Only clear path and force return if bird has been off-screen for a while
                    if (!obj.offscreenTime) {
                        obj.offscreenTime = 0;
                    }
                    obj.offscreenTime += 16; // Add time
                    
                    if (obj.offscreenTime > 5000) { // 5 seconds off-screen
                        // Clear any existing path and gently return to screen
                        obj.path = [];
                        obj.pathIndex = 0;
                        
                        // Generate new path to return to visible area
                        if (obj.generatePath) {
                            const targetX = 100 + Math.random() * (canvas.width - 200);
                            const targetY = 100 + Math.random() * (canvas.height * 0.5 - 100);
                            obj.generatePath(targetX, targetY);
                            
                            // Reset velocity gently to break any loops
                            obj.velocity = { 
                                x: obj.velocity.x * 0.5, 
                                y: obj.velocity.y * 0.5 
                            };
                            obj.state = BIRD_STATES.FLYING;
                            obj.stateTimer = 0;
                            debugLog(`Gently guiding off-screen bird back to (${targetX}, ${targetY})`);
                            obj.offscreenTime = 0;
                        }
                    }
                } else {
                    obj.isOffscreen = false;
                    obj.offscreenTime = 0;
                }
            } else {
                // Non-bird entities can have larger buffer
                obj.x = Math.max(-hardBuffer, Math.min(obj.x, canvas.width + hardBuffer));
                obj.y = Math.max(-hardBuffer, Math.min(obj.y, canvas.height + hardBuffer));
            }
        }

        // Background drawing
        function drawBackground() {
            let skyColor;

// // Add sunset variation
const sunsetType = Math.floor(simulationTime / dayNightDuration * 10) % 6; // Changed from 4 to 6 types
    
    if (timeOfDay < 1) {
        // Day colors with sunset variations
        const sunsetTime = timeOfDay > 0.6 && timeOfDay < 0.98; // Extended sunset period
        
        if (sunsetTime) {
            const sunsetIntensity = Math.min(1, (timeOfDay - 0.6) * 3);
            
            switch(sunsetType) {
                case 0:
                    // Golden sunset
                    skyColor = `hsl(${40 + timeOfDay * 5}, ${85 * sunsetIntensity}%, ${75 - timeOfDay * 15}%)`;
                    break;
                case 1:
                    // Mexican-style orange sunset (enhanced)
                    skyColor = `hsl(${25 + timeOfDay * 10}, ${95 * sunsetIntensity}%, ${65 - timeOfDay * 20}%)`;
                    break;
                case 2:
                    // Pink/purple sunset
                    skyColor = `hsl(${320 + timeOfDay * 10}, ${80 * sunsetIntensity}%, ${70 - timeOfDay * 25}%)`;
                    break;
                case 3:
                    // Dramatic red sunset
                    skyColor = `hsl(${5 + timeOfDay * 5}, ${90 * sunsetIntensity}%, ${60 - timeOfDay * 30}%)`;
                    break;
                case 4:
                    // Teal/green sunset
                    skyColor = `hsl(${180 + timeOfDay * 8}, ${70 * sunsetIntensity}%, ${65 - timeOfDay * 20}%)`;
                    break;
                case 5:
                    // Blue/purple gradient sunset
                    skyColor = `hsl(${240 + timeOfDay * 15}, ${80 * sunsetIntensity}%, ${65 - timeOfDay * 25}%)`;
                    break;
            }
        } else {
            // Regular blue day sky
            skyColor = `hsl(${200 + timeOfDay * 60}, 70%, ${70 - timeOfDay * 30}%)`; 
        }
    } else {
        // Night sky (unchanged)
        skyColor = `hsl(${260 - (timeOfDay - 1) * 60}, 70%, ${40 - (timeOfDay - 1) * 20}%)`; 
    
        // Night sky (unchanged)
        skyColor = `hsl(${260 - (timeOfDay - 1) * 60}, 70%, ${40 - (timeOfDay - 1) * 20}%)`; 
    }

    ctx.fillStyle = skyColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height * GROUND_HEIGHT_RATIO);


    

            if (timeOfDay < 1) {
                skyColor = `hsl(${200 + timeOfDay * 60}, 70%, ${70 - timeOfDay * 30}%)`; // Day
            } else {
                skyColor = `hsl(${260 - (timeOfDay - 1) * 60}, 70%, ${40 - (timeOfDay - 1) * 20}%)`; // Night
            }

            ctx.fillStyle = skyColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height * GROUND_HEIGHT_RATIO);


            // ADD THIS CODE RIGHT HERE after the sky is drawn:
    if (mushroomMode) {
        // Draw psychedelic sky patterns
        const currentTime = Date.now();
        if (currentTime - lastColorCycleUpdate > 100) { // Update every 100ms
            lastColorCycleUpdate = currentTime;
            
            // Draw rainbow gradient overlay with transparency
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            
            // Add color stops based on time
            const time = currentTime / 1000;
            for (let i = 0; i < 6; i++) {
                const hue = (time * 20 + i * 60) % 360;
                gradient.addColorStop(i / 5, `hsla(${hue}, 100%, 70%, 0.1)`);
            }
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height * GROUND_HEIGHT_RATIO);
            
            // Add some floating circles
            for (let i = 0; i < 3; i++) {
                const circleX = (canvas.width / 3) * (i + 1) + Math.sin(time + i) * 100;
                const circleY = canvas.height * 0.3 + Math.cos(time * 0.7 + i) * 50;
                const radius = 30 + Math.sin(time * 0.5 + i * 2) * 15;
                
                const circleGradient = ctx.createRadialGradient(
                    circleX, circleY, 0,
                    circleX, circleY, radius
                );
                
                circleGradient.addColorStop(0, `hsla(${(time * 30 + i * 120) % 360}, 100%, 70%, 0.2)`);
                circleGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = circleGradient;
                ctx.beginPath();
                ctx.arc(circleX, circleY, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    // Ground
    const groundColor = isRaining ? '#7AC552' : (puddles.length > 0 ? '#88DD77' : '#90EE90');
    ctx.fillStyle = groundColor;
    ctx.fillRect(0, canvas.height * GROUND_HEIGHT_RATIO, canvas.width, canvas.height * (1 - GROUND_HEIGHT_RATIO));

            
            // Draw stars at night
            if (timeOfDay >= 1 && !isRaining && cloudCover < 0.5) {
                ctx.fillStyle = 'white';
                stars.forEach(star => {
                    // Adjust opacity based on cloud cover
                    const opacity = 1 - (cloudCover * 2);
                    if (opacity > 0) {
                        ctx.globalAlpha = opacity;
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                ctx.globalAlpha = 1;
            }

            // Draw sun or moon
            if (timeOfDay < 1 && cloudCover < 0.7) {
                // Sun
                const sunX = canvas.width * 0.8;
                const sunY = canvas.height * 0.2;
                const sunRadius = 30;
                
                // Adjust sun glow based on cloud cover
                const sunOpacity = 1 - cloudCover;
                
                // Sun glow
                const gradient = ctx.createRadialGradient(
                    sunX, sunY, sunRadius * 0.5,
                    sunX, sunY, sunRadius * 2
                );
                gradient.addColorStop(0, `rgba(255, 255, 0, ${sunOpacity})`);
                gradient.addColorStop(1, `rgba(255, 255, 0, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(sunX, sunY, sunRadius * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Sun core
                ctx.fillStyle = `rgba(255, 255, 0, ${sunOpacity})`;
                ctx.beginPath();
                ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
                ctx.fill();
            } else if (timeOfDay >= 1 && cloudCover < 0.7) {
                // Moon
                ctx.fillStyle = `rgba(220, 220, 220, ${0.8 - cloudCover})`;
                ctx.beginPath();
                ctx.arc(canvas.width * 0.2, canvas.height * 0.2, 25, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw cloud cover if present
            if (cloudCover > 0) {
                // Draw varying cloud layers
                for (let i = 0; i < 3; i++) {
                    const cloudY = canvas.height * GROUND_HEIGHT_RATIO * 0.2 * (i * 0.4 + 0.5);
                    const cloudOpacity = cloudCover * (0.4 - i * 0.1);
                    
                    ctx.fillStyle = isThundering ? 
                        `rgba(60, 60, 80, ${cloudOpacity})` : 
                        `rgba(90, 90, 100, ${cloudOpacity})`;
                    
                    for (let j = 0; j < 4; j++) {
                        const cloudWidth = canvas.width * 0.4;
                        const cloudX = ((j * canvas.width / 3) + i * 50) % canvas.width;
                        
                        ctx.beginPath();
                        ctx.ellipse(
                            cloudX, cloudY, 
                            cloudWidth / 2, 
                            canvas.height * 0.05, 
                            0, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
            }
        }
        

        // Modified drawCurtains to do nothing
        function drawCurtains() {
            return; // Skip drawing curtains
        }

        // Draw debug visuals
        function drawDebugVisuals() {
            if (!debugVisuals) return;
            
            // Draw bird paths
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
            ctx.lineWidth = 1;
            
            birds.forEach(bird => {
                if (bird.path && bird.path.length > 0) {
                    // Draw path from current position to next waypoint
                    if (bird.pathIndex < bird.path.length) {
                        ctx.beginPath();
                        ctx.moveTo(bird.x, bird.y);
                        ctx.lineTo(bird.path[bird.pathIndex].x, bird.path[bird.pathIndex].y);
                        ctx.stroke();
                        
                        // Draw the rest of the path
                        ctx.beginPath();
                        for (let i = bird.pathIndex; i < bird.path.length - 1; i++) {
                            ctx.moveTo(bird.path[i].x, bird.path[i].y);
                            ctx.lineTo(bird.path[i+1].x, bird.path[i+1].y);
                        }
                        ctx.stroke();
                        
                        // Draw waypoints
                        ctx.fillStyle = 'yellow';
                        for (let i = bird.pathIndex; i < bird.path.length; i++) {
                            ctx.beginPath();
                            ctx.arc(bird.path[i].x, bird.path[i].y, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Highlight current waypoint
                        ctx.fillStyle = 'orange';
                        ctx.beginPath();
                        ctx.arc(bird.path[bird.pathIndex].x, bird.path[bird.pathIndex].y, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
            
            

     
     

        }

        // V26: Enhanced Nest class with deterioration system
        class Nest {
            constructor(tree, x, y) {
                this.tree = tree;
                this.x = x;
                this.y = y;
                this.materialsCollected = 0;
                this.isComplete = false;
                this.occupiedBy = null;
                this.health = 100;
                this.condition = 100;  // Tracks physical condition of nest (100 = perfect)
                this.deteriorationRate = 0.005;  // Base rate of deterioration per second
                this.lastMaintenanceTime = Date.now(); // Track last time maintenance was performed
                this.needsMaintenance = false; // Flag for when nest needs attention
                this.maintenanceThreshold = 60; // Below this condition, nest needs repair
                this.failureThreshold = 20; // Below this condition, nest becomes incomplete
                this.ratOccupied = false; // Track if a rat has taken over
                this.readyForBabies = false; // Explicit flag for baby creation
                this.lastBabyTime = 0; // Track when the last baby was born




                // Generate fixed angles for twigs for consistency
                this.twigAngles = [];
                for (let i = 0; i < NEST_MATERIALS_NEEDED; i++) {
                    this.twigAngles.push({
                        angle: (i / NEST_MATERIALS_NEEDED) * Math.PI + Math.PI / 8 * Math.sin(i * 2),
                        length: 5 + Math.random() * 10,
                        offset: Math.random() * 0.2
                    });
                }
            }

            addMaterial() {
                this.materialsCollected++;
                
                if (this.materialsCollected >= NEST_MATERIALS_NEEDED && !this.isComplete) {
                    this.isComplete = true;
                    this.readyForBabies = true;
                    this.condition = 100; // Reset condition when newly completed
                    debugLog(`Nest at (${this.x}, ${this.y}) is complete! Ready for babies!`);

                    // Add diary entry for first few nests
                    if (nests.filter(n => n.isComplete).length <= 3) {
                        if (nests.filter(n => n.isComplete).length === 1) {
                            addDiaryEntry("The first nest is complete! New life awaits.", 'nest');
                        } else {
                            addDiaryEntry("Another nest completed. The garden family grows.", 'nest');
                        }
                    }
                }
                
                // Repair functionality - improve condition when maintained
                if (this.isComplete && this.condition < 100) {
                    this.condition = Math.min(100, this.condition + 25); // Significant repair
                    this.lastMaintenanceTime = Date.now();
                    this.needsMaintenance = false;
                    debugLog(`Nest at (${this.x}, ${this.y}) maintained. New condition: ${this.condition.toFixed(1)}%`);
                }
                
                return this.isComplete;
            }

            damage(amount) {
                // Birds defend their nests
                if (this.occupiedBy && Math.random() < 0.7) {
                    // 70% chance a bird defends its nest
                    amount *= 0.3; // Reduce damage by 70%
                    debugLog("Bird defended nest from attack!");
                }
                
                this.health -= amount;
                
                // Also affect condition
                this.condition = Math.max(0, this.condition - amount);
                this.checkCondition();

                
                
                if (this.health <= 0) {
                    this.isComplete = false;
                    this.materialsCollected = Math.floor(this.materialsCollected / 2);
                    this.health = 50;
                    if (this.occupiedBy) {
                        this.occupiedBy.myNest = null;
                        this.occupiedBy = null;
                    }
                    return true; // Nest was damaged significantly
                }
                return false;}


                
            
            update(deltaTime) {
                if (!this.isComplete) return;
                
                // Calculate deterioration based on various factors
                let deteriorationAmount = this.deteriorationRate * (deltaTime / 1000);
                
                // Weather accelerates deterioration
                if (isRaining) {
                    deteriorationAmount *= 2.5; // Rain accelerates deterioration
                }
                
                // Seasonal factors
                const season = Math.floor((dayNightCycleCount % 80) / 20); // 0=spring, 1=summer, 2=fall, 3=winter
                if (season === 3) { // Winter
                    deteriorationAmount *= 1.5; // Harsh winter weather
                }
                
                // Occupied nests deteriorate more slowly
                if (this.occupiedBy) {
                    deteriorationAmount *= 0.5; // Halve deterioration if occupied
                    
                    // Occasional minor repairs when occupied
                    if (Math.random() < 0.01 * (deltaTime / 1000)) {
                        this.condition = Math.min(100, this.condition + 1);
                        debugLog(`Bird made minor repairs to nest at (${this.x}, ${this.y})`);
                    }
                }
                
                // Reduce condition
                this.condition = Math.max(0, this.condition - deteriorationAmount);
                
                // Check if condition crossed any thresholds
                this.checkCondition();
            }
            
            checkCondition() {
                // Check if condition dropped below maintenance threshold
                if (this.condition < this.maintenanceThreshold && !this.needsMaintenance) {
                    this.needsMaintenance = true;
                    if (this.occupiedBy) {
                        debugLog(`Nest at (${this.x}, ${this.y}) needs maintenance (${this.condition.toFixed(1)}%)`);
                    }
                }
                
                // Check if condition dropped below failure threshold
                if (this.condition < this.failureThreshold && this.isComplete) {
                    this.isComplete = false;
                    this.materialsCollected = Math.floor(NEST_MATERIALS_NEEDED / 2); // Nest partially collapses
                    this.readyForBabies = false;
                    debugLog(`Nest at (${this.x}, ${this.y}) has collapsed due to poor condition!`);
                    
                    // Any baby birds in collapsed nest may be endangered
                    const babiesInNest = babyBirds.filter(baby => 
                        distance(baby.x, baby.y, this.x, this.y) < 20
                    );
                    
                    for (const baby of babiesInNest) {
                        // 25% chance baby falls from collapsed nest
                        if (Math.random() < 0.25) {
                            // Baby falls from nest
                            baby.startFalling();
                        }
                    }
                    
                    // Alert occupying bird
                    if (this.occupiedBy) {
                        this.occupiedBy.myNest = null; // Bird loses connection to nest
                        this.occupiedBy = null;
                    }
                }
            }
            
            checkReadyForNewBabies(currentTime) {
                // If the nest has already had a baby and enough time has passed
                if (!this.readyForBabies && this.lastBabyTime > 0 && 
                    this.isComplete && this.condition > 70 &&
                    currentTime - this.lastBabyTime > 120000) { // 2 minutes
                    
                    this.readyForBabies = true;
                    this.lastBabyTime = 0;
                    debugLog(`Nest at (${this.x}, ${this.y}) ready for new babies!`);
                }
            }

            draw() {
                const completionRatio = this.materialsCollected / NEST_MATERIALS_NEEDED;
                const nestSize = 15 + completionRatio * 15;
                
                // Base of the nest - color varies with condition
                const conditionRatio = Math.max(0, this.condition / 100);
                const baseColor = this.ratOccupied ? '#966F33' : '#8B4513'; // Base color when good condition
                
                // Mix with gray as condition worsens
                const r1 = parseInt(baseColor.slice(1, 3), 16);
                const g1 = parseInt(baseColor.slice(3, 5), 16);
                const b1 = parseInt(baseColor.slice(5, 7), 16);
                
                const r2 = 100; // Gray color
                const g2 = 100;
                const b2 = 100;
                
                // Interpolate between base color and gray based on condition
                const r = Math.round(r1 * conditionRatio + r2 * (1 - conditionRatio));
                const g = Math.round(g1 * conditionRatio + g2 * (1 - conditionRatio));
                const b = Math.round(b1 * conditionRatio + b2 * (1 - conditionRatio));
                
                const nestColor = `rgb(${r}, ${g}, ${b})`;
                
                ctx.fillStyle = nestColor;
                ctx.beginPath();
                ctx.arc(this.x, this.y, nestSize, 0, Math.PI);
                ctx.fill();
                
                // Add detail to the nest based on completion and condition
                if (completionRatio > 0.2) {
                    // Twigs look more chaotic as condition worsens
                    const disarray = (1 - conditionRatio) * 0.5;
                    
                    ctx.strokeStyle = '#6B3E10';
                    ctx.lineWidth = 2;
                    
                    // Draw twigs sticking out with fixed angles
                    const twigCount = Math.min(
                        Math.floor(completionRatio * this.twigAngles.length),
                        this.twigAngles.length
                    );
                    
                    // Ensure twigAngles exists and has elements
                    if (Array.isArray(this.twigAngles) && this.twigAngles.length > 0) {
                        for (let i = 0; i < twigCount; i++) {
                            // Skip if index out of bounds
                            if (i >= this.twigAngles.length) continue;
                            
                            const twigInfo = this.twigAngles[i];
                            // Skip if twigInfo is undefined or missing required properties
                            if (!twigInfo || typeof twigInfo.angle !== 'number' || 
                                typeof twigInfo.length !== 'number') continue;
                            
                            // Add more random deviation to angle if nest is in disrepair
                            const disorderFactor = Math.random() * disarray * 0.4;
                            const angle = twigInfo.angle + disorderFactor + 
                                (twigInfo.offset || 0) * Math.sin(Date.now() / 8000);
                            
                            ctx.beginPath();
                            ctx.moveTo(
                                this.x + nestSize * Math.cos(angle), 
                                this.y + nestSize * Math.sin(angle) * 0.5
                            );
                            ctx.lineTo(
                                this.x + (nestSize + twigInfo.length) * Math.cos(angle),
                                this.y + (nestSize + twigInfo.length) * Math.sin(angle) * 0.5
                            );
                            ctx.stroke();
                            
                            // Some twigs appear loose in poor condition nests
                            if (this.condition < 50 && Math.random() < 0.3) {
                                ctx.beginPath();
                                const looseX = this.x + (nestSize + twigInfo.length * 0.6) * Math.cos(angle);
                                const looseY = this.y + (nestSize + twigInfo.length * 0.6) * Math.sin(angle) * 0.5;
                                const fallAngle = angle + (Math.random() - 0.5) * 0.5;
                                
                                ctx.moveTo(looseX, looseY);
                                ctx.lineTo(
                                    looseX + twigInfo.length * 0.4 * Math.cos(fallAngle),
                                    looseY + twigInfo.length * 0.4 * Math.sin(fallAngle)
                                );
                                ctx.stroke();
                            }
                        }
                    }
                }
                
                // Draw the inner part of the nest
                if (this.isComplete) {
                    // Inner nest color also affected by condition
                    const innerColor = this.ratOccupied ? 
                        `rgba(${Math.round(184*conditionRatio + 120*(1-conditionRatio))}, ${Math.round(134*conditionRatio + 120*(1-conditionRatio))}, ${Math.round(11*conditionRatio + 120*(1-conditionRatio))}, 1)` : 
                        `rgba(${Math.round(205*conditionRatio + 150*(1-conditionRatio))}, ${Math.round(167*conditionRatio + 150*(1-conditionRatio))}, ${Math.round(125*conditionRatio + 150*(1-conditionRatio))}, 1)`;
                    
                    ctx.fillStyle = innerColor;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, nestSize * 0.7, 0, Math.PI);
                    ctx.fill();
                    
                    // Draw rat in nest if occupied by one
                    if (this.ratOccupied) {
                        // Rat's eyes peeking out
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.arc(this.x - 5, this.y - 5, 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.arc(this.x + 5, this.y - 5, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Add visual cues for nest condition
                    if (this.condition < this.maintenanceThreshold) {
                        // Add loose threads/materials for nests needing repair
                        ctx.strokeStyle = '#6B3E10';
                        ctx.lineWidth = 1;
                        
                        const looseCount = Math.floor((this.maintenanceThreshold - this.condition) / 10) + 1;
                        for (let i = 0; i < looseCount; i++) {
                            const angle = Math.random() * Math.PI;
                            const radius = nestSize * (0.2 + Math.random() * 0.5);
                            
                            ctx.beginPath();
                            ctx.moveTo(this.x + Math.cos(angle) * radius, this.y + Math.sin(angle) * radius * 0.5);
                            ctx.lineTo(
                                this.x + Math.cos(angle) * (radius + 5 + Math.random() * 5),
                                this.y + Math.sin(angle) * (radius + 5 + Math.random() * 5) * 0.5
                            );
                            ctx.stroke();
                        }
                    }
                }
                
                // Draw debug health if enabled
                if (debugVisuals) {
                    // Health bar
                    ctx.fillStyle = this.health > 70 ? 'green' : (this.health > 30 ? 'orange' : 'red');
                    ctx.fillRect(this.x - 15, this.y - 25, 30 * (this.health / 100), 3);
                    
                    // Condition bar
                    ctx.fillStyle = this.condition > 70 ? 'blue' : (this.condition > 30 ? 'yellow' : 'red');
                    ctx.fillRect(this.x - 15, this.y - 30, 30 * (this.condition / 100), 3);
                    
                    if (this.ratOccupied) {
                        ctx.fillStyle = 'white';
                        ctx.font = '8px Arial';
                        ctx.fillText('Rat!', this.x - 10, this.y - 15);
                    }
                    
                    // Show ready for babies status
                    if (this.readyForBabies) {
                        ctx.fillStyle = 'yellow';
                        ctx.font = '8px Arial';
                        ctx.fillText('Ready!', this.x - 15, this.y - 35);
                    }
                    
                    // Show needs maintenance
                    if (this.needsMaintenance) {
                        ctx.fillStyle = 'orange';
                        ctx.font = '8px Arial';
                        ctx.fillText('Repair!', this.x - 15, this.y - 40);
                    }
                }
            }
        }
        
        // V26: Fixed Birdhouse class with properly shown top half
        class Birdhouse {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.materialsCollected = 0;
                this.isComplete = false;
                this.health = 100;
                this.occupants = [];
                this.maxOccupants = 2;
                
                // House properties
                this.width = 35;
                this.height = 40;
                this.roofHeight = 15;
                this.entranceSize = 10;
                this.poleHeight = 50; // Increased from 30 to ensure visibility
                
                // Randomly determine color scheme
                const colorSchemes = [
                    { body: '#D35400', roof: '#6C3483', trim: '#F1C40F' },  // Orange/Purple
                    { body: '#2980B9', roof: '#C0392B', trim: '#ECF0F1' },  // Blue/Red
                    { body: '#1E8449', roof: '#7D3C98', trim: '#F39C12' },  // Green/Purple
                    { body: '#A04000', roof: '#1B4F72', trim: '#D4AC0D' },  // Brown/Blue
                    { body: '#7D6608', roof: '#186A3B', trim: '#E74C3C' }   // Mustard/Green
                ];
                this.colors = colorSchemes[Math.floor(Math.random() * colorSchemes.length)];
                
                // Generate slight variation in dimensions
                this.width *= 0.9 + Math.random() * 0.2;
                this.height *= 0.9 + Math.random() * 0.2;
                this.entranceSize *= 0.9 + Math.random() * 0.2;
            }
            
            addMaterial() {
                this.materialsCollected++;
                if (this.materialsCollected >= BIRDHOUSE_MATERIALS_NEEDED && !this.isComplete) {
                    this.isComplete = true;
                    debugLog(`Birdhouse at (${this.x}, ${this.y}) is complete!`);
                }
                return this.isComplete;
            }
            
            damage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    return true; // Birdhouse was destroyed
                }
                return false;
            }
            
            canAcceptOccupant() {
                return this.isComplete && this.occupants.length < this.maxOccupants;
            }
            
            addOccupant(bird) {
                if (this.canAcceptOccupant()) {
                    this.occupants.push(bird);
                    return true;
                }
                return false;
            }
            
            removeOccupant(bird) {
                const index = this.occupants.indexOf(bird);
                if (index !== -1) {
                    this.occupants.splice(index, 1);
                    return true;
                }
                return false;
            }
            
            draw() {
                // Fixed drawing order to ensure all parts are visible
                
                // Draw support pole - proper connection fixed
                ctx.fillStyle = '#8B4513';
                const poleWidth = 6;
                const poleX = this.x - poleWidth/2;
                const poleBottom = this.y;
                const poleTop = this.y - this.poleHeight;
                
                // Draw the pole connected to both ground and birdhouse
                ctx.fillRect(
                    poleX, 
                    poleTop, // Top of pole connects to birdhouse
                    poleWidth, 
                    this.poleHeight // Full height to ground
                );
                
                // Position for the house components
                const houseBottom = poleTop;
                
                if (!this.isComplete) {
                    // Draw partially built birdhouse
                    const completionRatio = this.materialsCollected / BIRDHOUSE_MATERIALS_NEEDED;
                    
                    if (completionRatio > 0.3) {
                        // Draw partial house body
                        const partialHeight = this.height * Math.min(1, completionRatio * 1.5);
                        ctx.fillStyle = '#A0522D';
                        ctx.fillRect(
                            this.x - this.width/2, 
                            houseBottom - partialHeight,
                            this.width * completionRatio,
                            partialHeight
                        );
                    }
                    
                    if (completionRatio > 0.7) {
                        // Draw partial roof
                        const roofCompletionRatio = (completionRatio - 0.7) * 3.33; // Scale to 0-1
                        ctx.fillStyle = '#8B4513';
                        ctx.beginPath();
                        ctx.moveTo(this.x - this.width/2 - 5, houseBottom - this.height);
                        ctx.lineTo(this.x + this.width/2 * roofCompletionRatio, houseBottom - this.height);
                        ctx.lineTo(this.x, houseBottom - this.height - this.roofHeight * roofCompletionRatio);
                        ctx.closePath();
                        ctx.fill();
                    }
                } else {
                    // Draw completed birdhouse
                    
                    // House body
                    ctx.fillStyle = this.colors.body;
                    ctx.fillRect(
                        this.x - this.width/2, 
                        houseBottom - this.height,
                        this.width,
                        this.height
                    );
                    
                    // Roof - draw this after body to ensure it's visible
                    ctx.fillStyle = this.colors.roof;
                    ctx.beginPath();
                    ctx.moveTo(this.x - this.width/2 - 5, houseBottom - this.height);
                    ctx.lineTo(this.x + this.width/2 + 5, houseBottom - this.height);
                    ctx.lineTo(this.x, houseBottom - this.height - this.roofHeight);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Entrance hole
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(
                        this.x, 
                        houseBottom - this.height + this.height * 0.3,
                        this.entranceSize/2,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                    
                    // Perch stick
                    ctx.fillStyle = this.colors.trim;
                    ctx.fillRect(
                        this.x - this.entranceSize/2,
                        houseBottom - this.height + this.height * 0.3 + this.entranceSize/2,
                        this.entranceSize,
                        2
                    );
                    
                    // Decorative trimming
                    ctx.fillStyle = this.colors.trim;
                    ctx.fillRect(
                        this.x - this.width/2,
                        houseBottom - this.height * 0.2,
                        this.width,
                        3
                    );
                }
                
                // Draw debug health if enabled
                if (debugVisuals) {
                    // Health bar
                    ctx.fillStyle = this.health > 70 ? 'green' : (this.health > 30 ? 'orange' : 'red');
                    ctx.fillRect(
                        this.x - 15, 
                        houseBottom - this.height - this.roofHeight - 10, 
                        30 * (this.health / 100), 
                        3
                    );
                    
                    // Show occupancy
                    if (this.isComplete) {
                        ctx.fillStyle = 'rgba(255,255,255,0.7)';
                        ctx.font = '10px Arial';
                        ctx.fillText(
                            `${this.occupants.length}/${this.maxOccupants}`,
                            this.x - 8,
                            houseBottom - this.height - this.roofHeight - 15
                        );
                    }
                }
            }
        }

        // V26: Enhanced BabyBird class with gentler bobbing
       
       
       
       
        class BabyBird {
    constructor(x, y, birdType, nestObj = null) {
        this.x = x;
        this.y = y;
        this.age = 0;
        this.timeSinceLastMeal = 0;
        this.feedCount = 0;
        this.birdType = birdType || BIRD_TYPES[Math.floor(Math.random() * BIRD_TYPES.length)];
        this.size = 6;
        this.bobTimer = 0;
        this.bobSpeed = 0.05 + Math.random() * 0.02; // Reduced from 0.1 + Math.random() * 0.05
        this.associatedNest = nestObj; // Store reference to associated nest
        this.isFalling = false; // New falling state flag
        this.fallVelocity = 0; // New velocity for falling
    }

    update(deltaTime) {
    // Slower, gentler bobbing
    this.bobTimer += this.bobSpeed * deltaTime;
    
    this.age += deltaTime / 1000;
    this.timeSinceLastMeal += deltaTime / 1000;
    
    // Baby birds grow if fed regularly - fewer feedings required
    if (this.feedCount >= 6 && this.age > 45) { // Reduced from 8 feeds and 60 seconds
        debugLog(`Baby bird at (${this.x}, ${this.y}) matured into an adult.`);
        birds.push(new Bird(false, this.birdType, this.x, this.y));
        
        // Increment the babies born counter
        totalBabiesBorn++;
        
        // Create a flower where the baby matured
        createFlower(this.x, this.y);

            // Reset the nest to be ready for new babies after a delay
            if (this.associatedNest) {
                this.associatedNest.lastBabyTime = Date.now();
                setTimeout(() => {
                    this.associatedNest.readyForBabies = true;
                    debugLog(`Nest at (${this.associatedNest.x}, ${this.associatedNest.y}) ready for new babies!`);
                }, 60000); // One minute cooldown before new babies
            }
                        
            return true; // Should be removed
        }
        
        // Baby birds die if not fed for longer
        if (this.timeSinceLastMeal > 420) { // Increased from 120
            debugLog(`Baby bird at (${this.x}, ${this.y}) died from lack of food after ${this.timeSinceLastMeal.toFixed(0)} seconds.`);
            return true; // Should be removed
        }
        
        // Handle falling baby birds
        if (this.isFalling) {
            // Apply gravity
            this.fallVelocity += GRAVITY * (deltaTime / 16);
            this.y += this.fallVelocity * (deltaTime / 16);
            
            // Check for ground collision
            if (this.y >= canvas.height * GROUND_HEIGHT_RATIO - 10) {
                this.y = canvas.height * GROUND_HEIGHT_RATIO - 10;
                this.isFalling = false;
                this.associatedNest = null; // No longer in a nest
                debugLog(`Baby bird landed on ground`);
            }
        }
        
        return false;
    }
    
    feed() {
        this.feedCount += 1; // Increased from 0.5 - faster growth
        this.timeSinceLastMeal = 0;
        this.size = Math.min(11, 6 + this.feedCount * 0.5);
        debugLog(`Baby bird fed! Feed count: ${this.feedCount}`);
    }

    startFalling() {
        this.isFalling = true;
        this.fallVelocity = 0.5; // Initial fall velocity
        this.y += 20; // Move down initially
        this.timeSinceLastMeal += 20; // Stress makes them hungrier
        debugLog(`Baby bird falling because tree was removed`);
    }

    draw() {
        // More gentle bobbing with reduced amplitude
        const bobAmount = Math.sin(this.bobTimer) * 1.5; // Reduced from 3
        // Get colors based on bird type
        let bodyColor = this.birdType.bodyColor + '88'; // Lighter version with transparency
        let bellyColor = this.birdType.bellyColor + '88';
        
        // Extra fluffy body
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        
        // Draw a fluffier, rounder body
        const baseSize = this.size * 1.2;
        ctx.arc(this.x, this.y + bobAmount, baseSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Add some fuzzy edges to simulate baby feathers
        ctx.fillStyle = bodyColor;
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const fuzzX = this.x + Math.cos(angle) * baseSize * 0.9;
            const fuzzY = this.y + bobAmount + Math.sin(angle) * baseSize * 0.9;
            const fuzzSize = baseSize * 0.4;
            
            ctx.beginPath();
            ctx.arc(fuzzX, fuzzY, fuzzSize, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Belly
        ctx.fillStyle = bellyColor;
        ctx.beginPath();
        ctx.arc(this.x, this.y + baseSize * 0.3 + bobAmount, baseSize * 0.7, 0, Math.PI);
        ctx.fill();
        
        // Extra large beak that opens and closes
        ctx.fillStyle = '#FFAA55';
        ctx.beginPath();
        
        const beakOpenAmount = (Math.sin(this.bobTimer / 300) + 1) * 2.5;
        const beakWidth = baseSize * 0.7;
        
        // Triangular beak that opens and closes
        ctx.moveTo(this.x, this.y + bobAmount);
        ctx.lineTo(this.x + beakWidth, this.y - beakOpenAmount + bobAmount);
        ctx.lineTo(this.x + beakWidth, this.y + beakOpenAmount + bobAmount);
        ctx.fill();
        
        // Inside of mouth
        ctx.fillStyle = '#FF9999';
        ctx.beginPath();
        ctx.moveTo(this.x + beakWidth * 0.3, this.y + bobAmount);
        ctx.lineTo(this.x + beakWidth * 0.8, this.y - beakOpenAmount * 0.7 + bobAmount);
        ctx.lineTo(this.x + beakWidth * 0.8, this.y + beakOpenAmount * 0.7 + bobAmount);
        ctx.fill();
        
        // Big, cute eyes with highlights
        ctx.fillStyle = 'black';
        const eyeSize = baseSize * 0.3;
        ctx.beginPath();
        ctx.arc(this.x - baseSize * 0.3, this.y - baseSize * 0.2 + bobAmount, eyeSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye highlights
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.x - baseSize * 0.25, this.y - baseSize * 0.25 + bobAmount, eyeSize * 0.4, 0, Math.PI * 2);
        ctx.fill();
        
        // Show feeding info if debugging
        if (debugVisuals) {
            ctx.fillStyle = this.timeSinceLastMeal > 60 ? 'red' : 'green';
            ctx.fillRect(this.x - baseSize, this.y - baseSize - 8 + bobAmount, 
                       baseSize * 2 * (this.feedCount / 6), 3); // Changed from 8 to 6
                       
            // Show feedCount
            ctx.fillStyle = 'white';
            ctx.font = '8px Arial';
            ctx.fillText(`F:${this.feedCount.toFixed(1)}`, this.x - baseSize, this.y - baseSize - 15 + bobAmount);
            
            // Show falling status if applicable
            if (this.isFalling) {
                ctx.fillStyle = 'red';
                ctx.fillText('Falling!', this.x - baseSize, this.y - baseSize - 25 + bobAmount);
            }
        }
    }
}




        // Spawn birds - Birds spawn off-screen now and limited by MAX_BIRDS
        // Modify the spawnBird function
function spawnBird() {
    if (birds.length < MAX_BIRDS) {
        const newBird = new Bird();
        
        // Choose a random edge to fly in from
        const edges = [
            { side: 'top', x: Math.random() * canvas.width, y: -30 },
            { side: 'right', x: canvas.width + 30, y: Math.random() * canvas.height * 0.7 },
            { side: 'bottom', x: Math.random() * canvas.width, y: canvas.height + 30 },
            { side: 'left', x: -30, y: Math.random() * canvas.height * 0.7 }
        ];
        
        const edge = edges[Math.floor(Math.random() * edges.length)];
        newBird.x = edge.x;
        newBird.y = edge.y;
        
        // Set initial state to flying and generate path to center
        newBird.state = BIRD_STATES.FLYING;
        const targetX = canvas.width / 2;
        const targetY = canvas.height / 2;
        newBird.generatePath(targetX, targetY);
        
        birds.push(newBird);
        debugLog(`Bird spawned from ${edge.side} edge at (${newBird.x}, ${newBird.y})`);
    }
}
        
        // Wild bird spawn
        function spawnWildBird() {
            // Spawn wild birds with smoother entry
            if (Math.random() < WILD_BIRD_SPAWN_CHANCE) {
                const wildBird = new Bird(true); // true = wild bird
                
                // More varied entry points
                const entryOptions = [
                    { side: 'left', x: -30, y: Math.random() * canvas.height * 0.6, dir: 1 },
                    { side: 'right', x: canvas.width + 30, y: Math.random() * canvas.height * 0.6, dir: -1 },
                    { side: 'top', x: Math.random() * canvas.width, y: -30, dir: Math.random() < 0.5 ? -1 : 1 }
                ];
                
                // Choose a random entry point
                const entry = entryOptions[Math.floor(Math.random() * entryOptions.length)];
                
                wildBird.x = entry.x;
                wildBird.y = entry.y;
                wildBird.direction = entry.dir;
                
                // Better initial velocity
                wildBird.velocity.x = wildBird.direction * wildBird.baseSpeed * 1.5;
                wildBird.velocity.y = entry.side === 'top' ? wildBird.baseSpeed * 0.5 : (Math.random() - 0.5) * wildBird.baseSpeed;
                
                // First visible point inside screen
                const firstVisibleX = entry.side === 'left' ? 50 : (entry.side === 'right' ? canvas.width - 50 : entry.x);
                const firstVisibleY = entry.side === 'top' ? 50 : entry.y;
                
                // Mid-garden point with some randomness
                const midX = canvas.width/2 + (Math.random() - 0.5) * canvas.width/3;
                const midY = canvas.height * 0.3 + Math.random() * canvas.height * 0.2;
                
                // Exit point
                const exitSide = entry.side === 'left' ? 'right' : (entry.side === 'right' ? 'left' : (Math.random() < 0.5 ? 'left' : 'right'));
                const exitX = exitSide === 'left' ? -30 : canvas.width + 30;
                const exitY = Math.random() * canvas.height * 0.6;
                
                // Create path with additional control points for arcing
                wildBird.path = [
                    { x: entry.x, y: entry.y },                // Starting off-screen
                    { x: firstVisibleX, y: firstVisibleY },    // First visible point
                    { x: (firstVisibleX + midX) / 2,           // Control point 1
                      y: Math.min(firstVisibleY, midY) - 20 },
                    { x: midX, y: midY },                      // Mid-garden point
                    { x: (midX + exitX) / 2,                   // Control point 2
                      y: Math.min(midY, exitY) - 20 },
                    { x: exitX, y: exitY }                     // Exit point
                ];
                
                wildBird.pathIndex = 0;
                wildBird.state = BIRD_STATES.FLYING;
                
                birds.push(wildBird);
                debugLog(`Wild bird visiting from ${entry.side} with natural path`);
            }
            
            // Add rare flock behavior
            if (dayNightCycleCount > 0 && dayNightCycleCount % 3 === 0 && 
                timeOfDay < 0.3 && Math.random() < 0.1) {
                // Spawn a flock of 3-5 birds
                const flockSize = 3 + Math.floor(Math.random() * 3);
                const flockType = BIRD_TYPES[Math.floor(Math.random() * BIRD_TYPES.length)];
                const startSide = Math.random() < 0.5 ? "left" : "right";
                const direction = startSide === "left" ? 1 : -1;
                const startX = startSide === "left" ? -30 : canvas.width + 30;
                const startY = canvas.height * 0.3 + Math.random() * canvas.height * 0.2;
                
                for (let i = 0; i < flockSize; i++) {
                    // Create birds of the same type with similar paths
                    const wildBird = new Bird(true, flockType);
                    
                    // Set formation position with slight variation
                    wildBird.x = startX;
                    wildBird.y = startY + (i - flockSize/2) * 15; 
                    wildBird.direction = direction;
                    
                    // Set initial velocity
                    wildBird.velocity.x = direction * wildBird.baseSpeed * 2;
                    wildBird.velocity.y = (Math.random() - 0.5) * wildBird.baseSpeed * 0.5;
                    
                    // Generate path with slight variations
                    const midX = canvas.width/2 + (Math.random() - 0.5) * 50;
                    const midY = canvas.height * 0.3 + (i - flockSize/2) * 20;
                    
                    const exitX = direction === 1 ? canvas.width + 30 : -30;
                    const exitY = startY + (i - flockSize/2) * 15;
                    
                    // Use improved path with more control points for natural flight
                    wildBird.path = [
                        { x: wildBird.x, y: wildBird.y },    // Starting position
                        { x: startX + direction * 100, y: wildBird.y }, // Entry point
                        { x: midX, y: midY },                // Mid point
                        { x: (midX + exitX)/2, y: (midY + exitY)/2 - 20 }, // Control point
                        { x: exitX, y: exitY }               // Exit point
                    ];
                    
                    wildBird.pathIndex = 0;
                    wildBird.state = BIRD_STATES.FLYING;
                    
                    birds.push(wildBird);
                }
                
                debugLog(`A flock of ${flockSize} ${flockType.name}s is visiting!`);
            }
        }

        function checkAndAlertForHungryBabies() {
            // Find hungry babies that haven't been fed for a while
            const hungryBabies = babyBirds.filter(baby => baby.timeSinceLastMeal > 30); // Reduced from 60
            
            // Alert birds for each hungry baby
            for (const baby of hungryBabies) {
                alertBirdsToFeedBaby(baby);
                debugLog(`Alerting birds about hungry baby at (${baby.x}, ${baby.y})`);
            }
        }

        // Helper function to alert birds to feed babies
        function alertBirdsToFeedBaby(babyBird) {
            // Find birds that aren't currently busy with critical tasks
            const availableBirds = birds.filter(bird => 
                !bird.isWild && 
                bird.state !== BIRD_STATES.BUILDING && 
                bird.state !== BIRD_STATES.COLLECTING &&
                bird.state !== BIRD_STATES.FLEEING
            );
            
            // If there are available birds, direct one to feed the baby
            if (availableBirds.length > 0) {
                // Choose closest bird
                availableBirds.sort((a, b) => {
                    const distA = distance(a.x, a.y, babyBird.x, babyBird.y);
                    const distB = distance(b.x, b.y, babyBird.x, babyBird.y);
                    return distA - distB;
                });
                
                // Try to assign parent bird if baby is in a nest
                let assignedBird = null;
                if (babyBird.associatedNest && babyBird.associatedNest.occupiedBy) {
                    assignedBird = babyBird.associatedNest.occupiedBy;
                } else {
                    // Otherwise assign closest bird
                    assignedBird = availableBirds[0];
                }
                
                // Set bird to hunting state targeting the baby bird
                assignedBird.target = {
                    type: 'baby',
                    x: babyBird.x,
                    y: babyBird.y,
                    baby: babyBird
                };
                assignedBird.state = BIRD_STATES.HUNTING;
                assignedBird.stateTimer = 0;
                
                // Have bird find food first if it doesn't have any
                if (assignedBird.hunger > 200) {
                    assignedBird.findFoodSource();
                }
                
                debugLog(`Bird directed to feed baby bird`);
            }
        }

       // Find your existing resetStuckBirds function and ADD the tree-stuck detection inside of it:

// V26: Less frequent stuck bird detection with gentler handling 
function resetStuckBirds() {
    const groundY = canvas.height * GROUND_HEIGHT_RATIO;
    let stuckBirdsFixed = 0;
    const maxFixesPerFrame = 3; // Reduced from 5 to be more gentle
    
    for (let i = 0; i < birds.length && stuckBirdsFixed < maxFixesPerFrame; i++) {
        const bird = birds[i];
        
        // Initialize or update last position tracking
        if (!bird.lastPosition) {
            bird.lastPosition = { x: bird.x, y: bird.y };
            bird.stuckTime = 0;
        } else {
            const dist = distance(bird.x, bird.y, bird.lastPosition.x, bird.lastPosition.y);
            
            // Check if bird is stuck (not moving)
            if (dist < 1 && bird.state !== BIRD_STATES.PERCHED && bird.state !== BIRD_STATES.RESTING) {
                bird.stuckTime = (bird.stuckTime || 0) + 16;
                
                // Special treatment for off-screen birds
                const isOffScreen = bird.x < -20 || bird.x > canvas.width + 20 || 
                                    bird.y < -20 || bird.y > canvas.height + 20;
                
                // More aggressive unsticking for birds in known problem areas
                const inProblemArea = problemAreas.some(area => 
                    Math.abs(bird.x - area.x) < area.radius
                );
                
                // Increase stuck time thresholds - birds get more time before being unstuck
                const stuckThreshold = inProblemArea ? 300 : (isOffScreen ? 600 : 1000); // Increased thresholds
                
                if (bird.stuckTime > stuckThreshold) {
                    // Gentler unsticking action
                    // 1. Reset bird state but maintain direction
                    bird.state = BIRD_STATES.FLYING;
                    bird.target = null;
                    bird.stateTimer = 0;
                    bird.stuckTime = 0;
                    
                    // 2. Gently modify velocity to break patterns without jarring changes
                    bird.velocity = { 
                        x: bird.velocity.x * 0.3 + (Math.random() - 0.5) * 0.2,
                        y: bird.velocity.y * 0.3 - 0.05  // Slight upward bias
                    };
                    
                    // 3. Generate path to safe area (away from problem areas)
                    const safeX = findSafeX(problemAreas);
                    const safeY = 100 + Math.random() * (canvas.height * 0.3);
                    
                    bird.generatePath(safeX, safeY);
                    
                    // 4. Drop any held materials
                    if (bird.materialsHeld > 0) {
                        twigs.push({
                            x: bird.x,
                            y: groundY + Math.random() * 10,
                            size: 10 + Math.random() * 8,
                            angle: Math.PI / 4 + Math.random() * Math.PI / 2,
                            isSpecial: bird.hasSpecialTwig,
                            offshoots: []
                        });
                        bird.materialsHeld = 0;
                        bird.hasSpecialTwig = false;
                    }
                    
                    stuckBirdsFixed++;
                    debugLog(`Gentle unstick for bird at (${bird.x}, ${bird.y})`);
                }
            } else {
                // Bird is moving, update last position
                bird.lastPosition = { x: bird.x, y: bird.y };
                // Reduce stuck time more rapidly when moving
                bird.stuckTime = Math.max(0, bird.stuckTime - 64); // Doubled reduction rate
            }
        }
        
        // TREE STUCK DETECTION - ADD THIS SECTION
        // Only check some birds each frame for performance (10% chance)
        if (Math.random() < 0.1) {
            // Skip birds that are intentionally perched or building
            if (bird.state !== BIRD_STATES.PERCHED && 
                bird.state !== BIRD_STATES.BUILDING &&
                bird.state !== BIRD_STATES.RESTING) {
                
                try {
                    // Check if the bird is between two tree trunks
                    let treesToLeft = 0;
                    let treesToRight = 0;
                    
                    // Count trees on left and right with simple approach
                    for (const tree of trees) {
                        if (Math.abs(bird.x - tree.x) < tree.trunkWidth * 2) {
                            if (tree.x < bird.x) treesToLeft++;
                            if (tree.x > bird.x) treesToRight++;
                        }
                    }
                    
                    // If trees on both sides and bird is already showing stuck behavior
                    if (treesToLeft > 0 && treesToRight > 0 && bird.stuckTime > 300) {
                        // Apply gentle escape velocity
                        bird.velocity.y = -0.5; // Up
                        
                        // Choose escape direction
                        if (treesToLeft > treesToRight) {
                            bird.velocity.x = 0.5; // Right
                            bird.direction = 1;
                        } else {
                            bird.velocity.x = -0.5; // Left
                            bird.direction = -1;
                        }
                        
                        bird.state = BIRD_STATES.FLYING;
                        bird.stateTimer = 0;
                        
                        stuckBirdsFixed++;
                        debugLog(`Bird freed from between trees at (${bird.x}, ${bird.y})`);
                    }
                } catch (e) {
                    // Safely ignore any errors without breaking main loop
                    console.error("Error in tree stuck detection:", e);
                }
            }
        }
        // END OF TREE STUCK DETECTION ADDITION
        
        // Check if bird is stuck near a tree - much gentler approach
        const nearbyTree = trees.find(tree => 
            distance(bird.x, bird.y, tree.x, tree.y - tree.trunkHeight/2) < 70
        );

        if (nearbyTree && bird.stuckTime > 500) { // Increased threshold for tree-related stuckness
            // Apply gentle push away from the tree
            const dirX = bird.x < nearbyTree.x ? -1 : 1;
            bird.applyForce({ 
                x: dirX * 0.08, // Reduced from 0.2
                y: -0.04 // Reduced from -0.1
            });
            
            // Only reset state if clearly stuck
            if (bird.stuckTime > 800) {
                bird.state = BIRD_STATES.FLYING;
                bird.stateTimer = 0;
                
                // Generate a path away from the tree
                const targetX = bird.x + dirX * 80; // Reduced from 100
                const targetY = bird.y - 30; // Reduced from 50
                bird.generatePath(targetX, targetY);
                
                bird.stuckTime = 0;
                stuckBirdsFixed++;
                debugLog(`Gentle push for bird stuck near tree at (${bird.x}, ${bird.y})`);
            }
        }
        
        // Enhanced stasis detection with more patience
        if (bird.path && bird.path.length > 0 && bird.pathIndex < bird.path.length) {
            const waypoint = bird.path[bird.pathIndex];
            const waypointDist = distance(bird.x, bird.y, waypoint.x, waypoint.y);
            
            if (bird.lastWaypointDist && Math.abs(bird.lastWaypointDist - waypointDist) < 1 && bird.stateTimer > 2000) {
                bird.waypointStuckTime = (bird.waypointStuckTime || 0) + 16;
                
                // Make waypoint skipping more patient
                if (bird.waypointStuckTime > 400) { // Increased from 200
                    // Skip to next waypoint
                    bird.pathIndex++;
                    bird.waypointStuckTime = 0;
                    
                    // Apply small push in the direction of movement
                    if (bird.pathIndex < bird.path.length) {
                        const nextWaypoint = bird.path[bird.pathIndex];
                        const dx = nextWaypoint.x - bird.x;
                        const dy = nextWaypoint.y - bird.y;
                        const dir = normalize(dx, dy);
                        
                        bird.applyForce({ 
                            x: dir.x * 0.05, // Reduced from 0.1
                            y: dir.y * 0.05  // Reduced from 0.1
                        });
                    }
                    // If no more waypoints, find new state
                    else {
                        bird.state = BIRD_STATES.FLYING;
                        bird.stateTimer = 0;
                        
                        // Choose a new target
                        const targetX = 100 + Math.random() * (canvas.width - 200);
                        const targetY = 100 + Math.random() * (canvas.height * 0.5 - 100);
                        bird.generatePath(targetX, targetY);
                    }
                    
                    stuckBirdsFixed++;
                    debugLog(`Bird gently led past stuck waypoint`);
                }
            } else {
                bird.lastWaypointDist = waypointDist;
                bird.waypointStuckTime = 0;
            }
        }
    }
}

  // Draw worms with wiggle
function drawWorms() {
    worms.forEach(worm => {
        worm.wiggle += WORM_WIGGLE_SPEED * 0.1;
        
        // Base worm body - night worms can be a slightly different color
        ctx.fillStyle = worm.isNightWorm ? '#BC8866' : '#AA7755'; // Night worms are slightly lighter
        
        // Draw segmented worm body
        const segments = 5;
        const segmentLength = worm.size / segments;
        
        for (let i = 0; i < segments; i++) {
            const wiggleOffset = Math.sin(worm.wiggle + i * 0.5) * 3;
            
            ctx.beginPath();
            ctx.arc(
                worm.x + wiggleOffset, 
                worm.y + i * segmentLength * 0.5, 
                segmentLength * (1 - i * 0.1), 
                0, Math.PI * 2
            );
            ctx.fill();
        }
    });
}

        // Draw twigs on ground
        function drawTwigs() {
            twigs.forEach((twig) => {
                // Check if twig is in a pond - if so, flatten it for frogs to use
                let isInPond = false;
                let adjustedAngle = twig.angle;

                for (const pond of ponds) {
                    const distToPond = Math.sqrt(
                        Math.pow(twig.x - pond.x, 2) +
                        Math.pow(twig.y - (pond.y + pond.height), 2)
                    );
                    if (distToPond < pond.width) {
                        isInPond = true;
                        // Flatten the branch to be more horizontal (Frogger reference)
                        adjustedAngle = (Math.random() - 0.5) * Math.PI * 0.2; // Nearly horizontal
                        break;
                    }
                }

                ctx.save();
                ctx.translate(twig.x, twig.y);
                ctx.rotate(adjustedAngle);

                // Draw branch - color differently if it's a special twig
                if (twig.isSpecial) {
                    // Special twigs have a slight glow and lighter color
                    ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
                    ctx.shadowBlur = 5;
                    ctx.fillStyle = '#D2B48C'; // Lighter wood color
                } else {
                    ctx.fillStyle = '#8B4513';
                }
                
                ctx.fillRect(-2, -2, twig.size, 4);
                
                // Draw fixed offshoots
                if (!twig.offshoots) {
                    twig.offshoots = [];
                    for (let i = 0; i < 3; i++) {
                        twig.offshoots.push({
                            position: Math.random() * twig.size,
                            length: 2 + Math.random() * 4,
                            angle: (Math.random() - 0.5) * Math.PI / 2
                        });
                    }
                }
                
                // Draw the pre-calculated offshoots
                twig.offshoots.forEach(offshoot => {
                    ctx.save();
                    ctx.translate(offshoot.position, 0);
                    ctx.rotate(offshoot.angle);
                    ctx.fillRect(0, 0, offshoot.length, 1);
                    ctx.restore();
                });
                
                ctx.restore();
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                
                // Add special indicator for special twigs
                if (twig.isSpecial && debugVisuals) {
                    ctx.fillStyle = 'gold';
                    ctx.beginPath();
                    ctx.arc(twig.x, twig.y - 10, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        // Draw bird poops with falling animation (smaller sizes)
        function drawBirdPoops(deltaTime) {
            // Limit bird poops for performance
            if (birdPoops.length > MAX_BIRD_POOPS) {
                // Remove oldest poops (sorted by timer)
                birdPoops.sort((a, b) => b.timer - a.timer);
                birdPoops.splice(MAX_BIRD_POOPS);
            }
            
            for (let i = birdPoops.length - 1; i >= 0; i--) {
                const poop = birdPoops[i];
                poop.timer += deltaTime;
                
                // Handle falling animation until ground is reached
                if (!poop.grounded) {
                    poop.y += poop.yVelocity * (deltaTime / 16);
                    poop.yVelocity += 0.05 * (deltaTime / 16);
                    
                    // Check if poop has hit the ground
                    if (poop.y >= canvas.height * GROUND_HEIGHT_RATIO) {
                        poop.y = canvas.height * GROUND_HEIGHT_RATIO;
                        poop.grounded = true;
                        debugLog(`Poop landed at (${poop.x}, ${poop.y})`);
                    }
                }
                
                // Rain washes away poop gradually once on ground
                if (poop.grounded && isRaining) {
                    poop.size -= POOP_WASH_RATE * (deltaTime / 1000);
                }
                
                if (poop.size > 0) {
                    if (poop.grounded) {
                        // Ground poop with splatter - Grey/white tone
                        // Use white with slight grey/green tint for main poop
                        ctx.fillStyle = '#E6E8E6'; // Light grey-white color
                        ctx.beginPath();
                        ctx.arc(poop.x, poop.y, poop.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add darker center
                        ctx.fillStyle = '#C0C2C0'; // Slightly darker grey
                        ctx.beginPath();
                        ctx.arc(poop.x, poop.y, poop.size * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add splatter effect for grounded poop
                        if (poop.size > 1.5) { // Reduced threshold
                            ctx.fillStyle = 'rgba(200, 205, 200, 0.6)'; // Transparent grey-white
                            
                            // Use consistent splatter pattern
                            const splatSeed = Math.floor(poop.x);
                            for (let i = 0; i < 2; i++) { // Reduced from 3 splats
                                const angle = ((splatSeed * (i + 1)) % 100) / 100 * Math.PI * 2;
                                const distance = poop.size + ((splatSeed * (i + 2)) % 10) / 4;
                                const splatterSize = poop.size * 0.2; // Reduced from 0.3
                                
                                ctx.beginPath();
                                ctx.arc(
                                    poop.x + Math.cos(angle) * distance,
                                    poop.y + Math.sin(angle) * distance,
                                    splatterSize,
                                    0, Math.PI * 2
                                );
                                ctx.fill();
                            }
                        }
                    } else {
                        // Falling poop - white with grey tint
                        // For falling poop, add slight gradient effect
                        const gradient = ctx.createRadialGradient(
                            poop.x, poop.y, 0,
                            poop.x, poop.y, poop.size
                        );
                        gradient.addColorStop(0, '#FFFFFF');
                        gradient.addColorStop(0.5, '#E6E8E6');
                        gradient.addColorStop(1, '#C0C2C0');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(poop.x, poop.y, poop.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else {
                    // Remove poop if too small
                    birdPoops.splice(i, 1);
                }
            }
        }

        // Helper to add branches to trees
        function addBranchToTree(tree) {
            if (!tree.hasBranches) {
                tree.hasBranches = true;
                tree.branches = [];
            }
            
            // Create a new branch with proper upward angle
            const isRightSide = Math.random() > 0.5;
            let branchAngle;
            
            if (isRightSide) {
                // Right side branches point up and right (-π/4 to -π/2)
                branchAngle = -Math.PI/4 - Math.random() * (Math.PI/4);
            } else {
                // Left side branches point up and left (5π/4 to 3π/2)
                branchAngle = (5 * Math.PI)/4 + Math.random() * (Math.PI/4);
            }
            
            const heightPosition = 0.3 + Math.random() * 0.6; // 30% to 90% up the trunk
            
            tree.branches.push({
                height: tree.trunkHeight * heightPosition,
                length: 30 + Math.random() * 40,
                angle: branchAngle,
                thickness: tree.trunkWidth * (0.3 + Math.random() * 0.3)
            });
            debugLog(`New branch added to tree at (${tree.x})`);
        }

        // Tree class
        class Tree {
            constructor(x, trunkWidth, trunkHeight, leafRadius, hasBranches = false) {
                this.x = x;
                this.trunkWidth = trunkWidth;
                this.trunkHeight = trunkHeight;
                this.leafRadius = leafRadius;
                this.health = 100;
                this.hasBranches = hasBranches;
                this.branches = [];
                this.nest = null;
                this.depth = Math.random(); // 0 = foreground, 1 = background
                this.scale = 1 - this.depth * 0.3; // Scale based on depth (0.7x to 1.0x)
                this.age = Math.random() * (TREE_LIFESPAN * 0.5); // Stagger initial ages

                // Add depth variance: foreground trees (depth < 0.3) start deeper in grass
                // This creates 1-2 inches (20-40px) of depth perception
                const depthOffset = this.depth < 0.3 ? (20 + Math.random() * 20) : 0;
                this.y = canvas.height * GROUND_HEIGHT_RATIO + depthOffset;

                // Make foreground trees slightly thicker for more depth perception
                if (this.depth < 0.3) {
                    this.trunkWidth *= 1.1;
                    this.leafRadius *= 1.05;
                }
                
                if (hasBranches) {
                    const branchCount = Math.floor(1 + Math.random() * 3);
                    for (let i = 0; i < branchCount; i++) {
                        // Determine which side the branch comes out on
                        const isRightSide = Math.random() > 0.5;
                        
                        // CORRECTLY POINTING UP
                        let branchAngle;
                        
                        if (isRightSide) {
                            // Right side branches point up and right (-π/4 to -π/2) 
                            branchAngle = -Math.PI/4 - Math.random() * (Math.PI/4);
                        } else {
                            // Left side branches point up and left (5π/4 to 3π/2)
                            branchAngle = (5 * Math.PI)/4 + Math.random() * (Math.PI/4);
                        }
                        
                        // Vary height more naturally along the trunk
                        const heightPosition = 0.3 + Math.random() * 0.6; // 30% to 90% up the trunk
                        
                        this.branches.push({
                            height: this.trunkHeight * heightPosition,
                            length: 30 + Math.random() * 40,
                            angle: branchAngle,
                            thickness: this.trunkWidth * (0.3 + Math.random() * 0.3)
                        });
                    }
                }
            }

            draw() {
                // Apply depth scale
                ctx.save();
                
                // Center on tree position
                ctx.translate(this.x, this.y);
                ctx.scale(this.scale, this.scale);
                
                // Trunk (drawing relative to 0,0)
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.moveTo(-this.trunkWidth / 2, 0);
                ctx.quadraticCurveTo(
                    0, 
                    -this.trunkHeight / 2,
                    0, 
                    -this.trunkHeight
                );
                ctx.quadraticCurveTo(
                    0, 
                    -this.trunkHeight - 10,
                    this.trunkWidth / 2, 
                    -this.trunkHeight
                );
                ctx.lineTo(this.trunkWidth / 2, 0);
                ctx.fill();

                // Branches
                if (this.hasBranches) {
                    this.branches.forEach(branch => {
                        const branchY = -branch.height;
                        
                        ctx.strokeStyle = '#8B4513';
                        ctx.lineWidth = branch.thickness;
                        ctx.beginPath();
                        ctx.moveTo(0, branchY);
                        
                        // Calculate endpoint with correct angle
                        const endX = Math.cos(branch.angle) * branch.length;
                        const endY = branchY + Math.sin(branch.angle) * branch.length;
                        
                        // Draw with slight curve for more natural look
                        ctx.bezierCurveTo(
                            endX * 0.3, branchY + (endY - branchY) * 0.2,
                            endX * 0.7, branchY + (endY - branchY) * 0.7,
                            endX, endY
                        );
                        ctx.stroke();
                        
                        // Small leaf clusters on branch tips
                        ctx.fillStyle = '#2E8B57';
                        ctx.beginPath();
                        ctx.arc(endX, endY, this.leafRadius * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }

                // Leaves - keep original colors but ensure proper rgb format
                const leafX = 0;
                const leafY = -this.trunkHeight - this.leafRadius;
                
                // Draw main leaf cluster
                ctx.fillStyle = timeOfDay < 1 ? 'rgb(34, 139, 34)' : 'rgb(26, 107, 26)';
                ctx.beginPath();
                ctx.arc(leafX, leafY, this.leafRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw additional leaf clusters for volume
                const clusters = 5;
                for (let i = 0; i < clusters; i++) {
                    const angle = (i / clusters) * Math.PI * 2;
                    const offsetDistance = this.leafRadius * 0.6;
                    const offsetX = Math.cos(angle) * offsetDistance;
                    const offsetY = Math.sin(angle) * offsetDistance;
                    
                    ctx.fillStyle = timeOfDay < 1 ? 
                        'rgba(34, 139, 34, 0.8)' : 
                        'rgba(26, 107, 26, 0.8)';
                    
                    ctx.beginPath();
                    ctx.arc(
                        leafX + offsetX, 
                        leafY + offsetY, 
                        this.leafRadius * 0.7, 
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
                
                ctx.restore();
                
                // Reset any lingering alpha values
                ctx.globalAlpha = 1.0;

                // Draw debug health bar if enabled
                if (debugVisuals) {
                    const healthBarWidth = 30;
                    const x = this.x - healthBarWidth / 2;
                    const y = this.y + 5;
                    
                    // Health background
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(x, y, healthBarWidth, 3);
                    
                    // Health bar
                    const healthColor = this.health > 70 ? 'green' : (this.health > 30 ? 'orange' : 'red');
                    ctx.fillStyle = healthColor;
                    ctx.fillRect(x, y, healthBarWidth * (this.health / 100), 3);
                    
                    // Age indicator
                    const ageRatio = this.age / TREE_LIFESPAN;
                    ctx.fillStyle = ageRatio < 0.3 ? 'green' : (ageRatio < 0.7 ? 'yellow' : 'red');
                    ctx.fillRect(x, y + 5, healthBarWidth * ageRatio, 2);
                }
            }

            degrade(deltaTime) {
                // Increment age with slight randomness
                this.age += deltaTime * (0.4 + Math.random() * 0.1);
                
                // Trees with nests are more resistant
                const hasNest = this.nest !== null;
                const degradationMultiplier = hasNest ? 0.5 : 1.2;
                
                // Soften the sudden death at TREE_LIFESPAN
                const lifespanFactor = 1 + Math.min(1.2, Math.max(0, (this.age - TREE_LIFESPAN * 0.9) / (TREE_LIFESPAN * 0.1)));
                
                // Trees degrade with age and can recover with rain
                if (timeOfDay >= 1 && !isRaining) {
                    // Faster degradation at night without rain
                    this.health -= TREE_DEGRADATION_RATE * degradationMultiplier * lifespanFactor * (deltaTime / 1000);
                } else if (isRaining && timeOfDay < 1) {



                } else if (isRaining && timeOfDay < 1) {
    // Trees recover during rain in daytime
    const recoveryRate = hasNest ? 0.025 : 0.0125;
    this.health = Math.min(100, this.health + recoveryRate * (deltaTime / 1000));
} else if (timeOfDay < 1) {



                    
} else if (timeOfDay < 1) {
    // Trees gain a small health boost during the day, more if they have nests
    const sunRecoveryRate = hasNest ? 0.00625 : 0.003;
    this.health = Math.min(100, this.health + sunRecoveryRate * (deltaTime / 1000));
}







// Natural tree recovery during the day
if (timeOfDay < 1 && Math.random() < 0.001) {
    // Random health boost (1-5 points)
    this.health = Math.min(100, this.health + (1 + Math.random() * 4));
    
    // Only show healing sparkle effect when debug visuals are enabled
    if (debugVisuals) {
        addSpecialEffect({
            type: 'sparkle',
            x: this.x,
            y: this.y - this.trunkHeight * 0.5 * this.scale,
            duration: 1000,
            intensity: 0.3
        });
    }
}



                
                // Check if tree should be removed
                if (this.health <= TREE_HEALTH_THRESHOLD || this.age > TREE_LIFESPAN) {
                    debugLog(`Tree at (${this.x}, ${this.y}) has ${this.health <= TREE_HEALTH_THRESHOLD ? 'degraded completely' : 'reached end of lifespan'}.`);
                    
                    // If the tree has a nest, handle the nest and any baby birds
                    if (this.nest) {
                        const nestIndex = nests.indexOf(this.nest);
                        if (nestIndex !== -1) {
                            // Check for baby birds in this nest
                            const babiesInNest = babyBirds.filter(baby => 
                                baby.associatedNest === this.nest
                            );
                            
                            // Make babies fall if tree is removed
                            for (const baby of babiesInNest) {
                                baby.startFalling();
                            }
                            
                            if (this.nest.occupiedBy) {
                                this.nest.occupiedBy.myNest = null;
                                this.nest.occupiedBy = null;
                            }
                            
                            nests.splice(nestIndex, 1);
                        }
                    }
                    return true; // Tree should be removed
                }
                return false;
            }
            
            // Method to create perch positions
            getPerchPositions() {
                const positions = [];
                
                // Add positions on branches
                if (this.hasBranches && this.branches.length > 0) {
                    this.branches.forEach(branch => {
                        const branchY = this.y - branch.height;
                        
                        // Multiple positions along each branch
                        for (let i = 0.3; i <= 0.9; i += 0.2) {
                            const perchX = this.x + Math.cos(branch.angle) * branch.length * i * this.scale;
                            const perchY = branchY + Math.sin(branch.angle) * branch.length * i * this.scale;
                            
                            positions.push({
                                x: perchX,
                                y: perchY,
                                tree: this
                            });
                        }
                    });
                }
                
                // Add positions in the leafy area (top of tree)
                const leafY = this.y - this.trunkHeight * this.scale - this.leafRadius * 0.5 * this.scale;
                
                // Create a circular distribution in the leafy area
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    const distance = this.leafRadius * 0.6 * this.scale;
                    
                    const perchX = this.x + Math.cos(angle) * distance;
                    const perchY = leafY + Math.sin(angle) * distance * 0.5; // Flatten the circle a bit
                    
                    positions.push({
                        x: perchX,
                        y: perchY,
                        tree: this,
                        inLeaves: true
                    });
                }
                
                // Add position at the very top
                positions.push({
                    x: this.x,
                    y: this.y - this.trunkHeight * this.scale - this.leafRadius * this.scale,
                    tree: this,
                    inLeaves: true
                });
                
                return positions;
            }
        }

        function drawTrees(deltaTime) {
            // Sort trees by depth for proper rendering
            const sortedTrees = [...trees].sort((a, b) => b.depth - a.depth);
            
            for (let i = sortedTrees.length - 1; i >= 0; i--) {
                const tree = sortedTrees[i];
                const treeIndex = trees.indexOf(tree);
                const shouldRemove = tree.degrade(deltaTime);
                if (shouldRemove) {
                    trees.splice(treeIndex, 1);
                } else {
                    tree.draw();
                }
            }
        }

        // More dynamic tree regrowth
        function regrowTrees() {
            // Allow more trees, remove unhealthy ones if above max limit
            if (trees.length > MAX_TREES) {
                // Find the least healthy tree to remove
                let leastHealthyIndex = -1;
                let lowestHealth = 101; // Higher than maximum health
                
                for (let i = 0; i < trees.length; i++) {
                    if (trees[i].health < lowestHealth) {
                        lowestHealth = trees[i].health;
                        leastHealthyIndex = i;
                    }
                }
                
                // Remove it if health is below threshold
                if (leastHealthyIndex !== -1 && lowestHealth < 40) {
                    debugLog(`Removing unhealthy tree at index ${leastHealthyIndex} with health ${lowestHealth}`);
                    trees.splice(leastHealthyIndex, 1);
                }
            }
            
            // Stagger new tree growth
            if (trees.length < MAX_TREES && Math.random() < 0.7) { // 70% chance to actually grow a tree
                let validPosition = false;
                let attempts = 0;

                while (!validPosition && attempts < 50) {
                    attempts++;
                    const trunkHeight = Math.random() < 0.1 && tallTreeCount < 3 ?
                        150 + Math.random() * 50 :
                        80 + Math.random() * 70;

                    // Better positioning to avoid edges and spread trees more naturally
                    const margin = 100; 
                    const x = margin + Math.random() * (canvas.width - margin * 2);
                    const hasBranches = Math.random() < 0.8; // More trees have branches

                    // Check if position is valid (not too close to other trees)
                    validPosition = trees.every(tree =>
                        Math.abs(tree.x - x) > 100
                    );

                    if (validPosition) {
                        // Occasionally grow much taller trees
                        const extraTall = Math.random() < 0.25; // 25% chance for extra tall tree
                        
                        if (trunkHeight > 150 || extraTall) tallTreeCount++;
                        
                        // Allow for taller trees overall
                        const finalTrunkHeight = extraTall ? 
                        200 + Math.random() * 100 : // Even taller trees: 200-300px
                        trunkHeight;                // Normal trees
                        
                        // Thicker trunks for taller trees
                        const trunkWidth = extraTall ?
                            20 + Math.random() * 15 :  // Thicker trunks for tall trees
                            15 + Math.random() * 10;   // Normal trunks

                        // Larger leaf radius for taller trees
                        const leafRadius = extraTall ?
                            60 + Math.random() * 30 :  // Larger leaf clusters for tall trees
                            40 + Math.random() * 20;   // Normal leaf clusters
                        
                        const newTree = new Tree(
                            x, 
                            trunkWidth, 
                            finalTrunkHeight, 
                            leafRadius, 
                            hasBranches
                        );
                        // Stagger tree ages
                        newTree.age = Math.random() * (TREE_LIFESPAN * 0.5);
                        trees.push(newTree);
                        debugLog(`New tree grown at (${x}). Height: ${finalTrunkHeight}`);
                    }
                }
            }
        }

        // Ensure we always have at least a minimum number of trees
        function ensureMinimumTrees() {
            if (trees.length < MIN_TREES) {
                debugLog("Emergency tree regrowth - ensuring minimum trees exist");
                
                // Determine how many trees to add
                const treesToAdd = MIN_TREES - trees.length;
                
                // Create trees spaced evenly across the screen
                for (let i = 0; i < treesToAdd; i++) {
                    const segment = canvas.width / (treesToAdd + 1);
                    const x = segment * (i + 1) + (Math.random() - 0.5) * segment * 0.5;
                    
                    const newTree = new Tree(
                        x,
                        20,
                        120 + Math.random() * 40,
                        50,
                        true // Always include branches on emergency trees
                    );
                    trees.push(newTree);
                }
            }
        }

        function checkEcosystemHealth() {
            ensureMinimumTrees();
            
            // Check for bird population - more aggressive spawning
            if (birds.length + babyBirds.length < 3) {
                spawnBird();
            }
            
            // Add branches to existing trees periodically
            if (dayNightCycleCount % 3 === 0 && trees.length > 0) {
                // Pick a random tree to add a branch to
                const randomTree = trees[Math.floor(Math.random() * trees.length)];
                if (randomTree.branches.length < 6) { // Limit maximum branches per tree
                    addBranchToTree(randomTree);
                }
            }
        }

        // V26: Enhanced food placement with no glow effect
        function drawFood(deltaTime) {
            // Enforce maximum food limit
            if (foodItems.length > MAX_FOOD) {
                // Sort by timer (oldest first)
                foodItems.sort((a, b) => b.timer - a.timer);
                // Keep the newest ones
                foodItems.splice(MAX_FOOD);
            }
            
            for (let i = foodItems.length - 1; i >= 0; i--) {
                const food = foodItems[i];
                food.timer += deltaTime;
                
                // Add decay to food items over time
                if (isRaining) {
                    food.timer += deltaTime; // Food degrades faster in rain
                }
                
                // Food disappears after a long time
                if (food.timer > 270000) { // Adjusted
                    foodItems.splice(i, 1);
                    continue;
                }
                
                // Ensure food freshness never goes below 0
                const freshness = Math.max(0, 1 - (food.timer / 90000));
                // Ensure baseSize never goes below 2
                const baseSize = Math.max(2, 3 + freshness * 2);
                
                if (food.type === 'seed') {
                    ctx.fillStyle = '#F5DEB3';
                    ctx.beginPath();
                    ctx.ellipse(food.x, food.y, baseSize, baseSize * 0.7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Darker center to the seeds
                    ctx.fillStyle = '#E6C78F';
                    ctx.beginPath();
                    ctx.arc(food.x, food.y, baseSize * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (food.type === 'berry') {
                    ctx.fillStyle = '#8B0000';
                    ctx.beginPath();
                    ctx.arc(food.x, food.y, baseSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Highlight on berries
                    ctx.fillStyle = 'rgba(255, 200, 200, 0.6)';
                    ctx.beginPath();
                    ctx.arc(food.x - baseSize * 0.3, food.y - baseSize * 0.3, baseSize * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (food.type === 'crumb') {
                    ctx.fillStyle = '#D2B48C';
                    
                    // Draw irregular crumb shape
                    ctx.beginPath();
                    ctx.moveTo(food.x, food.y - baseSize * 0.8);
                    ctx.lineTo(food.x + baseSize * 0.7, food.y - baseSize * 0.2);
                    ctx.lineTo(food.x + baseSize * 0.5, food.y + baseSize * 0.5);
                    ctx.lineTo(food.x - baseSize * 0.4, food.y + baseSize * 0.7);
                    ctx.lineTo(food.x - baseSize * 0.7, food.y);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }

        // Spawn food more naturally
        function scatterFood(x, y, count = 5) {
            const types = ['seed', 'berry', 'crumb'];
            const groundY = canvas.height * GROUND_HEIGHT_RATIO;
            
            // If no coordinates specified, scatter in a random area
            if (x === undefined || y === undefined) {
                x = Math.random() * canvas.width;
                y = groundY;
            }
            
            // Ensure y is at or below ground level
            y = Math.max(y, groundY);
            
            // More natural distribution - cluster with some spread
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 50 + 10; // 10-60px from center
                
                const foodX = x + Math.cos(angle) * distance;
                const foodY = y + Math.sin(angle) * Math.min(distance * 0.3, 20); // Flatter distribution
                
                // Make sure food stays on screen
                if (foodX > 0 && foodX < canvas.width) {
                    foodItems.push({
                        x: foodX,
                        y: foodY,
                        type: types[Math.floor(Math.random() * types.length)],
                        timer: 0
                    });
                }
            }
        }

        // V26: Bird class with updated wing outlines and more perching behavior
        class Bird {
            constructor(isWild = false, birdTypeOverride = null, startX = null, startY = null) {
        this.birdType = birdTypeOverride || BIRD_TYPES[Math.floor(Math.random() * BIRD_TYPES.length)];
        this.x = startX !== null ? startX : Math.random() * canvas.width;
        this.y = startY !== null ? startY : canvas.height * 0.4;
        this.direction = Math.random() < 0.5 ? -1 : 1;
        this.velocity = { x: 0, y: 0 };
        this.acceleration = { x: 0, y: 0 };
        this.baseSpeed = 0.8 * this.birdType.speedMultiplier;
        this.isWild = isWild; // Wild birds come and go, don't build nests
                this.hunger = Math.random() * 200;
                this.state = BIRD_STATES.FLYING;
                this.stateTimer = 0;
                this.path = [];
                this.pathIndex = 0;
                this.target = null;
                this.pecking = false;
                this.peckTimer = 0;

                // Add depth for ground variance (0-50px deeper in grass for foreground birds)
                this.groundDepth = Math.random() * 50; // 0-50px variance
                this.wingFlap = 0;
                this.isFlying = false;
                this.perchTarget = null;
                this.lastPoopTime = Date.now() - (Math.random() * BIRD_POOP_DELAY);
                this.materialsHeld = 0;
                this.hasSpecialTwig = false;
                this.myNest = null;
                this.lastNestFindAttempt = 0;
                this.nestFindAttempts = 0;
                this.buildingBirdhouse = null;
                this.lastNestCheckTime = 0; // For nest maintenance system
                
                // Add directionChangeCooldown property
                this.directionChangeCooldown = 0;

                // === NEW BEHAVIOR PROPERTIES ===
                // Unique ID for tracking
                this.id = Math.random().toString(36).substr(2, 9);

                // Flocking and social behavior
                this.flockId = null; // Assigned when bird joins a flock
                this.isSentinel = false;
                this.lastSentinelTime = 0;

                // Territorial and aggression
                this.aggression = 0.3 + Math.random() * 0.7; // 0.3-1.0 aggression level
                this.territorialRange = 80 + this.aggression * 70; // 80-150px territory
                this.lastTerritorialDisplay = 0;
                this.defeatedRecently = false;
                this.defeatTimer = 0;

                // Food memory (individual)
                this.foodMemory = []; // {x, y, timestamp}
                this.lastFoodCall = 0;

                // Chirping behavior
                this.lastChirp = 0;
                this.chirpCooldown = 0;
                this.lastContactCall = 0;

                // Ground pecking
                this.isOnGround = false;
                this.peckingInterval = PECKING_INTERVAL_SOLO;
                this.lastPeckTime = 0;
                this.peckAnimationPhase = 0;

                // Mobbing behavior
                this.isMobbing = false;
                this.mobbingTarget = null;
                this.lastMobbingDive = 0;

                // Danger awareness
                this.lastDangerEncounter = 0;
                this.fearLevel = 0; // Increases with danger, decreases over time

                // In the Bird class update method
                if (this.y > canvas.height * GROUND_HEIGHT_RATIO) {
                    this.y = canvas.height * GROUND_HEIGHT_RATIO;
                    this.velocity.y = 0; // Stop when hitting the ground
                }
            }

            applyForce(force) {
                // V26: Add force limiting to prevent extreme accelerations
                const maxForce = 0.03;
                this.acceleration.x += Math.min(maxForce, Math.max(-maxForce, force.x));
                this.acceleration.y += Math.min(maxForce, Math.max(-maxForce, force.y));
            }

            // V26: Improved path generation for smoother, more natural movement
            generatePath(targetX, targetY) {
                // Clear existing path
                this.path = [];
                this.pathIndex = 0;
                
                // Keep target coordinates within visible bounds with more margin
                targetX = Math.max(100, Math.min(canvas.width - 100, targetX));
                targetY = Math.max(80, Math.min(canvas.height * GROUND_HEIGHT_RATIO - 50, targetY));
                
                // Check for problematic target locations with larger buffer
                const isTargetInProblemArea = problemAreas.some(area => 
                    Math.abs(targetX - area.x) < (area.radius + 20) // Added 20px buffer
                );
                
                // If target is in problem area, adjust it more aggressively
                if (isTargetInProblemArea) {
                    debugLog(`Adjusting target away from problem area`);
                    targetX = findSafeX(problemAreas);
                }
                
                // Special handling for birds starting off-screen
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    // Bird is off-screen, create a natural entry path
                    this.path.push({ x: this.x, y: this.y }); // Start at current position
                    
                    // Add entry point at screen edge with smoother entry
                    let entryX = this.x < 0 ? 80 : (this.x > canvas.width ? canvas.width - 80 : this.x); // Deeper entry
                    let entryY = this.y < 0 ? 80 : (this.y > canvas.height ? canvas.height * 0.5 : this.y); // Deeper entry
                    this.path.push({ x: entryX, y: entryY });
                    
                    // Add multiple waypoints for a smooth arc
                    const controlPoints = Math.min(3, 1 + Math.floor(distance(entryX, entryY, targetX, targetY) / 200));
                    
                    for (let i = 0; i < controlPoints; i++) {
                        const progress = (i + 1) / (controlPoints + 1);
                        const arcHeight = Math.sin(progress * Math.PI) * 60; // Higher arc for smoother flight
                        
                        const wayX = entryX + (targetX - entryX) * progress;
                        const wayY = entryY + (targetY - entryY) * progress - arcHeight;
                        
                        this.path.push({ x: wayX, y: wayY });
                    }
                    
                    // Add final destination
                    this.path.push({ x: targetX, y: targetY });
                } else {
                    // Bird is on-screen - use more natural flight paths with curves
                    // Start path at current position
                    this.path.push({ x: this.x, y: this.y });
                    
                    // For longer paths, add intermediate points for more natural movement
                    const dist = distance(this.x, this.y, targetX, targetY);
                    
                    if (dist > 100) { // Lower threshold for more frequent waypoints
                        // Add proportional waypoints based on distance
                        const controlPoints = Math.min(4, 1 + Math.floor(dist / 150)); // More waypoints
                        
                        for (let i = 0; i < controlPoints; i++) {
                            const progress = (i + 1) / (controlPoints + 1);
                            
                            // Distance-based arc height for natural flight
                            const arcHeight = Math.sin(progress * Math.PI) * Math.min(60, dist * 0.2);
                            
                            // Avoid creating waypoints in problem areas
                            let wayX;
                            let attempts = 0;
                            
                            do {
                                // Small random offset for more natural path
                                const randomOffset = (Math.random() - 0.5) * (dist * 0.1);
                                wayX = this.x + (targetX - this.x) * progress + randomOffset;
                                attempts++;
                            } while (
                                attempts < 5 && 
                                problemAreas.some(area => Math.abs(wayX - area.x) < area.radius)
                            );
                            
                            // Calculate y position with arc and random variation
                            const baseY = this.y + (targetY - this.y) * progress;
                            const wayY = Math.max(50, Math.min(baseY - arcHeight, canvas.height * 0.7));
                            
                            this.path.push({ x: wayX, y: wayY });
                        }
                    }
                    
                    // Add target as final waypoint
                    this.path.push({ x: targetX, y: targetY });
                }
                
                // Set bird to face in the correct direction
                this.direction = targetX > this.x ? 1 : -1;
            }

            // V26: Improved perch finding with more frequent perching
            findPerch(prioritizeShelter = false) {
                if (trees.length === 0) {
                    // No trees to perch on
                    this.state = BIRD_STATES.FLYING;
                    this.stateTimer = 0;
                    return;
                }
                
                // V26: Reduced chance to skip perching for more perching overall
                if (Math.random() < 0.03) { // 8% chance to skip perching (reduced from 15%)
                    this.state = BIRD_STATES.FLYING;
                    this.stateTimer = 0;
                    
                    // Fly around the sky instead
                    const targetX = 100 + Math.random() * (canvas.width - 200);
                    const targetY = 50 + Math.random() * (canvas.height * 0.3);
                    this.generatePath(targetX, targetY);
                    return;
                }
                
                // Collect all possible perch positions
                let allPerchPositions = [];

                trees.forEach(tree => {
                    const positions = tree.getPerchPositions();
                    allPerchPositions = allPerchPositions.concat(positions);
                });

                // Add clock number positions as perch spots when clock is enabled
                if (clockEnabled && window.clockNumberPositions && window.clockNumberPositions.length > 0) {
                    window.clockNumberPositions.forEach(clockSpot => {
                        // Add each clock number as a perch position
                        allPerchPositions.push({
                            x: clockSpot.x + (clockSpot.width / 2), // center of number
                            y: clockSpot.y,
                            inLeaves: false,
                            tree: null, // no tree, it's a clock number
                            isClock: true // mark as clock perch
                        });
                    });
                }

                // Safety check - if no perch positions, fly
                if (allPerchPositions.length === 0) {
                    this.state = BIRD_STATES.FLYING;
                    this.stateTimer = 0;
                    this.generatePath(
                        Math.random() * canvas.width, 
                        100 + Math.random() * (canvas.height * 0.3)
                    );
                    return;
                }
                
                // Filter and sort perches by preference
                let validPerches = allPerchPositions.filter(perch => {
                    // Check if there's a bird already perched here
                    return !birds.some(bird => 
                        bird !== this && 
                        bird.state === BIRD_STATES.PERCHED &&
                        distance(bird.x, bird.y, perch.x, perch.y) < 20
                    );
                });
                
                // Filter out perches in problem areas
                const problemXCoordinates = [100, 928, 888, 904, 0, canvas.width, 882, 877, 864, 873, 900, 866, 887, 859];
                const safeMargin = 60;
                
                validPerches = validPerches.filter(perch => 
                    !problemXCoordinates.some(x => Math.abs(perch.x - x) < safeMargin)
                );
                
                // V26: Reduced random rejection for more consistent perching
                validPerches = validPerches.filter(() => Math.random() < 0.85); // 15% chance to reject any perch (changed from 30%)
                
                // Safety check - if no valid perches after filtering, fly
                if (validPerches.length === 0) {
                    this.state = BIRD_STATES.FLYING;
                    this.stateTimer = 0;
                    this.generatePath(
                        100 + Math.random() * (canvas.width - 200), 
                        100 + Math.random() * (canvas.height * 0.3)
                    );
                    return;
                }
                
                // Sort perches with more balanced preferences (less tree dominance)
                validPerches.sort((a, b) => {
                    let scoreA = 0;
                    let scoreB = 0;
                    
                    // Prefer perches in leaves during rain if seeking shelter
                    if (prioritizeShelter && isRaining) {
                        if (a.inLeaves) scoreA += 100;
                        if (b.inLeaves) scoreB += 100;
                    }
                    
                    // Reduce the weight of proximity to balance attraction
                    const distA = distance(this.x, this.y, a.x, a.y);
                    const distB = distance(this.x, this.y, b.x, b.y);
                    
                    scoreA += (1000 - distA) * 0.05; // Reduced from 0.1
                    scoreB += (1000 - distB) * 0.05; // Reduced from 0.1
                    
                    // Strongly discourage perching on trees that have many birds already
                    const birdsInTreeA = birds.filter(bird => 
                        bird !== this && bird.perchTarget && bird.perchTarget.tree === a.tree
                    ).length;
                    
                    const birdsInTreeB = birds.filter(bird => 
                        bird !== this && bird.perchTarget && bird.perchTarget.tree === b.tree
                    ).length;
                    
                    scoreA -= birdsInTreeA * 30; // Stronger penalty for crowded trees
                    scoreB -= birdsInTreeB * 30;
                    
                    // Prefer reasonable distances
                    if (distA > 300) scoreA -= 150;
                    if (distB > 300) scoreB -= 150;
                    
                    // Prefer higher perches, but with less weight
                    scoreA += (canvas.height - a.y) * 0.02; // Reduced from 0.05
                    scoreB += (canvas.height - b.y) * 0.02; // Reduced from 0.05
                    
                    // Add randomness to perch selection
                    scoreA += Math.random() * 50;
                    scoreB += Math.random() * 50;
                    
                    return scoreB - scoreA;
                });
                
                // Choose perch with some randomness
                const topPerchCount = Math.min(validPerches.length, 5); // Increased choice range
                const selectedIndex = Math.floor(Math.random() * topPerchCount);
                const targetPerch = validPerches[selectedIndex];
                
                // Set perch target and state
                this.perchTarget = targetPerch;
                this.state = BIRD_STATES.PERCHED;
                this.stateTimer = 0;
                
                // Generate a more natural arc path to approach the perch
                const startX = this.x;
                const startY = this.y;
                const midX = (startX + targetPerch.x) / 2;
                const midY = Math.min(startY, targetPerch.y) - 30;
                
                // Create a more natural arc path
                this.path = [
                    { x: startX, y: startY },
                    { x: startX + (midX - startX) * 0.3, y: startY + (midY - startY) * 0.3 },
                    { x: midX, y: midY },
                    { x: midX + (targetPerch.x - midX) * 0.7, y: midY + (targetPerch.y - midY) * 0.7 },
                    { x: targetPerch.x, y: targetPerch.y }
                ];
                
                this.pathIndex = 0;
            }

            findFoodSource() {
                // Try to find food or worms
                let foundFood = false;

                // Expanded vision radius when hungry
                const visionRadius = this.hunger > HUNGER_CRITICAL_THRESHOLD ?
                    BIRD_FOOD_VISION_RADIUS * 2 : BIRD_FOOD_VISION_RADIUS * 1.5;

                // NEW: Check for large food piles (ground flocking behavior)
                // Count food items in clusters
                const foodClusters = [];
                const clusterRadius = 80;

                for (const food of foodItems) {
                    let addedToCluster = false;
                    for (const cluster of foodClusters) {
                        if (distance(food.x, food.y, cluster.x, cluster.y) < clusterRadius) {
                            cluster.count++;
                            cluster.x = (cluster.x * (cluster.count - 1) + food.x) / cluster.count;
                            cluster.y = (cluster.y * (cluster.count - 1) + food.y) / cluster.count;
                            addedToCluster = true;
                            break;
                        }
                    }
                    if (!addedToCluster) {
                        foodClusters.push({ x: food.x, y: food.y, count: 1 });
                    }
                }

                // If there's a large food pile (5+ items), go to ground and flock
                for (const cluster of foodClusters) {
                    if (cluster.count >= 5 && distance(this.x, this.y, cluster.x, cluster.y) < visionRadius * 1.5) {
                        // Direct to ground near food cluster - deeper into grass for more realistic ground behavior
                        const groundY = canvas.height * GROUND_HEIGHT_RATIO + 40; // Increased from +20 to +40
                        this.path = [
                            { x: this.x, y: this.y },
                            { x: cluster.x + (Math.random() - 0.5) * 40, y: groundY }
                        ];
                        this.pathIndex = 0;
                        this.intendToHop = true;
                        this.hopData = null;
                        debugLog(`Bird joining ground flock at food pile (${cluster.x}, ${cluster.y}) with ${cluster.count} items`);
                        return;
                    }
                }

                // Check food memory first
                const now = Date.now();
                this.foodMemory = this.foodMemory.filter(f => now - f.timestamp < FOOD_KNOWLEDGE_DURATION);

                if (this.foodMemory.length > 0 && Math.random() < 0.4) {
                    const memFood = this.foodMemory[0];
                    // Check if danger zone
                    if (!this.isDangerZone(memFood.x, memFood.y)) {
                        this.target = {
                            type: 'remembered',
                            x: memFood.x,
                            y: memFood.y
                        };
                        this.state = BIRD_STATES.HUNTING;
                        this.stateTimer = 0;
                        debugLog(`Bird using food memory`);
                        return;
                    }
                }

                // Target worms first (more nutritious)
                for (const worm of worms) {
                    if (distance(this.x, this.y, worm.x, worm.y) < visionRadius &&
                        !this.isDangerZone(worm.x, worm.y)) {
                        this.target = {
                            type: 'worm',
                            worm: worm,
                            x: worm.x,
                            y: worm.y
                        };
                        this.state = BIRD_STATES.HUNTING;
                        this.stateTimer = 0;
                        foundFood = true;

                        // Add to memory
                        this.foodMemory.push({x: worm.x, y: worm.y, timestamp: now});

                        // Make food call
                        if (Math.random() < 0.3) {
                            this.makeFoodCall(worm.x, worm.y);
                        }

                        debugLog(`Bird found worm at (${worm.x}, ${worm.y})`);
                        break;
                    }
                }

                // If no worms found, try to find food items
                if (!foundFood) {
                    for (const food of foodItems) {
                        if (distance(this.x, this.y, food.x, food.y) < visionRadius &&
                            !this.isDangerZone(food.x, food.y)) {
                            this.target = {
                                type: 'food',
                                food: food,
                                x: food.x,
                                y: food.y
                            };
                            this.state = BIRD_STATES.HUNTING;
                            this.stateTimer = 0;
                            foundFood = true;

                            // Add to memory
                            this.foodMemory.push({x: food.x, y: food.y, timestamp: now});

                            // Make food call
                            if (Math.random() < 0.3) {
                                this.makeFoodCall(food.x, food.y);
                            }

                            debugLog(`Bird found food at (${food.x}, ${food.y})`);
                            break;
                        }
                    }
                }
                
                // If no food found, fly to likely food areas
                if (!foundFood) {
                    // Generate path to a likely food location
                    const groundY = canvas.height * GROUND_HEIGHT_RATIO - 10;
                    
                    // Birds prioritize different areas based on hunger level
                    let targetX;
                    
                    if (this.hunger > HUNGER_CRITICAL_THRESHOLD) {
                        // Very hungry - check areas with recent food sightings
                        if (foodItems.length > 0) {
                            // Go to where food actually is
                            const randomFood = foodItems[Math.floor(Math.random() * foodItems.length)];
                            targetX = randomFood.x + (Math.random() - 0.5) * 30;
                        } else if (trees.length > 0) {
                            const randomTree = trees[Math.floor(Math.random() * trees.length)];
                            targetX = randomTree.x + (Math.random() - 0.5) * 50;
                        } else {
                            targetX = Math.random() * canvas.width;
                        }
                    } else {
                        // Less hungry - more random search
                        targetX = Math.random() * canvas.width;
                    }
                    
                    this.generatePath(targetX, groundY);
                    this.state = BIRD_STATES.FLYING;
                    this.stateTimer = 0;
                    debugLog(`Bird searching for food around ${targetX}`);
                }
            }

            findTwigs() {
                // Find twigs to build nest
                let foundTwig = false;
                
                // Increased vision radius
                const twigsVisionRadius = BIRD_VISION_RADIUS * 2; // Doubled vision for twigs
                
                for (const twig of twigs) {
                    if (distance(this.x, this.y, twig.x, twig.y) < twigsVisionRadius) {
                        this.target = {
                            type: 'twig',
                            twig: twig,
                            x: twig.x,
                            y: twig.y
                        };
                        this.state = BIRD_STATES.COLLECTING;
                        this.stateTimer = 0;
                        foundTwig = true;
                        debugLog(`Bird found twig at (${twig.x}, ${twig.y})`);
                        break;
                    }
                }
                
                // If no twigs found, fly to likely twig areas
                if (!foundTwig) {
                    const groundY = canvas.height * GROUND_HEIGHT_RATIO - 10;
                    let targetX;
                    
                    // Check if there are trees (likely source of twigs)
                    if (trees.length > 0) {
                        // Pick tree deliberately instead of randomly
                        // Sort trees by health to pick healthier trees first
                        const sortedTrees = [...trees].sort((a, b) => b.health - a.health);
                        const tree = sortedTrees[0]; // Pick healthiest tree
                        targetX = tree.x + (Math.random() - 0.5) * 30;
                    } else {
                        targetX = Math.random() * canvas.width;
                    }
                    
                    // More clear destination
                    this.generatePath(targetX, groundY);
                    this.state = BIRD_STATES.FLYING;
                    this.stateTimer = 0;
                    debugLog(`Bird looking for twigs near healthiest tree`);
                }
            }

            // V26: Updated nest finding & maintenance for deterioration system
            findOrCreateNest() {
                // Log attempt for debugging
                debugLog(`Bird attempting to find or create nest`);
                
                // Reset counter if it's been a long time since last attempt
                if (Date.now() - this.lastNestFindAttempt > 60000) {
                    this.nestFindAttempts = 0;
                }
                
                this.nestFindAttempts++;
                this.lastNestFindAttempt = Date.now();
                
                // First check if current nest needs maintenance
                if (this.myNest && this.myNest.needsMaintenance) {
                    this.state = BIRD_STATES.BUILDING; // Reuse building state for maintenance
                    this.stateTimer = 0;
                    debugLog(`Bird prioritizing nest maintenance`);
                    return;
                }
                
                // Check if current nest has collapsed and needs rebuilding
                if (this.myNest && !this.myNest.isComplete) {
                    this.state = BIRD_STATES.BUILDING; // Rebuild nest
                    this.stateTimer = 0;
                    debugLog(`Bird rebuilding collapsed nest`);
                    return;
                }
                
                // Try to find existing incomplete nest
                for (const nest of nests) {
                    if (!nest.occupiedBy && !nest.isComplete) {
                        this.myNest = nest;
                        nest.occupiedBy = this;
                        this.state = BIRD_STATES.BUILDING;
                        this.stateTimer = 0;
                        debugLog(`Bird found unoccupied nest at (${nest.x}, ${nest.y})`);
                        return;
                    }
                }
                
                // If no existing suitable nest, create a new one with less restrictions
                if (trees.length > 0 && nests.length < (trees.length * 0.9)) { // Increased from 0.8
                    // Find a suitable tree with more relaxed criteria
                    const potentialTrees = trees.filter(tree => 
                        !tree.nest && tree.health > 30 // Reduced from 50
                    );
                    
                    if (potentialTrees.length > 0) {
                        // Sort trees by health to pick healthier trees first
                        potentialTrees.sort((a, b) => b.health - a.health);
                        
                        // Pick one of the healthiest trees
                        const treeIndex = Math.floor(Math.random() * Math.min(3, potentialTrees.length));
                        const tree = potentialTrees[treeIndex];
                        
                        // Create a new nest with very clear logging
                        const nestX = tree.x + (Math.random() * 20 - 10) * tree.scale;
                        const nestY = tree.y - tree.trunkHeight * 0.8 * tree.scale;
                        
                        const newNest = new Nest(tree, nestX, nestY);
                        nests.push(newNest);
                        tree.nest = newNest;
                        
                        this.myNest = newNest;
                        newNest.occupiedBy = this;
                        
                        this.state = BIRD_STATES.BUILDING;
                        this.stateTimer = 0;
                        
                        debugLog(`Bird created new nest at (${nestX}, ${nestY}) in tree at ${tree.x}`);
                        return;
                    }
                }
                
                // Reset nest find attempts to try again immediately if failed
                if (this.nestFindAttempts > MAX_NEST_FIND_ATTEMPTS) {
                    this.nestFindAttempts = 0;
                    debugLog(`Bird resetting nest find attempts to try again`);
                }
                
                // If we can't create a nest, go back to flying but don't give up
                this.state = BIRD_STATES.FLYING;
                this.stateTimer = 0;
                
                // Rather than find a perch, look for another twig
                this.findTwigs();
            }


            findOrCreateBirdhouse() {
                 // Only non-wild birds build birdhouses AND only after at least 10 days have passed
    if (this.isWild || dayNightCycleCount < 10) return;
                
                // Check if there's already a birdhouse being built
                const incompleteBirdhouse = birdhouses.find(bh => !bh.isComplete);
                
                if (incompleteBirdhouse) {
                    // Join existing birdhouse construction
                    this.buildingBirdhouse = incompleteBirdhouse;
                    this.state = BIRD_STATES.BUILDING_BIRDHOUSE;
                    this.stateTimer = 0;
                    debugLog(`Bird joining birdhouse construction at (${incompleteBirdhouse.x})`);
                    return;
                }
                

                
                // Find a spot for a new birdhouse
                const validSpaces = [];
                const minDistance = 100; // Minimum distance from other birdhouses
                
                // Find valid placement spots
                for (let x = 100; x < canvas.width - 100; x += 50) {
                    let valid = true;
                    
                    // Check if too close to other birdhouses
                    for (const birdhouse of birdhouses) {
                        if (Math.abs(birdhouse.x - x) < minDistance) {
                            valid = false;
                            break;
                        }
                    }
                    
                    if (valid) validSpaces.push(x);
                }
                
                // Place birdhouse if valid space found
                if (validSpaces.length > 0 && birdhouses.length < 3) { // Limit to 3 birdhouses
                    const x = validSpaces[Math.floor(Math.random() * validSpaces.length)];
                    const y = canvas.height * GROUND_HEIGHT_RATIO;
                    
                    const newBirdhouse = new Birdhouse(x, y);
                    // Important: Don't set isComplete to true so birds can build it
                    birdhouses.push(newBirdhouse);
                    
                    this.buildingBirdhouse = newBirdhouse;
                    this.state = BIRD_STATES.BUILDING_BIRDHOUSE;
                    this.stateTimer = 0;
                    
                    debugLog(`Bird started new birdhouse at (${x})`);
                }


                
            }

            // V26: Nest condition checking helper
            checkNestCondition() {
                if (!this.isWild && this.myNest) {
                    if (this.myNest.needsMaintenance) {
                        // Find twigs for repairs if needed
                        if (this.materialsHeld === 0) {
                            this.findTwigs();
                            debugLog(`Bird looking for materials to repair nest`);
                        } else {
                            // Go to nest with materials
                            this.state = BIRD_STATES.BUILDING;
                            this.stateTimer = 0;
                            debugLog(`Bird has materials to repair nest`);
                        }
                        return true; // Nest needs attention
                    } else if (!this.myNest.isComplete) {
                        // Nest collapsed - needs rebuilding
                        if (this.materialsHeld === 0) {
                            this.findTwigs();
                            debugLog(`Bird looking for materials to rebuild collapsed nest`);
                        } else {
                            this.state = BIRD_STATES.BUILDING;
                            this.stateTimer = 0;
                            debugLog(`Bird has materials to rebuild collapsed nest`);
                        }
                        return true; // Nest needs attention
                    }
                }
                return false; // Nest doesn't need attention
            }


            findBirdhouse() {
    // Skip if wild bird
    if (this.isWild) return false;
    
    // Find available birdhouses
    const availableBirdhouses = birdhouses.filter(bh => 
        bh.isComplete && bh.canAcceptOccupant()
    );
    
    if (availableBirdhouses.length === 0) {
        return false; // No available birdhouses
    }
    
    // Choose closest birdhouse
    let closestBirdhouse = null;
    let minDistance = Infinity;
    
    for (const birdhouse of availableBirdhouses) {
        const dist = distance(this.x, this.y, birdhouse.x, birdhouse.y);
        if (dist < minDistance) {
            minDistance = dist;
            closestBirdhouse = birdhouse;
        }
    }
    
    if (closestBirdhouse) {
        // Generate path to birdhouse
        this.generatePath(
            closestBirdhouse.x, 
            closestBirdhouse.y - 20 // Position above the birdhouse
        );
        
        // Set state to flying toward birdhouse
        this.state = BIRD_STATES.FLYING;
        this.stateTimer = 0;
        
        // Remember target birdhouse
        this.targetBirdhouse = closestBirdhouse;
        debugLog(`Bird heading to birdhouse at (${closestBirdhouse.x})`);
        return true;
    }
    
    return false;
}

            findPuddle() {
                // Look for puddles or ponds to bathe/drink from
                if (puddles.length === 0 && ponds.length === 0) {
                    // No water available
                    this.state = BIRD_STATES.FLYING;
                    this.stateTimer = 0;

                    // Find a perch instead
                    this.findPerch();
                    return;
                }



                // Find the nearest puddle or pond
                let closestWater = null;
                let closestDist = Infinity;
                let isPond = false;

                for (const puddle of puddles) {
                    const dist = distance(this.x, this.y, puddle.x, puddle.y);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestWater = puddle;
                        isPond = false;
                    }
                }

                // Also check ponds
                for (const pond of ponds) {
                    const dist = distance(this.x, this.y, pond.x, pond.y);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestWater = pond;
                        isPond = true;
                    }
                }

                if (closestWater) {
                    // Go to water source
                    this.generatePath(closestWater.x, closestWater.y);
                    this.state = BIRD_STATES.BATHING;
                    this.stateTimer = 0;
                    this.drinkingFromPond = isPond; // Track if at pond
                    debugLog(`Bird going to ${isPond ? 'drink from pond' : 'bathe in puddle'} at (${closestWater.x}, ${closestWater.y})`);
                } else {
                    // Fallback - find a perch
                    this.findPerch();
                }
            }


            // Add this method to the Bird class, right after findPuddle and before flee methods

            findBabyBirds() {
                // Skip if no babies or if this is a wild bird
                if (babyBirds.length === 0 || this.isWild) {
                    this.state = BIRD_STATES.FLYING;
                    this.stateTimer = 0;
                    return;
                }
                
               // Prioritize babies in this bird's own nest
               let targetBaby = null;
               let closestDist = Infinity;

               // First check if bird has its own nest with babies
               if (this.myNest) {
                   for (const baby of babyBirds) {
                       // Check if baby is in or near bird's nest
                       if (baby.associatedNest === this.myNest || 
                           distance(baby.x, baby.y, this.myNest.x, this.myNest.y) < 30) {
                           // Prioritize hungry babies
                           const dist = distance(this.x, this.y, baby.x, baby.y);
                           const hungerFactor = baby.timeSinceLastMeal * 5; // Increased from 3 for own nest babies
                           const weightedDist = dist - hungerFactor;
                           
                           if (weightedDist < closestDist) {
                               closestDist = weightedDist;
                               targetBaby = baby;
                           }
                       }
                   }
               }
                
                // If no baby found in own nest, look for any baby
                if (!targetBaby) {
                    for (const baby of babyBirds) {
                        const dist = distance(this.x, this.y, baby.x, baby.y);
                        // Factor in how long since last feeding to prioritize hungrier babies
                        const hungerFactor = baby.timeSinceLastMeal * 2;
                        const weightedDist = dist - hungerFactor;
                        
                        if (weightedDist < closestDist && dist < BIRD_VISION_RADIUS * 1.5) {
                            closestDist = weightedDist;
                            targetBaby = baby;
                        }
                    }
                }
                
                if (targetBaby) {
                    // Go find food first if bird is hungry itself or doesn't have food
                    if (this.hunger > 200) {
                        this.findFoodSource();
                        debugLog(`Bird needs to find food before feeding baby`);
                    } else {
                        // Set target to the baby bird
                        this.target = {
                            type: 'baby',
                            x: targetBaby.x,
                            y: targetBaby.y,
                            baby: targetBaby
                        };
                        this.state = BIRD_STATES.HUNTING;
                        this.stateTimer = 0;
                        debugLog(`Bird targeting baby bird at (${targetBaby.x}, ${targetBaby.y}) to feed it`);
                    }
                } else {
                    // No suitable baby found, go back to flying
                    this.state = BIRD_STATES.FLYING;
                    this.stateTimer = 0;
                    
                    // Maybe find a perch instead
                    if (Math.random() < 0.5) {
                        this.findPerch();
                    }
                }
            }

            flee(threatX, threatY) {
                // Calculate direction away from threat
                const dx = this.x - threatX;
                const dy = this.y - threatY;
                const dir = normalize(dx, dy);

                // Record danger
                this.recordDanger(threatX, threatY, 'unknown');

                // Ground birds flee slower - use FLEEING_GROUND state
                if (this.isOnGround || this.y > canvas.height * GROUND_HEIGHT_RATIO - 20) {
                    this.state = BIRD_STATES.FLEEING_GROUND;
                    this.stateTimer = 0;
                    this.velocity = { x: 0, y: 0 }; // Will launch after delay
                } else {
                    // Air birds flee immediately
                    this.state = BIRD_STATES.FLEEING;
                    this.stateTimer = 0;

                    // Apply immediate force away from threat
                    this.velocity.x = dir.x * this.baseSpeed * 2;
                    this.velocity.y = dir.y * this.baseSpeed * 1.5 - 1; // Upward bias
                }

                // Set direction faced
                this.direction = dx > 0 ? 1 : -1;

                // Alert chirp
                this.chirp(CHIRP_TYPES.ALERT, 1.0);

                debugLog(`Bird fleeing from threat at (${threatX}, ${threatY})`);
            }

            // === NEW BEHAVIOR METHODS ===

            // Get all nearby flockmates
            getFlockmates() {
                return birds.filter(b =>
                    b !== this &&
                    !b.isWild &&
                    distance(this.x, this.y, b.x, b.y) < FLOCK_DISTANCE &&
                    b.birdType.name === this.birdType.name // Same species flock together
                );
            }

            // Check if this bird should be sentinel
            updateSentinelRole(flockmates) {
                if (flockmates.length === 0) {
                    this.isSentinel = false;
                    return;
                }

                const now = Date.now();
                const flockKey = `flock_${this.birdType.name}`;

                // Check if it's time to rotate sentinel
                if (!sentinelRotationTimers.has(flockKey) ||
                    now - sentinelRotationTimers.get(flockKey) > SENTINEL_ROTATION_INTERVAL) {

                    // Choose new sentinel (random from flock)
                    const candidates = [this, ...flockmates];
                    const newSentinel = candidates[Math.floor(Math.random() * candidates.length)];

                    // Clear old sentinel status
                    candidates.forEach(b => b.isSentinel = false);

                    // Assign new sentinel
                    newSentinel.isSentinel = true;
                    currentSentinels.set(flockKey, newSentinel);
                    sentinelRotationTimers.set(flockKey, now);

                    debugLog(`New sentinel assigned in ${this.birdType.name} flock`);
                }
            }

            // Emit a chirp with specific type
            chirp(type, intensity = 1.0) {
                // Don't chirp during playthehits performance
                if (playingTheHits) return;

                const now = Date.now();
                if (now - this.lastChirp < 1000) return; // Cooldown

                this.lastChirp = now;
                console.log("Bird chirp called - type:", type, "intensity:", intensity, "birdId:", this.id);

                activeChirps.push({
                    x: this.x,
                    y: this.y,
                    type: type,
                    timestamp: now,
                    birdId: this.id,
                    intensity: intensity
                });

                // Play audio using simplified bird chirp synthesis
                // Use synthBirdChirp for more natural bird sounds
                // Different chirp types get different volumes
                const volumeMap = {
                    [CHIRP_TYPES.SOCIAL]: 0.3,
                    [CHIRP_TYPES.FOOD_CALL]: 0.4,
                    [CHIRP_TYPES.CONTACT_CALL]: 0.25,
                    [CHIRP_TYPES.ALERT]: 0.5,
                    [CHIRP_TYPES.TERRITORIAL]: 0.35,
                    [CHIRP_TYPES.VICTORY]: 0.45
                };

                const volume = (volumeMap[type] || 0.3) * intensity;
                console.log("Calling synthBirdChirp with volume:", volume);
                synthBirdChirp(volume, this.id); // Pass bird ID for consistent voice
            }

            // Announce food discovery to flockmates
            makeFoodCall(foodX, foodY) {
                const now = Date.now();
                if (now - this.lastFoodCall < 3000) return; // Don't spam food calls

                this.lastFoodCall = now;
                this.chirp(CHIRP_TYPES.FOOD_CALL, 1.2);

                // Add to shared flock knowledge
                sharedFoodKnowledge.push({
                    x: foodX,
                    y: foodY,
                    timestamp: now,
                    discoveredBy: this.id
                });

                // Flockmates add to their own memory too
                const flockmates = this.getFlockmates();
                flockmates.forEach(bird => {
                    if (distance(bird.x, bird.y, this.x, this.y) < 200) {
                        bird.foodMemory.push({
                            x: foodX,
                            y: foodY,
                            timestamp: now
                        });
                    }
                });

                debugLog(`${this.birdType.name} made food call at (${foodX}, ${foodY})`);
            }

            // Make contact call when far from flock
            checkContactCall() {
                const flockmates = this.getFlockmates();
                if (flockmates.length === 0) return;

                const nearestDist = Math.min(...flockmates.map(b =>
                    distance(this.x, this.y, b.x, b.y)
                ));

                const now = Date.now();
                if (nearestDist > CONTACT_CALL_DISTANCE && now - this.lastContactCall > 5000) {
                    this.lastContactCall = now;
                    this.chirp(CHIRP_TYPES.CONTACT_CALL, 0.7);
                }
            }

            // Start mobbing behavior against predator
            startMobbing(predatorX, predatorY, predatorType) {
                this.isMobbing = true;
                this.mobbingTarget = {x: predatorX, y: predatorY, type: predatorType};
                this.state = BIRD_STATES.MOBBING;
                this.stateTimer = 0;
                this.chirp(CHIRP_TYPES.ALERT, 1.5);

                // Alert flockmates to join mobbing
                const flockmates = this.getFlockmates();
                flockmates.forEach(bird => {
                    if (distance(bird.x, bird.y, this.x, this.y) < 300 && bird.aggression > 0.4) {
                        bird.isMobbing = true;
                        bird.mobbingTarget = {x: predatorX, y: predatorY, type: predatorType};
                        bird.state = BIRD_STATES.MOBBING;
                        bird.stateTimer = 0;
                    }
                });

                // Register active mobbing
                activeMobbings.push({
                    targetX: predatorX,
                    targetY: predatorY,
                    participants: [this.id, ...flockmates.filter(b => b.isMobbing).map(b => b.id)],
                    startTime: Date.now()
                });

                debugLog(`Mobbing started against ${predatorType} at (${predatorX}, ${predatorY})`);
            }

            // Update mobbing behavior
            updateMobbing(deltaTime) {
                const now = Date.now();
                if (!this.mobbingTarget || this.stateTimer > MOBBING_DURATION) {
                    // End mobbing
                    this.isMobbing = false;
                    this.mobbingTarget = null;
                    this.state = BIRD_STATES.FLYING;
                    return;
                }

                // Circle and dive at target
                if (now - this.lastMobbingDive > MOBBING_DIVE_FREQUENCY) {
                    this.lastMobbingDive = now;

                    // Calculate dive point near predator
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 50 + Math.random() * 50;
                    const targetX = this.mobbingTarget.x + Math.cos(angle) * radius;
                    const targetY = this.mobbingTarget.y + Math.sin(angle) * radius - 30;

                    this.generatePath(targetX, targetY);

                    // Aggressive chirping
                    if (Math.random() < 0.3) {
                        this.chirp(CHIRP_TYPES.ALERT, 0.8);
                    }
                }
            }

            // Add danger zone to memory
            recordDanger(dangerX, dangerY, threatType) {
                this.lastDangerEncounter = Date.now();
                this.fearLevel = Math.min(1.0, this.fearLevel + 0.3);

                // Add to global danger zones
                dangerZones.push({
                    x: dangerX,
                    y: dangerY,
                    timestamp: Date.now(),
                    threatType: threatType
                });

                debugLog(`Danger recorded at (${dangerX}, ${dangerY}): ${threatType}`);
            }

            // Check if location is in a danger zone
            isDangerZone(x, y) {
                const now = Date.now();

                // Override fear if starving
                if (this.hunger > FEAR_OVERRIDE_HUNGER) {
                    return false;
                }

                // Clean up old danger zones
                dangerZones = dangerZones.filter(d => now - d.timestamp < DANGER_MEMORY_DURATION);

                // Check if point is in any danger zone
                return dangerZones.some(d =>
                    distance(x, y, d.x, d.y) < DANGER_ZONE_RADIUS
                );
            }

            // Ground pecking behavior
            startPecking() {
                this.state = BIRD_STATES.PECKING;
                this.isOnGround = true;
                this.peckTimer = 0;
                this.lastPeckTime = Date.now();

                // Check for nearby flockmates to determine pecking speed
                const nearbyFeeding = birds.filter(b =>
                    b !== this &&
                    b.state === BIRD_STATES.PECKING &&
                    distance(this.x, this.y, b.x, b.y) < 100
                );

                // Social facilitation - peck faster in groups
                if (nearbyFeeding.length > 0) {
                    this.peckingInterval = PECKING_INTERVAL_GROUP;
                    debugLog(`${this.birdType.name} started pecking in group (${nearbyFeeding.length} nearby) at (${this.x.toFixed(0)}, ${this.y.toFixed(0)})`);
                } else {
                    this.peckingInterval = PECKING_INTERVAL_SOLO;
                    debugLog(`${this.birdType.name} started solo pecking at (${this.x.toFixed(0)}, ${this.y.toFixed(0)})`);
                }
            }

            // Update pecking animation
            updatePecking(deltaTime) {
                const now = Date.now();

                // Check if should peck
                if (now - this.lastPeckTime > this.peckingInterval) {
                    this.lastPeckTime = now;
                    this.peckAnimationPhase = 1.0; // Start peck animation

                    // Actually consume food if present
                    const nearbyFood = foodItems.find(f =>
                        distance(this.x, this.y, f.x, f.y) < 20
                    );

                    if (nearbyFood) {
                        this.hunger = Math.max(0, this.hunger - 50);
                        foodItems.splice(foodItems.indexOf(nearbyFood), 1);
                        debugLog(`${this.birdType.name} pecked and consumed food at (${this.x.toFixed(0)}, ${this.y.toFixed(0)})`);
                    } else {
                        debugLog(`${this.birdType.name} pecked ground (no food) at (${this.x.toFixed(0)}, ${this.y.toFixed(0)})`);
                    }
                }

                // Animate peck
                if (this.peckAnimationPhase > 0) {
                    this.peckAnimationPhase -= deltaTime / 200; // Animation duration
                    this.peckAnimationPhase = Math.max(0, this.peckAnimationPhase);
                }

                // Check for nearby pecking birds for social facilitation
                const nearbyFeeding = birds.filter(b =>
                    b !== this &&
                    b.state === BIRD_STATES.PECKING &&
                    distance(this.x, this.y, b.x, b.y) < 100
                );

                this.peckingInterval = nearbyFeeding.length > 0 ?
                    PECKING_INTERVAL_GROUP : PECKING_INTERVAL_SOLO;
            }

            // Territorial display behavior
            startTerritorialDisplay(rival) {
                this.state = BIRD_STATES.TERRITORIAL_DISPLAY;
                this.lastTerritorialDisplay = Date.now();
                this.stateTimer = 0;
                this.chirp(CHIRP_TYPES.TERRITORIAL, 1.0);

                // Alert flockmates for coalition support
                const flockmates = this.getFlockmates();
                const supporters = flockmates.filter(b =>
                    distance(b.x, b.y, this.x, this.y) < 150 &&
                    b.aggression > 0.5
                );

                // Record territorial dispute
                territorialDisputes.push({
                    bird1: this,
                    bird2: rival,
                    location: {x: this.x, y: this.y},
                    startTime: Date.now(),
                    supporters1: supporters.length,
                    supporters2: 0 // Would count rival's supporters
                });

                debugLog(`Territorial display: ${this.birdType.name} vs ${rival.birdType.name}`);
            }

            update(deltaTime) {
                // Update wingflap with slower movement for calmer appearance
                if (this.state === BIRD_STATES.FLYING || this.state === BIRD_STATES.FLEEING || 
                    Math.abs(this.velocity.x) > 0.2 || Math.abs(this.velocity.y) > 0.2) {
                    this.wingFlap += 0.2 * deltaTime / 16; // Reduced from 0.3
                } else {
                    this.wingFlap += 0.02 * deltaTime / 16; // Reduced from 0.05
                }
                
                // State-independent checks
                this.hunger += BIRD_HUNGER_RATE * deltaTime / 16 * (isRaining ? 1.2 : 1);
                if (this.hunger >= BIRD_MAX_HUNGER) {
                    debugLog(`A ${this.birdType.name} died of hunger!`, DEBUG_LEVELS.WARNING);
                    return true; // Bird dies of hunger
                }
                
                // Wild birds leave after a while
                if (this.isWild && this.stateTimer > 30000) {
                    return true; // Bird leaves the scene
                }
                
                // Update poop timer - create smaller poops
                const now = Date.now();
                if (now - this.lastPoopTime > BIRD_POOP_DELAY && Math.random() < 0.001 * deltaTime / 16) {
                    birdPoops.push({
                        x: this.x,
                        y: this.y,
                        size: 3 + Math.random() * 2, // Reduced from 5 + random * 3
                        yVelocity: 1,
                        grounded: false,
                        timer: 0
                    });
                    this.lastPoopTime = now;
                    debugLog(`Bird pooped at (${this.x}, ${this.y})`);
                }
                
                this.stateTimer += deltaTime;
                
                // Reset acceleration each frame
                this.acceleration = { x: 0, y: 0 };
                
                // Check if non-wild bird has a nest that needs maintenance
                if (!this.isWild && this.myNest && this.myNest.needsMaintenance && 
                    this.state !== BIRD_STATES.BUILDING && Math.random() < 0.02) {
                    // Higher chance to check nest condition
                    if (this.checkNestCondition()) {
                        // Will transition to maintenance
                        return false; // Skip other state checks
                    }
                }


// Enhanced tree collision avoidance
if (this.state === BIRD_STATES.FLYING) {
    // Check for nearby trees that might cause problems
    for (const tree of trees) {
        const distToTree = Math.abs(this.x - tree.x);
        const treeWidth = tree.trunkWidth * tree.scale;
        
        // If very close to a tree trunk horizontally
        if (distToTree < treeWidth * 1.5) {
            // Check if we're at trunk height (not in the leafy part)
            const trunkTop = tree.y - tree.trunkHeight * tree.scale;
            if (this.y > trunkTop) {
                // Apply stronger horizontal force away from tree
                const pushDirection = this.x < tree.x ? -1 : 1;
                const pushStrength = 0.1; // Stronger push than normal
                
                this.applyForce({
                    x: pushDirection * pushStrength,
                    y: -0.05 // Always push slightly upward to help escape
                });
                
                // If extremely close to tree, make an emergency maneuver
                if (distToTree < treeWidth * 0.8) {
                    // Emergency evasion - stronger push
                    this.velocity.x = pushDirection * this.baseSpeed;
                    this.velocity.y = -this.baseSpeed * 0.5;
                    
                    // Update direction
                    this.direction = pushDirection;
                    
                    // Generate a path away from the tree if stuck for too long
                    if (!this.treeStuckTime) this.treeStuckTime = 0;
                    this.treeStuckTime += 16;
                    
                    if (this.treeStuckTime > 500) {
                        // Clear path and create a new one away from the tree
                        this.path = [];
                        this.pathIndex = 0;
                        
                        // Target position away from tree
                        const targetX = tree.x + (pushDirection * 150);
                        const targetY = Math.min(this.y - 50, tree.y - tree.trunkHeight * tree.scale - 20);
                        
                        this.generatePath(targetX, targetY);
                        debugLog(`Emergency evasion from tree at (${tree.x})`);
                        this.treeStuckTime = 0;
                    }
                }
            }
        } else {
            // Reset tree stuck time when not near trees
            this.treeStuckTime = 0;
        }
    }
}

                // === NEW BEHAVIOR UPDATES ===
                // Update flocking behaviors
                const flockmates = this.getFlockmates();

                // Update sentinel role
                if (!this.isWild && flockmates.length > 0) {
                    this.updateSentinelRole(flockmates);
                }

                // Contact calls - check if far from flock
                if (flockmates.length > 0 && Math.random() < 0.01) {
                    this.checkContactCall();
                }

                // Decrease fear level over time
                if (this.fearLevel > 0) {
                    this.fearLevel = Math.max(0, this.fearLevel - 0.001 * deltaTime / 16);
                }

                // Update defeat timer
                if (this.defeatedRecently) {
                    this.defeatTimer += deltaTime;
                    if (this.defeatTimer > 10000) {
                        this.defeatedRecently = false;
                        this.defeatTimer = 0;
                    }
                }

                // Clean up old food memory (reuse 'now' from earlier)
                this.foodMemory = this.foodMemory.filter(f => now - f.timestamp < FOOD_KNOWLEDGE_DURATION);

                // Check for owl/crow (predators) to mob
                if (!this.isWild && !this.isMobbing && flockmates.length >= 2) {
                    // Check for nearby owls
                    for (const owl of owls) {
                        if (distance(this.x, this.y, owl.x, owl.y) < 250) {
                            // High aggression birds more likely to initiate mobbing
                            if (Math.random() < this.aggression * 0.1) {
                                this.startMobbing(owl.x, owl.y, 'owl');
                                this.recordDanger(owl.x, owl.y, 'owl');
                                break;
                            }
                        }
                    }
                    // Check for nearby crows
                    for (const crow of crows) {
                        if (distance(this.x, this.y, crow.x, crow.y) < 200) {
                            if (Math.random() < this.aggression * 0.05) {
                                this.startMobbing(crow.x, crow.y, 'crow');
                                this.recordDanger(crow.x, crow.y, 'crow');
                                break;
                            }
                        }
                    }
                }

                // Update ground status
                const groundY = canvas.height * GROUND_HEIGHT_RATIO;
                this.isOnGround = Math.abs(this.y - groundY) < 10 && Math.abs(this.velocity.y) < 0.5;

                // Update bird based on its current state
                switch (this.state) {
                    case BIRD_STATES.IDLE:
                        // Apply air resistance
                        this.velocity.x *= AIR_RESISTANCE;
                        this.velocity.y *= AIR_RESISTANCE;

                        // Apply slight gravity
                        this.applyForce({ x: 0, y: GRAVITY });

                        // Random chirping while idle (ambient sounds)
                        if (Math.random() < 0.005) { // ~0.5% chance per frame (ambient)
                            const chirpTypes = [CHIRP_TYPES.SOCIAL, CHIRP_TYPES.CONTACT_CALL];
                            this.chirp(chirpTypes[Math.floor(Math.random() * chirpTypes.length)], 0.5);
                        }

                        // Check for baby birds needing feeding - higher priority than hunger
                        if (!this.isWild && babyBirds.length > 0 && Math.random() < 0.05) {
                            // Check more frequently for babies that need feeding
                            let hungryBaby = babyBirds.find(baby => baby.timeSinceLastMeal > 30);
                            if (hungryBaby) {
                                this.findBabyBirds();
                                break;
                            }
                        }
                        
// Check for shelter in birdhouses when raining or night
if ((isRaining || timeOfDay >= 1) && Math.random() < 0.4) { // 40% chance to seek shelter
        if (this.findBirdhouse()) {
            break; // Skip other state transitions
        }
    }


                        // Check for state transitions
                        if (this.hunger > HUNGER_CRITICAL_THRESHOLD) {
                            // Hungry - go find food
                            this.findFoodSource();
                        } else if (this.stateTimer > Math.max(MIN_STATE_DURATION, BIRD_STATE_DURATION.IDLE) || Math.random() < 0.01) {
                            // Transition to another state
                            const r = Math.random();

                            // CHECK FOR BATHING FIRST:
                            if (puddles.length > 0 && Math.random() < 0.4) { // 40% chance to bathe if puddles exist
                                this.findPuddle();
                            }
                                
                            // V26: Adjusted state preferences for more perching
                            if (this.hunger > HUNGER_CRITICAL_THRESHOLD - 50) {
                                // Go find food if somewhat hungry
                                this.findFoodSource();
                            } else if (!this.isWild && !this.myNest && twigs.length > 0 && r < 0.4) { // Increased from ~0.2
                                // Much higher chance to collect nest materials
                                this.findTwigs();
                            } else if (r < BIRD_STATE_PREFERENCES.PERCHING) { // Increased perching preference
                                // Try to find perch
                                this.findPerch();
                            } else {
                                this.state = BIRD_STATES.FLYING;
                                this.stateTimer = 0;
                                // Set random direction to fly in
                                this.generatePath(
                                    Math.random() * canvas.width, 
                                    100 + Math.random() * (canvas.height * 0.5 - 100)
                                );
                            }

                            // Add chance to build birdhouse
                            if (!this.isWild && Math.random() < 0.20 && this.materialsHeld === 0) {
                                this.findOrCreateBirdhouse();
                            }
                        } else {
                            // Random small movements
                            if (Math.random() < 0.05) {
                                this.applyForce({
                                    x: (Math.random() - 0.5) * 0.02,
                                    y: (Math.random() - 0.5) * 0.01
                                });
                            }

                            // Random chirping while idle (increased frequency)
                            if (Math.random() < 0.006) { // ~0.6% chance per frame
                                this.chirp(CHIRP_TYPES.SOCIAL, 0.5);
                            }
                        }
                        break;

                    case BIRD_STATES.PERCHED:
                        // V26: Check nest condition periodically when perched
                        if (Math.random() < 0.03) {
                            if (this.checkNestCondition()) {
                                // Will transition to maintenance mode if needed
                                break;
                            }
                        }
                    
                        if (!this.perchTarget || !this.perchTarget.tree || trees.indexOf(this.perchTarget.tree) === -1) {
                            // Tree is gone, can't perch
                            this.state = BIRD_STATES.FLYING;
                            this.stateTimer = 0;
                            this.perchTarget = null;
                            
                            // Generate path upward
                            this.generatePath(this.x, this.y - 50);
                            break;
                        }
                        
                        // Calculate distance to perch target
                        const perchDist = distance(this.x, this.y, this.perchTarget.x, this.perchTarget.y);
                        
                        if (perchDist < 5) {
                            // Bird is perched, stop all movement
                            this.velocity = { x: 0, y: 0 };
                            this.acceleration = { x: 0, y: 0 };
                            
                            // Exactly position on perch point
                            this.x = this.perchTarget.x;
                            this.y = this.perchTarget.y;


                            // Check for baby birds more frequently when perched
    if (!this.isWild && babyBirds.length > 0 && Math.random() < 0.008) { // 0.8% chance per frame (~2.5% per second)
        // Look for very hungry babies (over 120 seconds without food)
        let veryHungryBaby = babyBirds.find(baby => 
            baby.timeSinceLastMeal > 120 && 
            (baby.associatedNest === this.myNest || !baby.associatedNest)
        );
        
        if (veryHungryBaby) {
            // Leave perch immediately to feed baby
            this.state = BIRD_STATES.FLYING;
            this.stateTimer = 0;
            this.perchTarget = null;
            this.findBabyBirds();
            break;
        }
    }
                            
                            // Decrease cooldown timer
                            this.directionChangeCooldown -= deltaTime;
                            
                            // Only update direction when cooldown expires
                            if (this.directionChangeCooldown <= 0) {
                                // Face the correct direction based on position in tree
                                if (this.perchTarget.inLeaves) {
                                    // Even less frequent direction changes in leaves
                                    this.direction = Math.random() < 0.2 ? -1 : 1; // Reduced from 0.5
                                } else {
                                    // Face toward tree trunk on branches - no randomness
                                    this.direction = this.x < this.perchTarget.tree.x ? 1 : -1;
                                }
                                
                                // V26: Even longer cooldown for more stable perching
                                this.directionChangeCooldown = 8000 + Math.random() * 12000; // Increased from 5-15 seconds
                            }
                            
                            // Bird behavior while perched
                            this.pecking = Math.random() < 0.1;
                            if (this.pecking) {
                                this.peckTimer = (this.peckTimer + 1) % 100;
                            }

                            // Random chirping while perched (ambient sounds)
                            if (Math.random() < 0.008) { // ~0.8% chance per frame
                                const chirpTypes = [CHIRP_TYPES.SOCIAL, CHIRP_TYPES.CONTACT_CALL, CHIRP_TYPES.TERRITORIAL];
                                this.chirp(chirpTypes[Math.floor(Math.random() * chirpTypes.length)], 0.6);
                            }
                            
                            // Check if there are squirrels nearby
                            const nearbySquirrel = squirrels.find(squirrel => 
                                squirrel.climbingTree === this.perchTarget.tree &&
                                distance(squirrel.x, squirrel.y, this.x, this.y) < 60
                            );
                            
                            if (nearbySquirrel) {
                                // Flee from squirrel
                                this.flee(nearbySquirrel.x, nearbySquirrel.y);
                                debugLog(`Bird fleeing from squirrel in tree!`);
                                break;
                            }

                            // Check for baby birds while perched if bird has a nest with babies
                            if (!this.isWild && this.myNest && babyBirds.length > 0 && Math.random() < 0.1) {
                                // More frequent checks (increased from 0.08 to 0.1)
                                // Check if there are hungry babies in this bird's nest
                                let hungryBaby = babyBirds.find(baby => 
                                    baby.associatedNest === this.myNest && 
                                    baby.timeSinceLastMeal > 20 // Reduced threshold from 40
                                );
                                
                                if (hungryBaby) {
                                    this.findBabyBirds();
                                    break;
                                }
                            }

                            // Leave perch after a while or if hungry
                            if (this.stateTimer > BIRD_STATE_DURATION.PERCHED || 
                                this.hunger > HUNGER_CRITICAL_THRESHOLD - 50 || 
                                Math.random() < 0.002) { // Reduced chance to leave perch early
                                
                                // Decide what to do next
                                if (this.hunger > HUNGER_CRITICAL_THRESHOLD - 50) {
                                    // Go find food
                                    this.findFoodSource();
                                } else if (!this.isWild && !this.myNest && twigs.length > 0 && Math.random() < 0.5) {
                                    // Possibly collect nest materials
                                    this.findTwigs();
                                } else if (Math.random() < 0.4) { // Reduced from 0.6 - less likely to fly away
                                    // Just fly somewhere else rather than another tree
                                    this.state = BIRD_STATES.FLYING;
                                    this.stateTimer = 0;
                                    
                                    // Create a path away from the tree first
                                    const dirX = this.perchTarget.tree.x > this.x ? -50 : 50; // Stronger push away
                                    this.generatePath(this.x + dirX, this.y - 30);
                                } else {
                                    // Find a different perch
                                    this.findPerch();
                                }
                            }
                            
                            // Special case: if in the rain, seek shelter after a while
                            if (isRaining && this.stateTimer > 5000 && Math.random() < 0.1) {
                                this.state = BIRD_STATES.SHELTERING;
                                this.stateTimer = 0;
                            }
                            
                        } else {
                            // Moving toward perch
                            const dx = this.perchTarget.x - this.x;
                            const dy = this.perchTarget.y - this.y;
                            const perchDir = normalize(dx, dy);
                            
                            this.applyForce({ 
                                x: perchDir.x * 0.01, 
                                y: perchDir.y * 0.01 
                            });
                            
                            // Slow down as we approach the perch
                            const slowdownFactor = Math.min(1, perchDist / 30);
                            this.velocity.x *= Math.min(AIR_RESISTANCE, 0.95 + slowdownFactor * 0.04);
                            this.velocity.y *= Math.min(AIR_RESISTANCE, 0.95 + slowdownFactor * 0.04);
                            
                            // If perching is taking too long, give up
                            if (this.stateTimer > 10000) {
                                this.state = BIRD_STATES.FLYING;
                                this.stateTimer = 0;
                                this.perchTarget = null;
                                
                                // Fly away from failed perch
                                this.generatePath(
                                    Math.random() * canvas.width, 
                                    100 + Math.random() * (canvas.height * 0.3)
                                );
                            }
                        }
                        break;

                    case BIRD_STATES.HUNTING:
                        // Check if target is valid
                        if (!this.target || 
                            (this.target.type === 'worm' && worms.indexOf(this.target.worm) === -1) ||
                            (this.target.type === 'food' && foodItems.indexOf(this.target.food) === -1)) {
                            // Target is gone, go back to flying
                            this.state = BIRD_STATES.FLYING;
                            this.stateTimer = 0;
                            this.target = null;
                            break;
                        }
                        
                        // Move toward target
                        const huntTargetDist = distance(this.x, this.y, this.target.x, this.target.y);
                        
                        if (huntTargetDist < 25) { // Increased from 10 - easier to collect food
                            // Check dominance hierarchy - lower aggression birds wait for dominant birds
                            // Reuse flockmates declared earlier in update()
                            const dominantBirdsNearby = this.getFlockmates().filter(b =>
                                b.aggression > this.aggression &&
                                distance(this.x, this.y, b.x, b.y) < 50 &&
                                b.state === BIRD_STATES.HUNTING
                            );

                            // If dominant birds nearby and this bird is submissive, wait
                            if (dominantBirdsNearby.length > 0 && this.aggression < 0.6) {
                                // Wait 1-2 seconds before feeding
                                if (this.stateTimer < 1500) {
                                    this.velocity.x *= 0.9;
                                    this.velocity.y *= 0.9;
                                    break;
                                }
                            }

                            // Reached target - check if ground food
                            const isGroundFood = (this.target.type === 'worm' || this.target.type === 'food') &&
                                this.target.y > canvas.height * GROUND_HEIGHT_RATIO - 50;

                            if (isGroundFood && huntTargetDist < 30) {
                                // Transition to pecking behavior instead of instant eating
                                this.startPecking();
                                break;
                            }

                            // Eat it (for non-ground food or baby feeding)
                            if (this.target.type === 'worm') {
                                const wormIndex = worms.indexOf(this.target.worm);
                                if (wormIndex !== -1) {
                                    worms.splice(wormIndex, 1);
                                }
                                // Worms are more nutritious
                                this.hunger = Math.max(0, this.hunger - 150); // Increased from 120
                                debugLog(`Bird ate worm at (${this.target.x}, ${this.target.y})`);
                            } else if (this.target.type === 'food') {
                                const foodIndex = foodItems.indexOf(this.target.food);
                                if (foodIndex !== -1) {
                                    foodItems.splice(foodIndex, 1);
                                }
                                this.hunger = Math.max(0, this.hunger - 100); // Increased from 80
                                debugLog(`Bird ate food at (${this.target.x}, ${this.target.y})`);
                            } else if (this.target.type === 'baby') {
                                // Handle feeding baby birds with improved behavior
                                if (this.target.baby && babyBirds.indexOf(this.target.baby) !== -1) {
                                    // Feed the baby bird
                                    this.target.baby.feed();
                                    this.hunger += 20; // Feeding costs energy
                                    
                                    // Visual effect for feeding (could be flapping, etc)
                                    this.pecking = true;
                                    this.peckTimer = 0;
                                    
                                    // Create a small animation effect
                                    specialEffects.push({
                                        x: this.target.baby.x,
                                        y: this.target.baby.y - 10,
                                        type: 'feeding',
                                        timer: 0,
                                        duration: 1000
                                    });
                                    
                                    debugLog(`Bird fed baby at (${this.target.x}, ${this.target.y})`);
                                    
                                    // After feeding, possibly stay to feed more or look for more food
                                    if (Math.random() < 0.3 && this.hunger < 150) {
                                        // Stay with the baby a bit longer
                                        this.state = BIRD_STATES.RESTING;
                                        this.stateTimer = 0;
                                        this.x = this.target.x + (this.direction * 10);
                                        this.y = this.target.y;
                                    } else if (this.hunger > 150) {
                                        // Go find more food if bird is getting hungry
                                        this.findFoodSource();
                                    } else {
                                        // Look for another baby to feed
                                        setTimeout(() => {
                                            if (!this.isWild && birds.indexOf(this) !== -1) {
                                                this.findBabyBirds();
                                            }
                                        }, 2000);
                                    }
                                }
                            }
                            
                            // Start foraging on the ground
                            if (this.y > canvas.height * GROUND_HEIGHT_RATIO - 30) { // Increased from 20
                                this.state = BIRD_STATES.FEEDING;
                                this.stateTimer = 0;
                                debugLog(`Bird started foraging on ground`);
                            } else {
                                // If not close to ground, maybe look for more food
                                if (this.hunger > 100 && Math.random() < 0.6) { // Reduced from 0.7 - less hunting
                                    this.findFoodSource();
                                } else {
                                    // V26: Increased chance to perch after eating
                                    if (Math.random() < 0.6) { // Increased from ~0.3
                                        this.findPerch();
                                    } else {
                                        this.state = BIRD_STATES.FLYING;
                                        this.stateTimer = 0;
                                    }
                                }
                            }
                            
                            this.target = null;
                            
                        } else {
                            // Move toward target with adjusted speed based on distance
                            const dx = this.target.x - this.x;
                            const dy = this.target.y - this.y;
                            const dir = normalize(dx, dy);
                            
                            // If getting closer to target, start slowing down
                            const speedFactor = huntTargetDist < 30 ? 
                                0.3 + huntTargetDist / 30 * 0.7 : 1.0;
                            
                            this.applyForce({ 
                                x: dir.x * 0.02 * speedFactor, 
                                y: dir.y * 0.01 * speedFactor 
                            });
                            
                            // Face direction of movement
                            if (Math.abs(dx) > 2) { // More sensitive direction change
                                this.direction = dx > 0 ? 1 : -1;
                            }
                            
                            // If hunting is taking too long, give up
                            if (this.stateTimer > 7000) {
                                this.state = BIRD_STATES.FLYING;
                                this.stateTimer = 0;
                                this.target = null;
                                
                                // Generate a new flight path
                                this.generatePath(
                                    Math.random() * canvas.width, 
                                    Math.random() * (canvas.height * GROUND_HEIGHT_RATIO - 20)
                                );
                            }
                        }
                        break;

                    case BIRD_STATES.COLLECTING:
                        // Check if target is valid
                        if (!this.target || 
                            (this.target.type === 'twig' && twigs.indexOf(this.target.twig) === -1)) {
                            // Target is gone, go back to flying
                            this.state = BIRD_STATES.FLYING;
                            this.stateTimer = 0;
                            this.target = null;
                            debugLog("Bird lost target while collecting");
                            break;
                        }

                        const targetDist = distance(this.x, this.y, this.target.x, this.target.y);
                        
                        if (targetDist < 20) { // Increased from 10 - easier to collect twigs
                            // Reached target - collect it
                            if (this.target.type === 'twig') {
                                const twigIndex = twigs.indexOf(this.target.twig);
                                if (twigIndex !== -1) {
                                    // Check if this twig is special
                                    this.hasSpecialTwig = this.target.twig.isSpecial;
                                    twigs.splice(twigIndex, 1);
                                    this.materialsHeld = 1; // Carrying one twig
                                    debugLog(`Bird collected${this.hasSpecialTwig ? ' special' : ''} twig.`);
                                }
                            }
                            
                            // Now find/build a nest with high priority
                            if (this.isWild) {
                                // Wild birds don't build nests - just drop the twig
                                this.materialsHeld = 0;
                                this.hasSpecialTwig = false;
                                this.state = BIRD_STATES.FLYING;
                                this.stateTimer = 0;
                            } else if (this.myNest) {
                                // Already have a nest - go build it with high priority
                                this.state = BIRD_STATES.BUILDING;
                                this.stateTimer = 0;
                            } else if (this.buildingBirdhouse && this.buildingBirdhouse.isComplete === false) {
                                // Building a birdhouse
                                this.state = BIRD_STATES.BUILDING_BIRDHOUSE;
                                this.stateTimer = 0;
                            } else {
                                // No nest yet - find/create one
                                this.findOrCreateNest();
                            }
                            
                            this.target = null;
                            
                        } else {
                            // Move toward twig
                            const dx = this.target.x - this.x;
                            const dy = this.target.y - this.y;
                            const dir = normalize(dx, dy);
                            
                            // Slow down as we approach
                            const speedFactor = targetDist < 30 ? 
                                0.3 + targetDist / 30 * 0.7 : 1.0;
                            
                            this.applyForce({ 
                                x: dir.x * 0.02 * speedFactor, 
                                y: dir.y * 0.01 * speedFactor 
                            });
                            
                            // Face direction of movement
                            if (Math.abs(dx) > 2) {
                                this.direction = dx > 0 ? 1 : -1;
                            }
                            
                            // If collecting is taking too long, give up
                            if (this.stateTimer > 7000) {
                                this.state = BIRD_STATES.FLYING;
                                this.stateTimer = 0;
                                this.target = null;
                                
                                // Try again elsewhere
                                this.findTwigs();
                            }
                        }
                        break;

                    case BIRD_STATES.BUILDING:
                        // Check if nest is still valid
                        if (!this.myNest || nests.indexOf(this.myNest) === -1) {
                            // Nest is gone
                            this.myNest = null;
                            this.state = BIRD_STATES.FLYING;
                            this.stateTimer = 0;
                            
                            // Drop materials
                            if (this.materialsHeld > 0) {
                                twigs.push({
                                    x: this.x,
                                    y: canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 10,
                                    size: 10 + Math.random() * 8,
                                    angle: Math.PI / 4 + Math.random() * Math.PI / 2,
                                    isSpecial: this.hasSpecialTwig,
                                    offshoots: []
                                });
                                this.materialsHeld = 0;
                                this.hasSpecialTwig = false;
                            }
                            break;
                        }
                        
                        // Move toward nest
                        const nestDist = distance(this.x, this.y, this.myNest.x, this.myNest.y);
                        
                        if (nestDist < 25) { // Increased from 15 - easier to reach nest
                            // Reached nest - add materials
                            if (this.materialsHeld > 0) {
                                const isComplete = this.myNest.addMaterial();
                                debugLog(`Bird added ${this.hasSpecialTwig ? 'special ' : ''}material to nest at (${this.myNest.x}, ${this.myNest.y}). Materials: ${this.myNest.materialsCollected}/${NEST_MATERIALS_NEEDED}`);
                                
                                this.materialsHeld = 0;
                                this.hasSpecialTwig = false;
                                
                                // Set this nest as occupied by this bird
                                this.myNest.occupiedBy = this;
                                
                                // Check for baby bird creation
                                if (this.myNest.isComplete && this.myNest.readyForBabies) {
                                    this.myNest.readyForBabies = false; // Prevent multiple babies
                                    
                                    this.myNest.lastBabyTime = Date.now(); // Record when baby was born
                                
                                    // Create a baby bird
                                    const baby = new BabyBird(this.myNest.x, this.myNest.y, this.birdType, this.myNest);
                                    babyBirds.push(baby);
                                    debugLog(`Baby bird created in nest at (${this.myNest.x}, ${this.myNest.y})`);

                                    // Register baby in lineage and create diary entry
                                    const babyName = registerBabyBird(baby, this);
                                    const parentName = getBirdName(this);
                                    addDiaryEntry(`${babyName} was born! Parent: ${parentName}`, 'birth');

                                    // Alert birds to feed the baby with a slight delay
                                    setTimeout(() => alertBirdsToFeedBaby(baby), 1000);
                                    
                                    // Also make parent bird immediately target the baby
                                    if (!this.isWild) {
                                        this.target = {
                                            type: 'baby',
                                            x: baby.x,
                                            y: baby.y,
                                            baby: baby
                                        };
                                        this.state = BIRD_STATES.HUNTING;
                                        this.stateTimer = 0;
                                    }
                                }
                                
                                // Reset maintenance need if it was needed
                                if (this.myNest.needsMaintenance) {
                                    this.myNest.needsMaintenance = false;
                                    this.lastNestCheckTime = Date.now();
                                }
                            }
                            
                            // Finished building/maintaining - perch on/near nest
                            if (!this.myNest.isComplete || this.myNest.needsMaintenance) {
                                // Get more materials with high priority
                                this.findTwigs();
                            } else if (Math.random() < 0.3) { // Reduced from 0.4
                                // Maybe look for food
                                this.findFoodSource();
                            } else {
                                // Find perch near nest
                                if (babyBirds.length > 0 && Math.random() < 0.7) { // Increased from 0.5
                                    // Look for babies to feed
                                    this.findBabyBirds();
                                } else {
                                    // Rest at nest - V26: increased likelihood
                                    this.state = BIRD_STATES.RESTING;
                                    this.stateTimer = 0;
                                }
                            }
                            
                        } else {
                            // Move toward nest
                            const dx = this.myNest.x - this.x;
                            const dy = this.myNest.y - this.y;
                            const dir = normalize(dx, dy);
                            
                            // Slow down as we approach
                            const speedFactor = nestDist < 30 ? 
                                0.3 + nestDist / 30 * 0.7 : 1.0;
                            
                            this.applyForce({ 
                                x: dir.x * 0.02 * speedFactor, 
                                y: dir.y * 0.01 * speedFactor 
                            });
                            
                            // Face direction of movement
                            if (Math.abs(dx) > 2) {
                                this.direction = dx > 0 ? 1 : -1;
                            }
                            
                            // If building trip is taking too long, give up building for now
                            if (this.stateTimer > 10000) {
                                // Drop materials
                                if (this.materialsHeld > 0) {
                                    twigs.push({
                                        x: this.x,
                                        y: canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 10,
                                        size: 10 + Math.random() * 8,
                                        angle: Math.PI / 4 + Math.random() * Math.PI / 2,
                                        isSpecial: this.hasSpecialTwig,
                                        offshoots: []
                                    });
                                    this.materialsHeld = 0;
                                    this.hasSpecialTwig = false;
                                }
                                
                                this.state = BIRD_STATES.FLYING;
                                this.stateTimer = 0;
                                
                                // Generate a new flight path away from trouble
                                this.generatePath(
                                    Math.random() * canvas.width, 
                                    100 + Math.random() * (canvas.height * 0.3)
                                );
                            }
                        }
                        break;

                    case BIRD_STATES.BUILDING_BIRDHOUSE:
                       // Check if birdhouse still exists
                        if (!this.buildingBirdhouse || birdhouses.indexOf(this.buildingBirdhouse) === -1) {
                            // Birdhouse is gone
                            this.buildingBirdhouse = null;
                            this.state = BIRD_STATES.FLYING;
                            this.stateTimer = 0;
                            
                            // Drop materials
                            if (this.materialsHeld > 0) {
                                twigs.push({
                                    x: this.x,
                                    y: canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 10,
                                    size: 10 + Math.random() * 8,
                                    angle: Math.PI / 4 + Math.random() * Math.PI / 2,
                                    isSpecial: this.hasSpecialTwig,
                                    offshoots: []
                                });
                                this.materialsHeld = 0;
                                this.hasSpecialTwig = false;
                            }
                            break;
                        }
                        
                        // Move toward birdhouse
                        const birdhouseDist = distance(this.x, this.y, this.buildingBirdhouse.x, this.buildingBirdhouse.y);
                        
                        if (birdhouseDist < 30) { // Easier to reach birdhouse
                            // Reached birdhouse - add materials
                            if (this.materialsHeld > 0) {
                                const isComplete = this.buildingBirdhouse.addMaterial();
                                debugLog(`Bird added ${this.hasSpecialTwig ? 'special ' : ''}material to birdhouse at (${this.buildingBirdhouse.x}, ${this.buildingBirdhouse.y}). Materials: ${this.buildingBirdhouse.materialsCollected}/${BIRDHOUSE_MATERIALS_NEEDED}`);
                                
                                this.materialsHeld = 0;
                                this.hasSpecialTwig = false;
                                
                                // If birdhouse is complete, perch on it
                                if (this.buildingBirdhouse.isComplete) {
                                    // Add bird as occupant
                                    this.buildingBirdhouse.addOccupant(this);
                                    
                                    // Rest at birdhouse
                                    this.state = BIRD_STATES.RESTING;
                                    this.stateTimer = 0;
                                    debugLog(`Bird is now an occupant of the birdhouse`);
                                } else {
                                    // Get more materials
                                    this.findTwigs();
                                }
                            } else {
                                // Get more materials
                                this.findTwigs();
                            }
                            
                        } else {
                            // Move toward birdhouse
                            const dx = this.buildingBirdhouse.x - this.x;
                            const dy = this.buildingBirdhouse.y - this.y;
                            const dir = normalize(dx, dy);
                            
                            // Slow down as we approach
                            const speedFactor = birdhouseDist < 50 ? 
                                0.3 + birdhouseDist / 50 * 0.7 : 1.0;
                            
                            this.applyForce({ 
                                x: dir.x * 0.02 * speedFactor, 
                                y: dir.y * 0.01 * speedFactor 
                            });
                            
                            // Face direction of movement
                            if (Math.abs(dx) > 2) {
                                this.direction = dx > 0 ? 1 : -1;
                            }
                            
                            // If building trip is taking too long, give up
                            if (this.stateTimer > 10000) {
                                // Drop materials
                                if (this.materialsHeld > 0) {
                                    twigs.push({
                                        x: this.x,
                                        y: canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 10,
                                        size: 10 + Math.random() * 8,
                                        angle: Math.PI / 4 + Math.random() * Math.PI / 2,
                                        isSpecial: this.hasSpecialTwig,
                                        offshoots: []
                                    });
                                    this.materialsHeld = 0;
                                    this.hasSpecialTwig = false;
                                }
                                
                                this.state = BIRD_STATES.FLYING;
                                this.stateTimer = 0;
                                
                                // Generate a new flight path
                                this.generatePath(
                                    Math.random() * canvas.width, 
                                    100 + Math.random() * (canvas.height * 0.3)
                                );
                            }
                        }
                        break;

                    case BIRD_STATES.FEEDING:
                        // Bobbing motion while feeding
                        this.pecking = Math.random() < 0.7;
                        if (this.pecking) {
                            this.peckTimer = (this.peckTimer + 1) % 30;
                        }
                        
                        // Apply a small random force for natural movement
                        if (Math.random() < 0.1) {
                            this.applyForce({ 
                                x: (Math.random() - 0.5) * 0.02,
                                y: 0
                            });
                            
                            // Flip direction occasionally while foraging
                            if (Math.random() < 0.1) {
                                this.direction *= -1;
                            }
                        }
                        
                        // Check for nearby food with larger detection radius
                        for (let i = foodItems.length - 1; i >= 0; i--) {
                            const food = foodItems[i];
                            if (distance(this.x, this.y, food.x, food.y) < 30) { // Increased from 20
                                foodItems.splice(i, 1);
                                this.hunger = Math.max(0, this.hunger - 100); // Increased from 80
                                debugLog(`Bird found and ate food while foraging.`);
                            }
                        }
                        
                        // Check for worms with larger detection radius
                        for (let i = worms.length - 1; i >= 0; i--) {
                            const worm = worms[i];
                            if (distance(this.x, this.y, worm.x, worm.y) < 30) { // Increased from 20
                                worms.splice(i, 1);
                                this.hunger = Math.max(0, this.hunger - 150); // Increased from 120
                                debugLog(`Bird found and ate worm while foraging.`);
                            }
                        }
                        
                        // Enforce ground-level constraint
                        if (this.y < canvas.height * GROUND_HEIGHT_RATIO - 10) {
                            this.y = canvas.height * GROUND_HEIGHT_RATIO - 10;
                            this.velocity.y = 0;
                        }
                        
                        // End feeding state after a while
                        if (this.stateTimer > 8000 || this.hunger < 100) {
                            // V26: More likely to perch after feeding
                            if (this.hunger > 200 && Math.random() < 0.4) { // Reduced from 0.5
                                // Still hungry - keep searching
                                this.findFoodSource();
                            } else if (!this.isWild && !this.myNest && twigs.length > 0 && Math.random() < 0.1) {
                                // Maybe collect nest materials
                                this.findTwigs();
                            } else if (!this.isWild && this.myNest && this.myNest.isComplete && babyBirds.length > 0 && Math.random() < 0.4) { // Reduced from 0.5
                                // Look for babies to feed
                                this.findBabyBirds();
                            } else {
                                // V26: Increased likelihood to perch rather than fly after feeding
                                if (Math.random() < 0.6) { // Added 60% chance to perch
                                    this.findPerch();
                                } else {
                                    // Return to flying
                                    this.state = BIRD_STATES.FLYING;
                                    this.stateTimer = 0;
                                    
                                    // Fly upward
                                    this.generatePath(
                                        this.x + (Math.random() - 0.5) * 50,
                                        100 + Math.random() * 100
                                    );
                                }
                            }
                        }
                        break;

                    case BIRD_STATES.FLEEING:
                        // Strong upward and away motion
                        if (this.velocity.y > -1.0) {
                            this.applyForce({ x: 0, y: -0.05 });
                        }
                        
                        // Continue in flee direction
                        this.applyForce({ 
                            x: this.direction * 0.03, 
                            y: 0 
                        });
                        
                        // After fleeing for a while, transition to flying
                        if (this.stateTimer > BIRD_STATE_DURATION.FLEEING) {
                            this.state = BIRD_STATES.FLYING;
                            this.stateTimer = 0;
                            
                            // Fly away in current direction
                            const targetX = this.x + this.direction * 200;
                            const targetY = Math.max(50, this.y - 100);
                            this.generatePath(targetX, targetY);
                        }
                        break;

                    case BIRD_STATES.SHELTERING:
                        // Stay in place
                        this.velocity.x *= 0.9;
                        this.velocity.y *= 0.9;
                        
                        // Random small movements
                        if (Math.random() < 0.05) {
                            this.applyForce({ 
                                x: (Math.random() - 0.5) * 0.01,
                                y: (Math.random() - 0.5) * 0.005
                            });
                        }
                        
                        // Occasional preening motion
                        this.pecking = Math.random() < 0.2;
                        
                        // End sheltering if rain stops or after a while
                        if (!isRaining || this.stateTimer > BIRD_STATE_DURATION.SHELTERING) {
                            // V26: More likely to perch after sheltering
                            if (Math.random() < 0.7) { // Increased from 0.5
                                // Find perch after sheltering
                                this.findPerch();
                            } else if (Math.random() < 0.5) {
                                // Look for food after sheltering
                                this.findFoodSource();
                            } else {
                                // Return to flying
                                this.state = BIRD_STATES.FLYING;
                                this.stateTimer = 0;
                                
                                // Fly somewhere
                                this.generatePath(
                                    Math.random() * canvas.width,
                                    100 + Math.random() * (canvas.height * 0.3)
                                );
                            }
                        }
                        break;

                    case BIRD_STATES.RESTING:
                        // V26: Check nest condition occasionally while resting
                        if (!this.isWild && this.myNest && Math.random() < 0.02) {
                            this.checkNestCondition();
                        }
                        
                        // Very minimal movement while resting
                        this.velocity.x *= 0.95;
                        this.velocity.y *= 0.95;
                        
                        // Infrequent small adjustments
                        if (Math.random() < 0.02) {
                            this.applyForce({ 
                                x: (Math.random() - 0.5) * 0.005,
                                y: (Math.random() - 0.5) * 0.002
                            });
                        }
                        
                        // End resting after a while or if hungry
                        if (this.stateTimer > BIRD_STATE_DURATION.RESTING || this.hunger > HUNGER_CRITICAL_THRESHOLD - 100) {
                            if (this.hunger > HUNGER_CRITICAL_THRESHOLD - 100) {
                                // Go find food
                                this.findFoodSource();
                            } else if (!this.isWild && babyBirds.length > 0 && Math.random() < 0.5) { // Reduced from 0.6
                                // Look for babies to feed
                                this.findBabyBirds();
                            } else if (wasRaining && puddles.length > 0 && Math.random() < 0.3) {
                                // Go take a bath in a puddle
                                this.findPuddle();
                            } else {
                                // V26: More likely to find a new perch than to fly
                                if (Math.random() < 0.6) { // 60% chance to perch
                                    this.findPerch();
                                } else {
                                    // Return to flying
                                    this.state = BIRD_STATES.FLYING;
                                    this.stateTimer = 0;
                                    
                                    // Fly somewhere
                                    this.generatePath(
                                        Math.random() * canvas.width,
                                        100 + Math.random() * (canvas.height * 0.3)
                                    );
                                }
                            }
                        }
                        break;

                    case BIRD_STATES.BATHING:
                        // Check if there are still puddles
                        if (puddles.length === 0) {
                            this.state = BIRD_STATES.FLYING;
                            this.stateTimer = 0;
                            break;
                        }
                        
                        // Find nearest puddle
                        let nearestPuddle = null;
                        let minDist = Infinity;
                        for (const puddle of puddles) {
                            const dist = distance(this.x, this.y, puddle.x, puddle.y);
                            if (dist < minDist) {
                                minDist = dist;
                                nearestPuddle = puddle;
                            }
                        }
                        
                        if (!nearestPuddle || minDist > 50) {
                            // No puddle nearby, find one
                            this.findPuddle();
                            break;
                        }
                        
                        // If already at puddle
                        if (minDist < 15) {
                            // Bathing behavior - animated fluttering
                            this.velocity.x *= 0.5;
                            this.velocity.y *= 0.5;
                            
                            // Splashing motions
                            if (Math.random() < 0.2) {
                                // Add ripple to puddle
                                nearestPuddle.ripples.push({
                                    size: 2,
                                    maxSize: 5 + Math.random() * 8,
                                    speed: 0.1 + Math.random() * 0.1
                                });
                                
                                // Random motion
                                this.applyForce({ 
                                    x: (Math.random() - 0.5) * 0.1,
                                    y: (Math.random() - 0.5) * 0.05
                                });
                            }
                            
                            // End bathing after a while
                            if (this.stateTimer > BIRD_STATE_DURATION.BATHING) {
                                // V26: More likely to perch after bathing to dry off
                                if (Math.random() < 0.8) { // Increased from 0.7
                                    this.findPerch();
                                } else {
                                    this.state = BIRD_STATES.FLYING;
                                    this.stateTimer = 0;
                                    
                                    // Fly upward
                                    this.generatePath(
                                        this.x + (Math.random() - 0.5) * 50,
                                        this.y - 50 - Math.random() * 50
                                    );
                                }
                            }
                        } else {
                            // Move toward puddle
                            const dx = nearestPuddle.x - this.x;
                            const dy = nearestPuddle.y - this.y;
                            const dir = normalize(dx, dy);
                            
                            this.applyForce({ 
                                x: dir.x * 0.01, 
                                y: dir.y * 0.01 
                            });
                            
                            // Face direction of movement
                            if (Math.abs(dx) > 2) {
                                this.direction = dx > 0 ? 1 : -1;
                            }
                            
                            // If taking too long to reach puddle, give up
                            if (this.stateTimer > 5000) {
                                this.state = BIRD_STATES.FLYING;
                                this.stateTimer = 0;
                                
                                // Fly somewhere else
                                this.generatePath(
                                    Math.random() * canvas.width,
                                    100 + Math.random() * (canvas.height * 0.3)
                                );
                            }
                        }
                        break;

                    case BIRD_STATES.FLYING:
                    default:
                        // V26: Check if non-wild bird has a nest that needs maintenance
                        if (!this.isWild && this.myNest && 
                            (this.myNest.needsMaintenance || !this.myNest.isComplete) && 
                            Math.random() < 0.03) {
                            // Higher chance to check nest condition
                            if (this.checkNestCondition()) {
                                break; // Skip other flying behaviors
                            }
                        }
                        
                        // V26: Additional damping for flying state to prevent excessive acceleration
                        this.velocity.x *= 0.97; // More damping
                        this.velocity.y *= 0.97; // More damping

                        // NEW: Calm behavior - birds should land on ground when flying near it
                        const groundY = canvas.height * GROUND_HEIGHT_RATIO;
                        const distanceToGround = Math.abs(this.y - groundY);

                        if (distanceToGround < 80 && Math.random() < 0.002) { // Slightly increased frequency for more ground activity
                            // Land on ground and rest/hop - prefer landing under trees
                            let landX = this.x + (Math.random() - 0.5) * 50;

                            // Check if there's a tree nearby to land under
                            const nearbyTree = trees.find(tree =>
                                Math.abs(tree.x - this.x) < 150 && tree.health > 30
                            );

                            if (nearbyTree && Math.random() < 0.7) { // 70% chance to prefer tree
                                // Land under the tree for shade/shelter
                                landX = nearbyTree.x + (Math.random() - 0.5) * 60;
                                debugLog(`Bird choosing to land under tree for ground rest`);
                            }

                            this.path = [
                                { x: this.x, y: this.y },
                                { x: landX, y: groundY + 40 } // Increased from +20 to +40
                            ];
                            this.pathIndex = 0;
                            this.intendToHop = true;
                            this.hopData = null;
                            debugLog(`Bird landing on ground for calm behavior at (${landX}, ${groundY + 40})`);
                        }

                        // If we have a path, follow it
                        if (this.path && this.path.length > 0 && this.pathIndex < this.path.length) {
                            const waypoint = this.path[this.pathIndex];
                            const waypointDist = distance(this.x, this.y, waypoint.x, waypoint.y);
                            
                            if (waypointDist < 10) {
                                // Reached waypoint, move to next
                                this.pathIndex++;
                                debugLog(`Bird reached waypoint ${this.pathIndex - 1} of ${this.path.length}, moving to next`);
                                
                                

                               // If reached final waypoint, clear path
if (this.pathIndex >= this.path.length) {
    // Check if we intended to hop
    if (this.intendToHop && Math.abs(this.y - (canvas.height * GROUND_HEIGHT_RATIO + 40)) < 50) { // Increased tolerance
        // Ensure we're on/below the ground line (can hop into grass) - deeper for more ground presence
        this.y = canvas.height * GROUND_HEIGHT_RATIO + 40; // Increased from +20 to +40
        this.velocity = { x: 0, y: 0 }; // Full stop

        // IMPORTANT: Transition to hopping state
        this.state = BIRD_STATES.HOPPING;
        this.stateTimer = 0;
        this.intendToHop = false;
        this.hopData = null; // Force fresh initialization

        debugLog(`Bird reached ground and transitioning to hopping state at (${this.x}, ${this.y})`);
    } else {
        // Normal path completion or not close enough to ground
        this.path = [];
        this.pathIndex = 0;
        this.intendToHop = false; // Reset intention if we didn't transition
    }
}
                            } else {
                                // Move toward waypoint
                                const dx = waypoint.x - this.x;
                                const dy = waypoint.y - this.y;
                                const dir = normalize(dx, dy);
                                
                                // Adjust speed based on distance
                                const speedFactor = waypointDist < 30 ? 
                                    0.3 + waypointDist / 30 * 0.7 : 1.0;
                                
                                this.applyForce({ 
                                    x: dir.x * 0.01 * speedFactor, // Reduced from 0.02
                                    y: dir.y * 0.005 * speedFactor // Reduced from 0.01
                                });
                                
                                // Face the direction of movement when significant
                                if (Math.abs(dx) > 2) { // More sensitive direction change
                                    this.direction = dx > 0 ? 1 : -1;
                                }
                            }
                        } else {
                            // No path, just fly naturally
                            // Apply a small random force
                            if (Math.random() < 0.1) {
                                this.applyForce({ 
                                    x: (Math.random() - 0.5) * 0.02,
                                    y: (Math.random() - 0.5) * 0.01
                                });
                            }
                            
                            // Apply a slight gravity
                            this.applyForce({ x: 0, y: GRAVITY * 0.5 });
                            
                            // Check for state transitions
                            if (this.stateTimer > Math.max(MIN_STATE_DURATION, BIRD_STATE_DURATION.FLYING)) {
                                // Choose a new random activity
                                const r = Math.random();
                                
                                if (this.hunger > HUNGER_CRITICAL_THRESHOLD - 50) {
                                    // Always find food if hungry
                                    this.findFoodSource();
                                } else if (!this.isWild && !this.myNest && twigs.length > 0 && r < 0.1) {
                                    // Find building materials
                                    this.findTwigs();
                                } else if (!this.isWild && Math.random() < 0.3 && this.materialsHeld === 0) {
                                    // Add chance to build birdhouse
                                    this.findOrCreateBirdhouse();


                                    
                                } 
                                
                                
                                else if (!this.isWild && Math.random() < 0.1) {
        this.findBirdhouse();
    }
                                
                                
                                else if (r < BIRD_STATE_PREFERENCES.PERCHING) { // Significantly increased - 55% chance
                                    // Try to perch (much more likely now)
                                    this.findPerch();
           
    
                                } else if (r < BIRD_STATE_PREFERENCES.PERCHING + BIRD_STATE_PREFERENCES.FEEDING) {
   // Go to ground to forage (below ground line to reach worms/branches)
   // Reuse groundY from earlier in update() - just reference it
   const targetX = Math.random() * canvas.width;
   const forageGroundY = canvas.height * GROUND_HEIGHT_RATIO + 20;

   // Very high chance to hop on ground (increased from 0.95 to 0.98)
   if (Math.random() < 0.98) {
       // Create a direct path to ground
       this.path = [
           { x: this.x, y: this.y }, // Current position
           { x: targetX, y: forageGroundY } // Direct to ground
       ];
       this.pathIndex = 0;

       // Set flag to mark for hopping once we reach ground
       this.intendToHop = true;

       // Clear any existing hop data to ensure fresh start
       this.hopData = null;

       debugLog(`Bird flying directly to ground at (${targetX}, ${forageGroundY}) to hop`);
   }

                                } else {
                                    // Go to idle state
                                    this.state = BIRD_STATES.IDLE;
                                    this.stateTimer = 0;
                                    
                                    // Random horizontal force
                                    this.applyForce({ 
                                        x: (Math.random() - 0.5) * 0.1,
                                        y: 0
                                    });
                                }
                            }
                        }
                        break;







                    

                        case BIRD_STATES.HOPPING:
    // CRITICAL FIX: Immediately verify and enforce ground position (allow hopping below ground into grass)
    // Use bird's individual groundDepth for depth perception (some birds appear in foreground)
    const birdGroundY = canvas.height * GROUND_HEIGHT_RATIO + 40 + this.groundDepth;
    if (Math.abs(this.y - birdGroundY) > 35) { // Increased tolerance for deeper ground
        debugLog(`Fixing bird position in hopping state: ${this.y} → ${birdGroundY}`);
        this.y = birdGroundY;
        this.velocity = { x: 0, y: 0 };
    }

    // Define hopping ground level once to ensure consistency (below ground line for worms/branches) - deeper for better ground presence
    const hoppingGroundY = birdGroundY;

    // Only stay in hopping state for a reasonable duration
    if (this.stateTimer < BIRD_STATE_DURATION.HOPPING) {
        // Initialize hopping properties if not present
        if (!this.hopData) {
            // Set up structured hopping with enforced ground time
            this.hopData = {
                phase: "ground",         // "ground" or "hop"
                phaseTimer: 0,           // Time in current phase
                hopHeight: 0,            // Current height of hop
                nextHopDelay: 2000,      // Time between hops (2 seconds)
                baseY: hoppingGroundY,   // Store exact ground level
                hopDistance: 0,          // Distance to move in this hop
                lastX: this.x            // Track position to detect external changes
            };

            // Force initial position
            this.y = hoppingGroundY;
            this.velocity.y = 0;
            
            debugLog("HOPPING STATE INITIALIZED - forcing ground position");
        }
        
        // Update phase timer
        this.hopData.phaseTimer += deltaTime;
        
        // Check if something else moved the bird - if so, reset
        if (Math.abs(this.x - this.hopData.lastX) > 10 && this.hopData.phase === "ground") {
            debugLog("WARNING: Bird position changed externally during hopping");
            this.hopData.lastX = this.x;
        }
        
        // Clear all velocity and acceleration influences
        this.velocity.y = 0;
        this.acceleration.y = 0;
        
        // CONTROLLED STATE MACHINE
        if (this.hopData.phase === "ground") {
            // Keep bird FIRMLY on ground during ground phase
            this.y = hoppingGroundY;
            
            // Slow x movement while on ground
            this.velocity.x *= 0.9;
            
            // Occasional pecking
            if (Math.random() < 0.1) {
                this.pecking = !this.pecking;
            }
            
            // Check if time to hop - guaranteed minimum ground time
            if (this.hopData.phaseTimer > this.hopData.nextHopDelay) {
                // Transition to hop phase
                this.hopData.phase = "hop";
                this.hopData.phaseTimer = 0;
                this.hopData.maxHopHeight = 15 + Math.random() * 10; // 8-12px hop height
                this.hopData.hopDuration = 500; // 0.5 second hop
                
                // Determine hop direction and distance
                if (Math.random() < 0.2) {
                    this.direction *= -1;
                }
                
                // Set distance to hop - small horizontal movement
                this.hopData.hopDistance = this.direction * (10 + Math.random() * 15);
                
                this.pecking = false; // Stop pecking during hop
                
                debugLog(`Bird starting hop with height ${this.hopData.maxHopHeight}px`);
            }
        } else if (this.hopData.phase === "hop") {
            // In hop phase - follow a precise arc
            const hopProgress = Math.min(1, this.hopData.phaseTimer / this.hopData.hopDuration);
            
            // Sinusoidal hop height - max at middle of hop
            const normalizedHeight = Math.sin(hopProgress * Math.PI);
            this.hopData.hopHeight = this.hopData.maxHopHeight * normalizedHeight;
            
            // Apply precise position with arc motion
            this.y = hoppingGroundY - this.hopData.hopHeight;

            // Move horizontally during hop - linear movement
            this.x = this.hopData.lastX + (this.hopData.hopDistance * hopProgress);

            // Remember position to prevent external interference
            if (hopProgress >= 1) {
                // Hop complete - back to ground
                this.hopData.phase = "ground";
                this.hopData.phaseTimer = 0;
                this.hopData.lastX = this.x;
                this.hopData.nextHopDelay = 1500 + Math.random() * 1500; // 1.5-3s ground time (increased from 0.8-1.6s)

                // Force ground position to prevent any drift
                this.y = hoppingGroundY;
                this.velocity.y = 0;
                
                // Start pecking again
                this.pecking = true;
                
                debugLog("Bird finished hop, returning to ground");
            }
        }
        
        // Check for food while hopping
        let foundFood = false;
        const hopFoodRadius = 25;
        
        for (let i = foodItems.length - 1; i >= 0; i--) {
            const food = foodItems[i];
            if (distance(this.x, this.y, food.x, food.y) < hopFoodRadius) {
                foodItems.splice(i, 1);
                this.hunger = Math.max(0, this.hunger - 100);
                foundFood = true;
                debugLog(`Bird found and ate food while hopping.`);
                break;
            }
        }
        
        if (!foundFood) {
            for (let i = worms.length - 1; i >= 0; i--) {
                const worm = worms[i];
                if (distance(this.x, this.y, worm.x, worm.y) < hopFoodRadius) {
                    worms.splice(i, 1);
                    this.hunger = Math.max(0, this.hunger - 150);
                    foundFood = true;
                    debugLog(`Bird found and ate worm while hopping.`);
                    break;
                }
            }
        }
        
        // Check for threats while hopping - allow state to be interrupted for safety
        const nearbyRat = rats.find(rat => 
            distance(this.x, this.y, rat.x, rat.y) < 50
        );
        
        if (nearbyRat) {
            // Flee from rat
            this.flee(nearbyRat.x, nearbyRat.y);
            debugLog(`Bird interrupted hopping to flee from rat`);
            this.hopData = null; // Reset hopping data
            break;
        }
    }
    
    // Only exit hopping after extended time AND when on ground
    if (this.stateTimer > BIRD_STATE_DURATION.HOPPING) {
        if (!this.hopData || this.hopData.phase === "ground") {
            // Exit to flying or perching (don't reset timer - let it naturally end)
            if (Math.random() < 0.7) {
                this.findPerch();
            } else {
                this.state = BIRD_STATES.IDLE;
                this.stateTimer = 0;
                debugLog("Bird finished hopping, now idle");
            }
        }
        // If mid-hop, let it finish the current hop naturally without resetting timer
    }
    break;

                    case BIRD_STATES.MOBBING:
                        // Update mobbing behavior
                        this.updateMobbing(deltaTime);

                        // Follow path if one exists
                        if (this.path && this.path.length > 0 && this.pathIndex < this.path.length) {
                            const currentTarget = this.path[this.pathIndex];
                            const dist = distance(this.x, this.y, currentTarget.x, currentTarget.y);

                            if (dist < 20) {
                                this.pathIndex++;
                            } else {
                                const dx = currentTarget.x - this.x;
                                const dy = currentTarget.y - this.y;
                                const dir = normalize(dx, dy);
                                this.applyForce({ x: dir.x * 0.04, y: dir.y * 0.04 });
                            }
                        }
                        break;

                    case BIRD_STATES.PECKING:
                        // Update pecking behavior
                        this.updatePecking(deltaTime);

                        // Sentinel doesn't peck
                        if (this.isSentinel) {
                            this.pecking = false;
                            // Scan for threats
                            if (Math.random() < 0.02) {
                                this.chirp(CHIRP_TYPES.SOCIAL, 0.5);
                            }
                        } else {
                            // Actually peck
                            this.pecking = this.peckAnimationPhase > 0;
                        }

                        // Stay on ground
                        this.y = canvas.height * GROUND_HEIGHT_RATIO;
                        this.velocity.y = 0;

                        // Check if should make food call
                        const nearbyFood = foodItems.find(f =>
                            distance(this.x, this.y, f.x, f.y) < 30
                        );
                        if (nearbyFood && Math.random() < 0.02) {
                            this.makeFoodCall(nearbyFood.x, nearbyFood.y);
                        }

                        // Chance to stop pecking
                        if (this.stateTimer > 5000 || this.hunger < 100) {
                            this.state = BIRD_STATES.FLYING;
                            this.isOnGround = false;
                        }
                        break;

                    case BIRD_STATES.SENTINEL:
                        // Sentinel stays alert, doesn't feed
                        this.pecking = false;
                        this.isOnGround = true;
                        this.y = canvas.height * GROUND_HEIGHT_RATIO;
                        this.velocity = { x: 0, y: 0 };

                        // Scan for threats
                        if (Math.random() < 0.05) {
                            // Check for predators
                            for (const owl of owls) {
                                if (distance(this.x, this.y, owl.x, owl.y) < 300) {
                                    // Alert call
                                    this.chirp(CHIRP_TYPES.ALERT, 1.5);
                                    this.recordDanger(owl.x, owl.y, 'owl');
                                    // Alert flockmates
                                    const flockmates = this.getFlockmates();
                                    flockmates.forEach(b => {
                                        if (b.state === BIRD_STATES.PECKING) {
                                            b.flee(owl.x, owl.y);
                                        }
                                    });
                                    break;
                                }
                            }
                        }
                        break;

                    case BIRD_STATES.TERRITORIAL_DISPLAY:
                        // Territorial display behavior
                        if (this.isOnGround) {
                            // Ground display - hopping toward rival
                            if (Math.random() < 0.3) {
                                this.pecking = true;
                            }
                        }

                        // Occasional territorial chirps
                        if (Math.random() < 0.05) {
                            this.chirp(CHIRP_TYPES.TERRITORIAL, 0.8);
                        }

                        // End display after duration
                        if (this.stateTimer > TERRITORIAL_DISPLAY_DURATION) {
                            // Determine winner based on aggression and flock support
                            const flockSupport = this.getFlockmates().filter(b =>
                                distance(b.x, b.y, this.x, this.y) < 150
                            ).length;

                            if (flockSupport > 0 || this.aggression > 0.7) {
                                // Victory!
                                this.chirp(CHIRP_TYPES.VICTORY, 1.2);
                                debugLog(`${this.birdType.name} won territorial dispute!`);
                            } else {
                                // Defeat
                                this.defeatedRecently = true;
                                this.defeatTimer = 0;
                                debugLog(`${this.birdType.name} lost territorial dispute`);
                            }

                            this.state = BIRD_STATES.FLYING;
                        }
                        break;

                    case BIRD_STATES.FLEEING_GROUND:
                        // Ground birds flee slower - hop launch delay
                        if (this.stateTimer < GROUND_ESCAPE_DELAY) {
                            // Delay before takeoff
                            this.y = canvas.height * GROUND_HEIGHT_RATIO;
                            this.velocity.y = 0;
                        } else {
                            // Now take off
                            this.state = BIRD_STATES.FLEEING;
                            this.velocity.y = -this.baseSpeed * 2;
                        }
                        break;

}







                
                // Update position with velocity
                this.velocity.x += this.acceleration.x * (deltaTime / 16);
                this.velocity.y += this.acceleration.y * (deltaTime / 16);
                
                // V26: Limit speed with more aggressive cap for smoother movement
                const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
                if (speed > MAX_SPEED * 0.8) { // 20% lower speed cap
                    this.velocity.x = (this.velocity.x / speed) * MAX_SPEED * 0.8;
                    this.velocity.y = (this.velocity.y / speed) * MAX_SPEED * 0.8;
                }
                
                // Update position
                this.x += this.velocity.x * (deltaTime / 16);
                this.y += this.velocity.y * (deltaTime / 16);
                
                // Ensure birds always face their movement direction when moving significantly
                if (Math.abs(this.velocity.x) > 0.2) { // Only change direction when there's meaningful horizontal movement
                    this.direction = this.velocity.x > 0 ? 1 : -1;
                }
                
                // Apply position constraints
                validatePosition(this);
                
                return false; // Bird continues to exist
            }

            // V26: Enhanced bird drawing with outlined wings
            draw() {
                const sizeMultiplier = this.birdType.sizeMultiplier;
                
                // Determine if wings should be flapping based on state
                const isFlapping = 
                    this.state === BIRD_STATES.FLYING || 
                    this.state === BIRD_STATES.FLEEING || 
                    Math.abs(this.velocity.x) > 0.5 || 
                    Math.abs(this.velocity.y) > 0.5;
                
                // // Calculate position adjustments for flapping/gliding/hopping motion
    let yOffset;
    
    if (this.state === BIRD_STATES.HOPPING) {
        // Hopping creates a bouncy motion - more pronounced up and down
        yOffset = Math.abs(Math.sin(this.wingFlap * 1.5)) * 3;
    } else {
        // Regular flight bobbing
        yOffset = Math.sin(this.wingFlap * 0.5) * (isFlapping ? 1.5 : 0.3); // Increased from 1.0/0.2
    }
                
                // Wing position and spread - adjusted for more visibility
                const wingSpread = isFlapping ? 
                    Math.abs(Math.sin(this.wingFlap)) * this.birdType.wingFlapAmplitude * 1.2 : // Increased by 20%
                    this.birdType.glideRatio * 1.2; // Increased by 20%
                    
                const wingY = isFlapping ? Math.cos(this.wingFlap) * 5 : 0; // Increased from 2 to 3
                
                // Draw body
                 // MODIFY THIS LINE to use mushroom color:
    ctx.fillStyle = mushroomMode ? getMushroomColor(this.birdType.bodyColor) : this.birdType.bodyColor;
    ctx.beginPath();
    ctx.ellipse(
        this.x, 
        this.y + yOffset, 
        10 * sizeMultiplier, 
        7 * sizeMultiplier, 
        0, 0, Math.PI * 2
    );
    ctx.fill();
                
                // Draw the belly
              // MODIFY THIS LINE to use mushroom color:
    ctx.fillStyle = mushroomMode ? getMushroomColor(this.birdType.bellyColor) : this.birdType.bellyColor;
    ctx.beginPath();
    ctx.ellipse(
        this.x, 
        this.y + 3 * sizeMultiplier + yOffset, 
        8 * sizeMultiplier, 
        5 * sizeMultiplier, 
        0, 0, Math.PI
    );
    ctx.fill();
                
               // MODIFY THIS LINE to use mushroom color:
    ctx.fillStyle = mushroomMode ? getMushroomColor(this.birdType.bodyColor) : this.birdType.bodyColor;
    ctx.beginPath();
    if (this.direction > 0) {
        ctx.moveTo(this.x - 10 * sizeMultiplier, this.y + yOffset);
        ctx.lineTo(this.x - 16 * sizeMultiplier, this.y - 2 * sizeMultiplier + yOffset);
        ctx.lineTo(this.x - 16 * sizeMultiplier, this.y + 2 * sizeMultiplier + yOffset);
    } else {
        ctx.moveTo(this.x + 10 * sizeMultiplier, this.y + yOffset);
        ctx.lineTo(this.x + 16 * sizeMultiplier, this.y - 2 * sizeMultiplier + yOffset);
        ctx.lineTo(this.x + 16 * sizeMultiplier, this.y + 2 * sizeMultiplier + yOffset);
    }
    ctx.fill();

    // ADD YOUR RAINBOW TAIL CODE RIGHT HERE, after the normal tail is drawn:
    if (mushroomMode) {
        // Draw a more elaborate, colorful tail
        const tailLength = 20 * sizeMultiplier;
        const segments = 5;
        
        for (let i = 0; i < segments; i++) {
            // Each segment gets a different color
            const hue = (this.wingFlap * 20 + i * 30) % 360;
            ctx.fillStyle = `hsl(${hue}, 90%, 60%)`;
            
            // Calculate position based on segment
            const segmentSize = (segments - i) / segments;
            const waveOffset = Math.sin(this.wingFlap + i) * 5;
            
            if (this.direction > 0) {
                ctx.beginPath();
                ctx.ellipse(
                    this.x - (10 + i * 3) * sizeMultiplier,
                    this.y + yOffset + waveOffset,
                    tailLength * 0.3 * segmentSize,
                    tailLength * 0.15 * segmentSize,
                    Math.PI / 3,
                    0, Math.PI * 2
                );
            } else {
                ctx.beginPath();
                ctx.ellipse(
                    this.x + (10 + i * 3) * sizeMultiplier,
                    this.y + yOffset + waveOffset,
                    tailLength * 0.3 * segmentSize,
                    tailLength * 0.15 * segmentSize,
                    -Math.PI / 3,
                    0, Math.PI * 2
                );
            }
            ctx.fill();
        }
    }

    if (mushroomMode) {
    // Rainbow outline for wings in mushroom mode
    ctx.strokeStyle = `hsl(${(colorCycleTimer / 100) % 360}, 100%, 70%)`;
    ctx.lineWidth = 2;
    
    // Pulsing glow effect based on time
    const glowSize = 3 + Math.sin(colorCycleTimer / 500) * 2;
    ctx.shadowColor = `hsl(${(colorCycleTimer / 80 + 30) % 360}, 100%, 60%)`;
    ctx.shadowBlur = glowSize;
} else {
    // Regular style for non-mushroom mode
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 0.02;
    ctx.shadowBlur = 0;
}
                // Draw wings with improved visibility, downward angle, and more volume
                ctx.strokeStyle = '#000000'; // Black outline
                ctx.lineWidth = .02;

                if (this.direction > 0) {
                    // Facing right - left wing outline
                    ctx.beginPath();
                    ctx.moveTo(this.x - 5, this.y + yOffset); // Wider at body
                    // Curve with more downward angle and volume
                    ctx.quadraticCurveTo(
                        this.x - 8 * wingSpread, 
                        this.y + 2 * wingSpread + wingY, // Adjusted for more volume
                        this.x - 10 * wingSpread * sizeMultiplier, 
                        this.y + 3 * sizeMultiplier + wingY  // Top edge of wing
                    );
                    // Fatter wing tip - more separation between points
                    ctx.lineTo(
                        this.x - 9 * wingSpread * sizeMultiplier,
                        this.y + 9 * sizeMultiplier + wingY // Increased separation from 7 to 9
                    );
                    ctx.quadraticCurveTo(
                        this.x - 7 * wingSpread,
                        this.y + 7 * wingSpread + wingY, // Increased from 5 to 7 for fuller shape
                        this.x - 5,
                        this.y + 3 + yOffset // Increased from 2 to 3 for fuller connection
                    );
                    ctx.closePath();
                    ctx.stroke(); // Draw outline
                    
                    // Now fill the wing
                    ctx.fillStyle = this.birdType.wingColor;
                    ctx.fill();
                } else {
                    // Similar changes for left-facing birds
                    ctx.beginPath();
                    ctx.moveTo(this.x + 5, this.y + yOffset);
                    ctx.quadraticCurveTo(
                        this.x + 8 * wingSpread,
                        this.y + 2 * wingSpread + wingY, // Adjusted for more volume
                        this.x + 10 * wingSpread * sizeMultiplier,
                        this.y + 3 * sizeMultiplier + wingY // Top edge of wing
                    );
                    ctx.lineTo(
                        this.x + 9 * wingSpread * sizeMultiplier,
                        this.y + 9 * sizeMultiplier + wingY // Increased separation for fatter tip
                    );
                    ctx.quadraticCurveTo(
                        this.x + 7 * wingSpread,
                        this.y + 7 * wingSpread + wingY, // Increased for fuller shape
                        this.x + 5,
                        this.y + 3 + yOffset // Increased for fuller connection
                    );
                    ctx.closePath();
                    ctx.stroke();
                    ctx.fillStyle = this.birdType.wingColor;
                    ctx.fill();
                }
                
              // Draw the head
ctx.fillStyle = mushroomMode ? getMushroomColor(this.birdType.bodyColor) : this.birdType.bodyColor;
ctx.beginPath();
ctx.arc(
    this.x + (this.direction * 8 * sizeMultiplier), 
    this.y - 2 * sizeMultiplier + yOffset, 
    6 * sizeMultiplier, 
    0, Math.PI * 2
);
ctx.fill();
                
                // Draw beak
                ctx.fillStyle = this.pecking ? '#FF8800' : '#FFAA00';
                ctx.beginPath();
                if (this.direction > 0) {
                    ctx.moveTo(this.x + 12 * sizeMultiplier, this.y - 3 * sizeMultiplier + yOffset);
                    ctx.lineTo(this.x + 18 * sizeMultiplier, this.y - 2 * sizeMultiplier + yOffset);
                    ctx.lineTo(this.x + 12 * sizeMultiplier, this.y + yOffset);
                } else {
                    ctx.moveTo(this.x - 12 * sizeMultiplier, this.y - 3 * sizeMultiplier + yOffset);
                    ctx.lineTo(this.x - 18 * sizeMultiplier, this.y - 2 * sizeMultiplier + yOffset);
                    ctx.lineTo(this.x - 12 * sizeMultiplier, this.y + yOffset);
                }
                ctx.fill();
                
                // Eyes with pupil and highlight for cuter appearance
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(
                    this.x + (this.direction * 8 * sizeMultiplier), 
                    this.y - 3 * sizeMultiplier + yOffset, 
                    2 * sizeMultiplier,
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Add white highlight to eyes for cute effect
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(
                    this.x + (this.direction * 8.5 * sizeMultiplier), 
                    this.y - 3.5 * sizeMultiplier + yOffset, 
                    0.8 * sizeMultiplier,
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Draw carried twig if holding materials
                if (this.materialsHeld > 0) {
                    ctx.save();
                    ctx.translate(
                        this.x + (this.direction * 15 * sizeMultiplier), 
                        this.y - 2 * sizeMultiplier + yOffset
                    );
                    ctx.rotate(this.direction * Math.PI * 0.25);
                    
                    if (this.hasSpecialTwig) {
                        ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
                        ctx.shadowBlur = 3;
                        ctx.fillStyle = '#D2B48C'; // Lighter wood color
                    } else {
                        ctx.fillStyle = '#8B4513';
                    }
                    
                    ctx.fillRect(-2, -2, 15, 2);
                    ctx.restore();
                }
                
                // Debug info
                if (debugVisuals) {
                 // Vision radius
ctx.strokeStyle = 'rgba(255, 255, 0, 0.4)';  // Brighter yellow with higher opacity
ctx.lineWidth = 2;  // Make the line thicker
ctx.beginPath();
ctx.arc(this.x, this.y, BIRD_VISION_RADIUS, 0, Math.PI * 2);
ctx.stroke();
                    
                    // Hunger bar
                    const hungerRatio = this.hunger / BIRD_MAX_HUNGER;
                    ctx.fillStyle = hungerRatio > 0.7 ? 'red' : (hungerRatio > 0.4 ? 'yellow' : 'green');
                    ctx.fillRect(this.x - 10, this.y - 15, 20 * hungerRatio, 3);
                    
                    // State text
                    ctx.fillStyle = 'white';
                    ctx.font = '8px Arial';
                    ctx.fillText(this.state, this.x - 10, this.y - 20);
                }
            }
        }

        // V26: Modified Rat class with reduced spawn rate and king formation chance
        class Rat {
            constructor(x, y, isRatKing = false) {
                this.x = x;
                this.y = y;
                this.direction = x < canvas.width / 2 ? 1 : -1;
                this.velocity = { x: 0, y: 0 };
                this.acceleration = { x: 0, y: 0 };
                this.speed = 0.7;
                this.state = 'wandering';
                this.stateTimer = 0;
                this.targetX = null;
                this.isRatKing = isRatKing;
                this.nestTarget = null;
                this.wanderTimer = 0;
                this.bobTimer = 0; // For animation

                // Enhanced ground exploration: rats can move in grass depth (0-30px below ground)
                this.groundDepth = Math.random() * 30;
                this.targetDepth = this.groundDepth; // Target depth for exploration
                this.exploreTimer = 0; // Timer for changing exploration depth

                // For rat king
                if (isRatKing) {
                    this.kingSize = 1.5;
                    this.ratCount = 3 + Math.floor(Math.random() * 3); // 3-5 rats in the king
                    this.rattiness = Math.random() * 0.5 + 0.7; // Higher value = more chaotic
                }
            }
            
            applyForce(force) {
                this.acceleration.x += force.x;
                this.acceleration.y += force.y;
            }
            
            nearestNest() {
                let closest = null;
                let closestDist = Infinity;
                
                for (const nest of nests) {
                    const dist = distance(this.x, this.y, nest.x, nest.y);
                    if (dist < closestDist && nest.isComplete) {
                        closestDist = dist;
                        closest = nest;
                    }
                }
                
                return closestDist < 100 ? closest : null;
            }
            
            update(deltaTime) {
                this.stateTimer += deltaTime;
                this.bobTimer += deltaTime * 0.01;
                
                // Reset acceleration each frame
                this.acceleration = { x: 0, y: 0 };
                
                // Rats are scared of birds nearby
                const nearbyBird = birds.find(bird => 
                    distance(this.x, this.y, bird.x, bird.y) < 50
                );
                
                if (nearbyBird && !this.isRatKing) {
                    // Run away from bird
                    this.state = 'fleeing';
                    this.stateTimer = 0;
                    
                    const fleeDirection = this.x < nearbyBird.x ? -1 : 1;
                    this.direction = fleeDirection;
                    
                    this.applyForce({ 
                        x: this.direction * 0.04, 
                        y: 0 
                    });
                }
                
                switch (this.state) {
                    case 'wandering':
                        this.wanderTimer += deltaTime;
                        this.exploreTimer += deltaTime;

                        // Enhanced ground exploration: change target depth every 3-5 seconds
                        if (this.exploreTimer > 3000 + Math.random() * 2000) {
                            this.targetDepth = Math.random() * 30; // New depth to explore
                            this.exploreTimer = 0;
                        }

                        // Smoothly move toward target depth
                        const groundBase = canvas.height * GROUND_HEIGHT_RATIO;
                        const targetY = groundBase + this.targetDepth;
                        const depthDiff = targetY - this.y;
                        if (Math.abs(depthDiff) > 2) {
                            this.applyForce({
                                x: 0,
                                y: depthDiff * 0.001 // Gentle vertical movement
                            });
                        }

                        // V26: Reduced nest raiding chance for better ecosystem balance
                        if (!this.nestTarget && Math.random() < 0.007) { // Reduced from 0.01
                            const nearestNest = this.nearestNest();
                            if (nearestNest && !nearestNest.ratOccupied) {
                                this.nestTarget = nearestNest;
                                this.state = 'raiding';
                                this.stateTimer = 0;
                                debugLog(`Rat targeting nest at (${nearestNest.x}, ${nearestNest.y})`);
                            }
                        }

                        // Move in current direction (horizontal)
                        this.applyForce({
                            x: this.direction * 0.01,
                            y: 0
                        });

                        // Random direction changes
                        if (Math.random() < 0.01) {
                            this.direction *= -1;
                        }

                        // Random stops
                        if (Math.random() < 0.005) {
                            this.state = 'stopped';
                            this.stateTimer = 0;
                        }
                        
                        // Leave after a longer while or if off-screen
                        if ((this.wanderTimer > 40000) || // Increased from 20000
                            (this.direction < 0 && this.x < -50) || 
                            (this.direction > 0 && this.x > canvas.width + 50)) {
                            return true; // Rat should be removed
                        }
                        break;
                        
                    case 'stopped':
                        // Stand still with slight movement
                        this.velocity.x *= 0.9;
                        
                        if (Math.random() < 0.05) {
                            this.applyForce({ 
                                x: (Math.random() - 0.5) * 0.01, 
                                y: 0 
                            });
                        }
                        
                        // Resume wandering after a pause
                        if (this.stateTimer > 3000 + Math.random() * 2000) {
                            this.state = 'wandering';
                            this.stateTimer = 0;
                        }
                        break;
                        
                    case 'fleeing':
                        // Run away fast
                        this.applyForce({ 
                            x: this.direction * 0.02, 
                            y: 0 
                        });
                        
                        // Return to wandering after fleeing
                        if (this.stateTimer > 3000) {
                            this.state = 'wandering';
                            this.stateTimer = 0;
                        }
                        break;
                        
                    case 'raiding':
                        if (!this.nestTarget || nests.indexOf(this.nestTarget) === -1) {
                            this.nestTarget = null;
                            this.state = 'wandering';
                            this.stateTimer = 0;
                            break;
                        }
                        
                        const nestDist = distance(this.x, this.y, this.nestTarget.x, this.nestTarget.y);
                        
                        if (nestDist < 10) {
                            // At the nest, attempt to damage it
                            if (Math.random() < 0.08) { // Reduced from 0.1 - less aggressive damage
                                const destroyed = this.nestTarget.damage(8); // Reduced from 10
                                debugLog(`Rat damaged nest: ${destroyed ? 'Significant damage!' : 'Minor damage'}`);
                                
                                // Occupy nest if it's really damaged
                                if (this.nestTarget.health < 30 && Math.random() < 0.25) { // Reduced from 0.3
                                    this.nestTarget.ratOccupied = true;
                                    debugLog(`Rat occupied damaged nest!`);
                                }
                            }
                            
                            // Stand still with slight movement
                            this.velocity.x *= 0.8;
                            
                            // Return to wandering after a while
                            if (this.stateTimer > 10000 || this.nestTarget.ratOccupied) {
                                this.state = 'wandering';
                                this.stateTimer = 0;
                                this.nestTarget = null;
                            }
                        } else {
                            // Move toward nest
                            const dx = this.nestTarget.x - this.x;
                            this.direction = dx > 0 ? 1 : -1;
                            
                            this.applyForce({ 
                                x: this.direction * 0.015, 
                                y: 0 
                            });
                            
                            // Give up after trying too long
                            if (this.stateTimer > 15000) {
                                this.state = 'wandering';
                                this.stateTimer = 0;
                                this.nestTarget = null;
                            }
                        }
                        break;
                }
                
                // Update position with velocity
                this.velocity.x += this.acceleration.x * (deltaTime / 16);
                this.velocity.y += this.acceleration.y * (deltaTime / 16);
                
                // Limit speed
                const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
                if (speed > this.speed) {
                    this.velocity.x = (this.velocity.x / speed) * this.speed;
                    this.velocity.y = (this.velocity.y / speed) * this.speed;
                }
                
                // Update position
                this.x += this.velocity.x * (deltaTime / 16);
                this.y += this.velocity.y * (deltaTime / 16);
                
                return false;
            }
            
            draw() {
                if (this.isRatKing) {
                    this.drawRatKing();
                } else {
                    this.drawRegularRat();
                }
                
                if (debugVisuals) {
                    // Vision circle
                    ctx.strokeStyle = 'rgba(200, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, RAT_VISION_RADIUS, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // State text
                    ctx.fillStyle = 'white';
                    ctx.font = '8px Arial';
                    ctx.fillText(this.state, this.x - 10, this.y - 15);
                }
            }
            
            drawRegularRat() {
                const bobAmount = Math.sin(this.bobTimer) * 2;
                
                // Body
                ctx.fillStyle = '#696969';
                ctx.beginPath();
                ctx.ellipse(
                    this.x, 
                    this.y + bobAmount, 
                    10, 
                    5, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
                
                // Tail
                ctx.strokeStyle = '#696969';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const tailWag = Math.sin(this.bobTimer * 2) * 3;
                
                if (this.direction > 0) {
                    ctx.moveTo(this.x - 8, this.y + bobAmount);
                    ctx.bezierCurveTo(
                        this.x - 20, this.y + bobAmount, 
                        this.x - 30, this.y + tailWag + bobAmount, 
                        this.x - 35, this.y + tailWag + bobAmount
                    );
                } else {
                    ctx.moveTo(this.x + 8, this.y + bobAmount);
                    ctx.bezierCurveTo(
                        this.x + 20, this.y + bobAmount, 
                        this.x + 30, this.y + tailWag + bobAmount, 
                        this.x + 35, this.y + tailWag + bobAmount
                    );
                }
                ctx.stroke();
                
                // Head
                ctx.fillStyle = '#696969';
                ctx.beginPath();
                ctx.ellipse(
                    this.x + (this.direction * 8), 
                    this.y + bobAmount, 
                    6, 
                    4, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.arc(
                    this.x + (this.direction * 10), 
                    this.y - 1 + bobAmount, 
                    1, 
                    0, Math.PI * 2
                );
                ctx.fill();
            }
            
            drawRatKing() {
                const bobAmount = Math.sin(this.bobTimer) * 2;
                
                // Draw the outline first for better visibility
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                
                // Multiple intertwined rats for the king
                for (let i = 0; i < this.ratCount; i++) {
                    const angle = (i / this.ratCount) * Math.PI * 2;
                    const rattiness = this.rattiness;
                    
                    const offsetX = Math.cos(angle) * 5 * rattiness;
                    const offsetY = Math.sin(angle) * 5 * rattiness;
                    
                    // Body outline
                    ctx.beginPath();
                    ctx.ellipse(
                        this.x + offsetX, 
                        this.y + offsetY + bobAmount, 
                        10 * this.kingSize, 
                        5 * this.kingSize, 
                        angle, 0, Math.PI * 2
                    );
                    ctx.stroke();
                    
                    // Body fill
                    ctx.fillStyle = '#4B0082'; // Darker color for rat king
                    ctx.fill();
                    
                    // Tail - intertwined in center
                    ctx.beginPath();
                    ctx.moveTo(this.x + offsetX, this.y + offsetY + bobAmount);
                    ctx.lineTo(this.x, this.y + bobAmount);
                    ctx.stroke();
                    
                    // Head outline
                    ctx.beginPath();
                    ctx.ellipse(
                        this.x + offsetX * 1.5 + (this.direction * 5), 
                        this.y + offsetY * 1.5 + bobAmount, 
                        6 * this.kingSize, 
                        4 * this.kingSize, 
                        angle, 0, Math.PI * 2
                    );
                    ctx.stroke();
                    
                    // Head fill
                    ctx.fillStyle = '#4B0082';
                    ctx.fill();
                    
                    // Glowing red eyes
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.arc(
                        this.x + offsetX * 1.5 + (this.direction * 7), 
                        this.y + offsetY * 1.5 - 1 + bobAmount, 
                        1.5 * this.kingSize, 
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
                
                // Center knot of tails
                ctx.fillStyle = '#4B0082';
                ctx.beginPath();
                ctx.arc(
                    this.x, 
                    this.y + bobAmount, 
                    5 * this.kingSize, 
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Add a crown on top for the rat king
                ctx.fillStyle = '#FFD700'; // Gold crown
                ctx.beginPath();
                ctx.moveTo(this.x - 6 * this.kingSize, this.y - 6 * this.kingSize + bobAmount);
                ctx.lineTo(this.x - 4 * this.kingSize, this.y - 10 * this.kingSize + bobAmount);
                ctx.lineTo(this.x - 2 * this.kingSize, this.y - 7 * this.kingSize + bobAmount);
                ctx.lineTo(this.x, this.y - 10 * this.kingSize + bobAmount);
                ctx.lineTo(this.x + 2 * this.kingSize, this.y - 7 * this.kingSize + bobAmount);
                ctx.lineTo(this.x + 4 * this.kingSize, this.y - 10 * this.kingSize + bobAmount);
                ctx.lineTo(this.x + 6 * this.kingSize, this.y - 6 * this.kingSize + bobAmount);
                ctx.closePath();
                ctx.fill();
                
                // Crown outline
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }



// V26: Improved Squirrel class with less frequent spawn rate
class Squirrel {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.direction = Math.random() < 0.5 ? -1 : 1;
        this.velocity = { x: 0, y: 0 };
        this.acceleration = { x: 0, y: 0 };
        this.speed = 1.2;
        this.state = 'wandering';
        this.stateTimer = 0;
        this.climbingTree = null;
        this.targetY = null;
        this.tailWobble = 0;
        this.nutCollected = false;
        this.fleeing = false;
        this.groundY = canvas.height * GROUND_HEIGHT_RATIO;
    }
    
    applyForce(force) {
        this.acceleration.x += force.x;
        this.acceleration.y += force.y;
    }
    
    nearestTree() {
        let closest = null;
        let closestDist = Infinity;
        
        for (const tree of trees) {
            const dist = distance(this.x, this.y, tree.x, this.y);
            if (dist < closestDist && dist < 100) { // Only consider trees within 100px
                closestDist = dist;
                closest = tree;
            }
        }
        
        return closest;
    }
    
    update(deltaTime) {
        this.stateTimer += deltaTime;
        this.tailWobble += 0.1 * deltaTime / 16;
        
        // Reset acceleration each frame
        this.acceleration = { x: 0, y: 0 };
        
        // Squirrels are scared of nearby birds
        const nearbyBird = birds.find(bird => 
            distance(this.x, this.y, bird.x, bird.y) < 50 &&
            bird.state !== BIRD_STATES.FLEEING
        );
        
        if (nearbyBird && this.state !== 'climbing' && !this.fleeing) {
            // Run away from bird
            this.state = 'fleeing';
            this.stateTimer = 0;
            this.fleeing = true;
            
            const fleeDirection = this.x < nearbyBird.x ? -1 : 1;
            this.direction = fleeDirection;
            
            debugLog(`Squirrel fleeing from bird at (${nearbyBird.x}, ${nearbyBird.y})`);
        }
        
        switch (this.state) {
            case 'wandering':
                // Check for trees to climb - reduced chance
                if (!this.fleeing && Math.random() < 0.003) { // Reduced from 0.005
                    const nearestTree = this.nearestTree();
                    if (nearestTree && trees.indexOf(nearestTree) !== -1) { // Verify tree exists
                        this.climbingTree = nearestTree;
                        this.state = 'climbing';
                        this.stateTimer = 0;
                        debugLog(`Squirrel climbing tree at (${nearestTree.x})`);
                    }
                }
                
                // Move along ground
                this.applyForce({ 
                    x: this.direction * 0.02, 
                    y: 0 
                });
                
                // Random direction changes
                if (Math.random() < 0.01) {
                    this.direction *= -1;
                }
                
                // Random stops
                if (Math.random() < 0.02) {
                    this.state = 'foraging';
                    this.stateTimer = 0;
                }

                // Allow exploring slightly below ground to reach worms/branches
                this.y = Math.min(this.y, this.groundY + 15); // Can go 15px below ground line
                
                // Leave after a while
                if (this.stateTimer > 60000 || 
                    (this.direction < 0 && this.x < -30) || 
                    (this.direction > 0 && this.x > canvas.width + 30)) {
                    
                    if (this.x < -30 || this.x > canvas.width + 30) {
                        this.state = 'leaving';
                    } else {
                        this.state = 'leaving'; // go offscreen intentionally
                        this.direction = Math.random() < 0.5 ? -1 : 1;
                    }
                    debugLog(`Squirrel leaving scene in direction: ${this.direction}`);
                }
                break;
                
            case 'foraging':
                // Allow squirrels to explore below ground while foraging for worms/branches
                this.y = Math.min(this.y, this.groundY + 15); // Can go 15px below ground line
                
                // Bobbing and foraging motions
                this.velocity.x *= 0.9;
                
                if (Math.random() < 0.05) {
                    this.applyForce({ 
                        x: (Math.random() - 0.5) * 0.02, 
                        y: 0 
                    });
                    
                    // Flip direction occasionally while foraging
                    if (Math.random() < 0.1) {
                        this.direction *= -1;
                    }
                }
                
                // Find nuts occasionally
                if (!this.nutCollected && Math.random() < 0.001) {
                    this.nutCollected = true;
                    debugLog(`Squirrel found a nut!`);
                }
                
                // Resume wandering after foraging
                if (this.stateTimer > 5000) {
                    if (this.nutCollected && Math.random() < 0.7) {
                        // More likely to climb trees with nuts
                        const nearestTree = this.nearestTree();
                        if (nearestTree && trees.indexOf(nearestTree) !== -1) { // Verify tree exists
                            this.climbingTree = nearestTree;
                            this.state = 'climbing';
                            this.stateTimer = 0;
                            debugLog(`Squirrel climbing tree with nut`);
                        } else {
                            this.state = 'wandering';
                            this.stateTimer = 0;
                        }
                    } else {
                        this.state = 'wandering';
                        this.stateTimer = 0;
                    }
                }
                break;
                
            case 'climbing':
                // Verify tree still exists
                if (!this.climbingTree || trees.indexOf(this.climbingTree) === -1) {
                    this.state = 'falling';
                    this.stateTimer = 0;
                    this.climbingTree = null;
                    debugLog(`Squirrel's tree disappeared!`);
                    break;
                }
                
                // IMPORTANT FIX: Reset acceleration and limit velocity to prevent drift
                this.acceleration = { x: 0, y: 0 };
                this.velocity.x *= 0.8; // Stronger damping
                
                // Move toward tree trunk
                const distToTrunk = Math.abs(this.x - this.climbingTree.x);
                
                // Reduced threshold for closer tree attachment
                if (distToTrunk < 3) { // Changed from 5 to 3
                    // IMPORTANT: Force the X position to be exactly at the trunk
                    this.x = this.climbingTree.x;
                    this.velocity.x = 0; // Stop horizontal movement
                    
                    // At trunk, climb up
                    if (!this.targetY) {
                        // Target height is top of trunk
                        this.targetY = this.climbingTree.y - this.climbingTree.trunkHeight * 0.8 * this.climbingTree.scale;
                    }
                    
                    const heightDiff = this.y - this.targetY;
                    
                    if (Math.abs(heightDiff) < 5) {
                        // Reached target height
                        this.state = 'inTree';
                        this.stateTimer = 0;
                        this.x = this.climbingTree.x; // Center on trunk
                        this.velocity = { x: 0, y: 0 }; // Stop all movement
                        debugLog(`Squirrel reached top of tree at (${this.climbingTree.x})`);
                    } else {
                        // Climb up or down - use constant speed rather than deltaTime
                        // to avoid dependency issues
                        const climbSpeed = 0.9;
                        this.y -= Math.sign(heightDiff) * climbSpeed;
                        
                        // IMPORTANT: Ensure squirrel stays exactly on trunk while climbing
                        this.x = this.climbingTree.x;
                        this.velocity.x = 0;
                    }
                } else {
                    // Move toward trunk with more control
                    const moveDir = this.x < this.climbingTree.x ? 1 : -1;
                    this.direction = moveDir;
                    
                    // Adjust force based on distance - slower approach when close
                    const approachForce = Math.min(0.01, distToTrunk * 0.003);
                    this.applyForce({ 
                        x: moveDir * approachForce, 
                        y: 0 
                    });
                    
                    // Add this check to prevent overshooting
                    if ((moveDir > 0 && this.velocity.x > 0.5) || 
                        (moveDir < 0 && this.velocity.x < -0.5)) {
                        this.velocity.x = moveDir * 0.5; // Cap velocity
                    }
                }
                
                // Birds sometimes chase squirrels from trees
                const nearbyBirdInTree = birds.find(bird => 
                    bird.perchTarget && 
                    bird.perchTarget.tree === this.climbingTree &&
                    distance(this.x, this.y, bird.x, bird.y) < 50
                );
                
                if (nearbyBirdInTree) {
                    // Fall out of tree
                    this.state = 'falling';
                    this.stateTimer = 0;
                    this.velocity.y = 0.5; // Initial falling velocity
                    debugLog(`Bird chased squirrel out of tree!`);
                }
                break;
                
            case 'inTree':
                // Verify tree still exists
                if (!this.climbingTree || trees.indexOf(this.climbingTree) === -1) {
                    this.state = 'falling';
                    this.stateTimer = 0;
                    this.climbingTree = null;
                    debugLog(`Squirrel's tree disappeared while in it!`);
                    break;
                }

                // CRITICAL FIX: Reset acceleration and force position to tree
                this.acceleration = { x: 0, y: 0 };
                
                // Keep squirrel at the target position with stronger enforcement
                this.x = this.climbingTree.x;
                this.y = this.targetY;
                this.velocity.x = 0; // Stop horizontal movement
                this.velocity.y *= 0.8; // Dampen vertical movement
                
                // Random small movements, but MUCH smaller to stay on trunk
                if (Math.random() < 0.1) {
                    this.applyForce({ 
                        x: (Math.random() - 0.5) * 0.0005, // Reduced by 2x
                        y: (Math.random() - 0.5) * 0.0005  // Reduced by 2x
                    });
                }
                
                // Eat nuts, or check nests
                if (this.nutCollected) {
                    // Eating animation
                    if (this.stateTimer > 8000) {
                        this.nutCollected = false;
                        debugLog(`Squirrel finished eating nut`);
                    }
                } else {
                    // V26: Reduced nest damage chance
                    // Look for bird nests - only if squirrel doesn't already have food
                    const nearbyNest = nests.find(nest => 
                        nest.tree === this.climbingTree &&
                        distance(this.x, this.y, nest.x, nest.y) < 40
                    );
                    
                    if (nearbyNest && Math.random() < 0.07) { // Reduced from 0.1
                        // Raid nest
                        nearbyNest.damage(4); // Reduced from 5
                        debugLog(`Squirrel damaged nest at (${nearbyNest.x}, ${nearbyNest.y})`);
                    }
                }
                
                // Birds sometimes chase squirrels from trees
                const birdInTree = birds.find(bird => 
                    bird.perchTarget && 
                    bird.perchTarget.tree === this.climbingTree &&
                    distance(this.x, this.y, bird.x, bird.y) < 30
                );
                
                if (birdInTree) {
                    // Fall out of tree
                    this.state = 'falling';
                    this.stateTimer = 0;
                    this.velocity.y = 0.5; // Initial falling velocity
                    debugLog(`Bird chased squirrel out of tree!`);
                }
                
                // Check for nearby trees to jump to (branch traversal)
                if (this.stateTimer > 3000 && Math.random() < 0.01) {
                    // Look for nearby trees
                    const nearbyTrees = trees.filter(tree =>
                        tree !== this.climbingTree &&
                        Math.abs(tree.x - this.climbingTree.x) < 80 && // Trees within 80px
                        Math.abs((tree.y - tree.trunkHeight * 0.8 * tree.scale) - this.y) < 40 // Similar height
                    );

                    if (nearbyTrees.length > 0) {
                        // Jump to nearby tree!
                        const targetTree = nearbyTrees[Math.floor(Math.random() * nearbyTrees.length)];
                        this.state = 'branchJumping';
                        this.jumpTargetTree = targetTree;
                        this.jumpStartX = this.x;
                        this.jumpStartY = this.y;
                        this.jumpProgress = 0;
                        this.stateTimer = 0;
                        debugLog(`Squirrel jumping from tree to nearby tree at (${targetTree.x})`);
                        break;
                    }
                }

                // Eventually climb down
                if (this.stateTimer > 15000) {
                    this.state = 'climbing';
                    this.stateTimer = 0;
                    this.targetY = this.groundY - 5; // Ground level
                    debugLog(`Squirrel climbing down`);
                }
                break;
                
            case 'falling':
                // Apply gravity
                this.applyForce({ x: 0, y: 0.05 });
                
                // Check if reached ground (allow slightly below for foraging)
                if (this.y >= this.groundY + 15) {
                    this.y = this.groundY + 15;
                    this.velocity.y = 0;
                    this.state = 'stunned';
                    this.stateTimer = 0;
                    debugLog(`Squirrel hit the ground!`);
                }
                break;
                
            case 'stunned':
                // Stunned after falling, minimal movement
                this.velocity.x *= 0.95;
                this.velocity.y = 0;
                
                // Recover after a moment
                if (this.stateTimer > 2000) {
                    this.state = 'wandering';
                    this.stateTimer = 0;
                    this.fleeing = false;
                    this.climbingTree = null;
                    this.targetY = null;
                    debugLog(`Squirrel recovered from fall`);
                }
                break;
                
            case 'fleeing':
                // Run away fast
                this.applyForce({
                    x: this.direction * 0.05,
                    y: 0
                });

                // Allow exploring slightly below ground
                this.y = Math.min(this.y, this.groundY + 15);

                // Return to wandering after fleeing
                if (this.stateTimer > 3000) {
                    this.state = 'wandering';
                    this.stateTimer = 0;
                    this.fleeing = false;
                }
                break;

            case 'branchJumping':
                // Animate jump between trees
                if (!this.jumpTargetTree || trees.indexOf(this.jumpTargetTree) === -1) {
                    // Target tree disappeared, fall
                    this.state = 'falling';
                    this.stateTimer = 0;
                    break;
                }

                this.jumpProgress += deltaTime / 500; // 500ms jump duration

                if (this.jumpProgress >= 1) {
                    // Jump complete, attach to new tree
                    this.climbingTree = this.jumpTargetTree;
                    this.x = this.jumpTargetTree.x;
                    this.y = this.jumpTargetTree.y - this.jumpTargetTree.trunkHeight * 0.8 * this.jumpTargetTree.scale;
                    this.targetY = this.y;
                    this.state = 'inTree';
                    this.stateTimer = 0;
                    this.velocity = { x: 0, y: 0 };
                    debugLog(`Squirrel landed on tree at (${this.jumpTargetTree.x})`);
                } else {
                    // Arc motion during jump
                    const targetX = this.jumpTargetTree.x;
                    const targetY = this.jumpTargetTree.y - this.jumpTargetTree.trunkHeight * 0.8 * this.jumpTargetTree.scale;

                    this.x = this.jumpStartX + (targetX - this.jumpStartX) * this.jumpProgress;
                    this.y = this.jumpStartY + (targetY - this.jumpStartY) * this.jumpProgress - Math.sin(this.jumpProgress * Math.PI) * 30;

                    // Face direction of jump
                    this.direction = targetX > this.jumpStartX ? 1 : -1;
                }
                break;
                
                case 'leaving':
    // Follow path to exit just like 'flying' state
    if (this.path && this.path.length > 0 && this.pathIndex < this.path.length) {
        const waypoint = this.path[this.pathIndex];
        const waypointDist = distance(this.x, this.y, waypoint.x, waypoint.y);
        
        if (waypointDist < 10) {
            // Reached waypoint, move to next
            this.pathIndex++;
        } else {
            // Move toward waypoint
            const dx = waypoint.x - this.x;
            const dy = waypoint.y - this.y;
            const dir = normalize(dx, dy);
            
            // Move faster when leaving
            this.applyForce({ 
                x: dir.x * 0.03, 
                y: dir.y * 0.02 
            });
            
            // Face direction of movement
            if (Math.abs(dx) > 2) {
                this.direction = dx > 0 ? 1 : -1;
            }
        }
    }
    
    // Check if off screen - only return true when actually off screen
    if (this.x < -50 || this.x > canvas.width + 50 || 
        this.y < -50 || this.y > canvas.height + 50) {
        debugLog(`Crow has left the screen at (${this.x}, ${this.y})`);
        return true; // Remove the crow
    }
    break;
        }
        
        // Update position with velocity
        this.velocity.x += this.acceleration.x * (deltaTime / 16);
        this.velocity.y += this.acceleration.y * (deltaTime / 16);
        
        // Limit speed
        const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
        if (speed > this.speed) {
            this.velocity.x = (this.velocity.x / speed) * this.speed;
            this.velocity.y = (this.velocity.y / speed) * this.speed;
        }
        
        // Update position
        this.x += this.velocity.x * (deltaTime / 16);
        this.y += this.velocity.y * (deltaTime / 16);
        
        // Apply position constraints if not intentionally leaving
        if (this.state !== 'leaving') {
            validatePosition(this);
        }
        
        return false;
    }
    
    draw() {
        const tailWag = Math.sin(this.tailWobble) * 8;
        const tailWagOffset = Math.cos(this.tailWobble) * 5;
        
        // Draw bushy tail
        ctx.fillStyle = '#B25D18';
        
        // Tail position and shape depends on state
        const tailBaseX = this.x + (this.direction * -8);
        const tailBaseY = this.y - 3;
        
        // Tail shape varies by state
        if (this.state === 'falling') {
            // Spread tail when falling
            ctx.beginPath();
            ctx.ellipse(
                tailBaseX, 
                tailBaseY + 5,
                20, 
                10, 
                0, 0, Math.PI * 2
            );
            ctx.fill();
        } else if (this.state === 'stunned') {
            // Flat tail when stunned
            ctx.beginPath();
            ctx.ellipse(
                tailBaseX, 
                tailBaseY + 5,
                12, 
                4, 
                0, 0, Math.PI * 2
            );
            ctx.fill();
        } else {
            // Normal bushy tail with movement
            ctx.beginPath();
            ctx.moveTo(tailBaseX, tailBaseY);
            
            ctx.bezierCurveTo(
    tailBaseX + (this.direction * -20), tailBaseY + tailWagOffset, 
    tailBaseX + (this.direction * -50), tailBaseY + tailWag, 
    tailBaseX + (this.direction * -30), tailBaseY + tailWag + 5
);
            
            ctx.bezierCurveTo(
                tailBaseX + (this.direction * -18), tailBaseY + tailWag, 
                tailBaseX + (this.direction * -10), tailBaseY + tailWagOffset - 2, 
                tailBaseX, tailBaseY - 3
            );
            
            ctx.fill();
        }
        
        // Body
        ctx.fillStyle = '#B25D18';
        ctx.beginPath();
        ctx.ellipse(
            this.x, 
            this.y, 
            12, 
            7, 
            0, 0, Math.PI * 2
        );
        ctx.fill();
        
        // Head
        ctx.fillStyle = '#B25D18';
        ctx.beginPath();
        ctx.ellipse(
            this.x + (this.direction * 10), 
            this.y - 3, 
            7, 
            6, 
            0, 0, Math.PI * 2
        );
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(
            this.x + (this.direction * 12), 
            this.y - 4, 
            1.5, 
            0, Math.PI * 2
        );
        ctx.fill();
        
        // Ears
        ctx.fillStyle = '#B25D18';
        ctx.beginPath();
        ctx.ellipse(
            this.x + (this.direction * 13), 
            this.y - 8, 
            2, 
            3, 
            0, 0, Math.PI * 2
        );
        ctx.fill();
        
        // Draw nut if holding one
        if (this.nutCollected) {
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(
                this.x + (this.direction * 15), 
                this.y, 
                3, 
                0, Math.PI * 2
            );
            ctx.fill();
        }
        
        if (debugVisuals) {
            // Vision circle
            ctx.strokeStyle = 'rgba(200, 100, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(this.x, this.y, SQUIRREL_VISION_RADIUS, 0, Math.PI * 2);
            ctx.stroke();
            
            // State text
            ctx.fillStyle = 'white';
            ctx.font = '8px Arial';
            ctx.fillText(this.state, this.x - 10, this.y - 15);
        }
    }
}



class Butterfly {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.velocity = { x: 0, y: 0 };
        this.acceleration = { x: 0, y: 0 };
        this.direction = Math.random() < 0.5 ? -1 : 1;
        this.state = 'flying'; // flying, approaching, resting, leaving
        this.stateTimer = 0;
        this.wingFlap = Math.random() * Math.PI * 2; // Random start position
        this.targetFlower = null;
        this.speed = 0.6 + Math.random() * 0.4; // Slower than birds
        this.size = 8 + Math.random() * 5; // Increased size for visibility
        this.restingTime = 3000 + Math.random() * 7000; // 3-10 seconds at a flower
        this.dancingFrequency = 0.01 + Math.random() * 0.02; // For dancing flight pattern
        this.dancingAmplitude = 10 + Math.random() * 15; // How large the dancing circles are
        this.dancingTimer = Math.random() * Math.PI * 2; // Offset the dancing pattern
        this.exitPoint = null;
        this.lastFlowerChange = 0; // Track when we last moved to a different flower
        
        // Choose a butterfly style (0-3)
        this.butterflyStyle = Math.floor(Math.random() * 4);
        
        // Cute pastel colors for butterflies
        const butterflyColors = [
            // Pastel colors for cuter appearance
            "#FFB6C1", // Light pink
            "#FFC3A0", // Peach
            "#FFDFBA", // Pale orange
            "#FFFFBA", // Pale yellow
            "#BAFFC9", // Pale green
            "#BAE1FF", // Pale blue
            "#E2BAFF", // Pale purple
            "#D4F0F0", // Pale turquoise
            "#FFC8DD", // Pink
            "#BDFFFD"  // Aqua
        ];
        
        // Choose main color
        this.primaryColor = butterflyColors[Math.floor(Math.random() * butterflyColors.length)];
        
        // Choose secondary color with some logic for good combinations
        const index = butterflyColors.indexOf(this.primaryColor);
        const complementaryIndex = (index + 4) % butterflyColors.length; // Pick a complementary color
        this.secondaryColor = butterflyColors[complementaryIndex];
        
        // Pattern type (0-2: dots, stripes, gradient)
        this.patternType = Math.floor(Math.random() * 3);
        
        // Pattern color
        const patternIndex = (index + 2) % butterflyColors.length;
        this.patternColor = butterflyColors[patternIndex];
    }
    
    applyForce(force) {
        this.acceleration.x += force.x;
        this.acceleration.y += force.y;
    }
    
    update(deltaTime) {


// Make butterflies leave at night
if (timeOfDay >= 1 && this.state !== 'leaving') {
        this.state = 'leaving';
        this.stateTimer = 0;
        this.targetFlower = null;
        
        // Choose a random edge to exit toward
        const exitEdge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
        let exitX, exitY;
        switch(exitEdge) {
            case 0: // Top
                exitX = Math.random() * canvas.width;
                exitY = -50;
                break;
            case 1: // Right
                exitX = canvas.width + 50;
                exitY = Math.random() * canvas.height * 0.7;
                break;
            case 2: // Bottom
                exitX = Math.random() * canvas.width;
                exitY = canvas.height + 50;
                break;
            case 3: // Left
                exitX = -50;
                exitY = Math.random() * canvas.height * 0.7;
                break;
        }
        this.exitPoint = { x: exitX, y: exitY };
        
        if (typeof debugLog === 'function') {
            debugLog("Butterfly leaving due to nightfall");
        }
    }

        // Update animation timers
        this.stateTimer += deltaTime;
        this.wingFlap += 0.3 * deltaTime / 16; // Wing flap speed
        this.dancingTimer += this.dancingFrequency * deltaTime / 16; // Dancing motion timer
        


        
        // Reset acceleration each frame
        this.acceleration = { x: 0, y: 0 };
        
        switch (this.state) {
            case 'flying':
                // Apply a dancing/bobbing motion for cute effect
                const dancingX = Math.sin(this.dancingTimer) * this.dancingAmplitude;
                const dancingY = Math.cos(this.dancingTimer * 0.8) * (this.dancingAmplitude * 0.5);
                
                this.applyForce({
                    x: dancingX * 0.001, // Gentle force for dancing motion
                    y: dancingY * 0.001
                });
                
                // Occasional random direction changes
                if (Math.random() < 0.02) {
                    this.applyForce({
                        x: (Math.random() - 0.5) * 0.03,
                        y: (Math.random() - 0.5) * 0.02
                    });
                    
                    // Occasionally flip direction for visual interest
                    if (Math.random() < 0.3) {
                        this.direction *= -1;
                    }
                }
                
                // Look for flowers to visit
                if (typeof flowers !== 'undefined' && Array.isArray(flowers) && flowers.length > 0 && Math.random() < 0.1) {
                    // Find a flower to visit that isn't the current target
                    let availableFlowers = flowers.filter(flower => 
                        this.targetFlower === null || flower !== this.targetFlower
                    );
                    
                    if (availableFlowers.length > 0) {
                        // Choose a random flower from available ones
                        this.targetFlower = availableFlowers[Math.floor(Math.random() * availableFlowers.length)];
                        this.state = 'approaching';
                        this.stateTimer = 0;
                        this.lastFlowerChange = Date.now();
                        
                        if (typeof debugLog === 'function') {
                            debugLog(`Butterfly heading to a new flower at (${this.targetFlower.x}, ${this.targetFlower.y})`);
                        }
                    }
                }
                
                // Occasionally decide to leave
                if (this.stateTimer > 30000 && Math.random() < 0.01) {
                    this.state = 'leaving';
                    this.stateTimer = 0;
                    this.targetFlower = null;
                    
                    if (typeof debugLog === 'function') {
                        debugLog(`Butterfly decided to leave the garden`);
                    }
                }
                break;
                
            case 'approaching':
                if (!this.targetFlower || typeof flowers === 'undefined' || !Array.isArray(flowers) || 
                    !flowers.includes(this.targetFlower)) {
                    // Target flower is gone, return to flying
                    this.state = 'flying';
                    this.stateTimer = 0;
                    this.targetFlower = null;
                    break;
                }
                
                // Move toward flower with a dancing motion
                const dx = this.targetFlower.x - this.x;
                const dy = this.targetFlower.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Add dancing motion while approaching
                const approachDancingX = Math.sin(this.dancingTimer * 1.5) * (this.dancingAmplitude * 0.5);
                const approachDancingY = Math.cos(this.dancingTimer) * (this.dancingAmplitude * 0.3);
                
                if (dist < 10) {
                    // Reached flower, start resting
                    this.state = 'resting';
                    this.stateTimer = 0;
                    
                    // Position exactly on flower
                    this.x = this.targetFlower.x;
                    this.y = this.targetFlower.y - 5; // Just above flower
                    
                    if (typeof debugLog === 'function') {
                        debugLog(`Butterfly resting on flower at (${this.targetFlower.x}, ${this.targetFlower.y})`);
                    }
                } else {
                    // Calculate direction to flower
                    let dirX = dx / dist;
                    let dirY = dy / dist;
                    
                    // Apply dancing motion to approach path
                    dirX += approachDancingX * 0.01;
                    dirY += approachDancingY * 0.01;
                    
                    // Normalize the direction
                    const normFactor = 1 / Math.sqrt(dirX * dirX + dirY * dirY);
                    dirX *= normFactor;
                    dirY *= normFactor;
                    
                    // Apply force toward flower with dancing
                    this.applyForce({
                        x: dirX * 0.01,
                        y: dirY * 0.01
                    });
                    
                    // Face direction of movement
                    if (Math.abs(dx) > 2) {
                        this.direction = dx > 0 ? 1 : -1;
                    }
                    
                    // If taking too long to reach flower, give up
                    if (this.stateTimer > 10000) {
                        this.state = 'flying';
                        this.stateTimer = 0;
                        this.targetFlower = null;
                    }
                }
                break;
                
            case 'resting':
                // Stay at flower position with slight movement
                if (this.targetFlower && typeof flowers !== 'undefined' && Array.isArray(flowers) && 
                    flowers.includes(this.targetFlower)) {
                    
                    // Subtle movement while resting (wing fluttering)
                    this.x = this.targetFlower.x + Math.sin(this.wingFlap * 0.5) * 2;
                    this.y = this.targetFlower.y - 5 + Math.cos(this.wingFlap * 0.3) * 2;
                    
                    // Reset velocity while resting
                    this.velocity.x *= 0.8;
                    this.velocity.y *= 0.8;
                } else {
                    // Flower is gone, go back to flying
                    this.state = 'flying';
                    this.stateTimer = 0;
                    this.targetFlower = null;
                    break;
                }
                
                // End resting after specified time
                if (this.stateTimer > this.restingTime) {
                    if (Math.random() < 0.8) {
                        // Usually look for a new flower
                        this.state = 'flying';
                        this.stateTimer = 0;
                        // Don't immediately clear target flower so we don't pick the same one
                        setTimeout(() => {
                            if (this && this.state === 'flying') {
                                this.targetFlower = null;
                            }
                        }, 1000);
                    } else {
                        // Sometimes decide to leave
                        this.state = 'leaving';
                        this.stateTimer = 0;
                        this.targetFlower = null;
                    }
                }
                break;
                
            case 'leaving':
                // Choose a random edge to fly toward if we haven't yet
                if (!this.exitPoint) {
                    const edge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
                    
                    switch (edge) {
                        case 0: // Top
                            this.exitPoint = { x: Math.random() * canvas.width, y: -50 };
                            break;
                        case 1: // Right
                            this.exitPoint = { x: canvas.width + 50, y: Math.random() * canvas.height * 0.7 };
                            break;
                        case 2: // Bottom
                            this.exitPoint = { x: Math.random() * canvas.width, y: canvas.height + 50 };
                            break;
                        case 3: // Left
                            this.exitPoint = { x: -50, y: Math.random() * canvas.height * 0.7 };
                            break;
                    }
                }
                
                // Move toward exit point with dancing motion
                const exitDx = this.exitPoint.x - this.x;
                const exitDy = this.exitPoint.y - this.y;
                const exitDist = Math.sqrt(exitDx * exitDx + exitDy * exitDy);
                
                // Add dancing motion while leaving
                const leavingDanceX = Math.sin(this.dancingTimer * 1.2) * this.dancingAmplitude;
                const leavingDanceY = Math.cos(this.dancingTimer * 0.9) * (this.dancingAmplitude * 0.5);
                
                // If reached exit point or off screen, remove butterfly
                if (exitDist < 10 || 
                    this.x < -100 || this.x > (canvas ? canvas.width : 1000) + 100 || 
                    this.y < -100 || this.y > (canvas ? canvas.height : 1000) + 100) {
                    return true; // Remove butterfly
                }
                
                // Calculate direction to exit
                let exitDirX = exitDx / exitDist;
                let exitDirY = exitDy / exitDist;
                
                // Add dancing motion
                exitDirX += leavingDanceX * 0.001;
                exitDirY += leavingDanceY * 0.001;
                
                // Apply force toward exit with dancing
                this.applyForce({
                    x: exitDirX * 0.02,
                    y: exitDirY * 0.01
                });
                
                // Face direction of movement
                if (Math.abs(exitDx) > 2) {
                    this.direction = exitDx > 0 ? 1 : -1;
                }
                break;
        }
        
        // Update velocity with acceleration
        this.velocity.x += this.acceleration.x * (deltaTime / 16);
        this.velocity.y += this.acceleration.y * (deltaTime / 16);
        
        // Add gentle gravity (lighter than birds)
        if (this.state !== 'resting' && typeof GRAVITY !== 'undefined') {
            this.applyForce({ x: 0, y: GRAVITY * 0.2 });
        }
        
        // Apply air resistance
        if (typeof AIR_RESISTANCE !== 'undefined') {
            this.velocity.x *= AIR_RESISTANCE;
            this.velocity.y *= AIR_RESISTANCE;
        } else {
            // Fallback if AIR_RESISTANCE isn't defined
            this.velocity.x *= 0.98;
            this.velocity.y *= 0.98;
        }
        
        // Limit speed
        const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
        if (speed > this.speed) {
            this.velocity.x = (this.velocity.x / speed) * this.speed;
            this.velocity.y = (this.velocity.y / speed) * this.speed;
        }
        
        // Update position
        this.x += this.velocity.x * (deltaTime / 16);
        this.y += this.velocity.y * (deltaTime / 16);
        
        // Apply position constraints if not intentionally leaving
        if (this.state !== 'leaving' && typeof validatePosition === 'function') {
            try {
                validatePosition(this);
            } catch (e) {
                // Ignore errors in validatePosition
            }
        }
        
        return false; // Don't remove by default
    }
    
    draw() {
        // Get wing flap animation parameters
        const wingOpen = Math.abs(Math.sin(this.wingFlap)); // 0-1 for closed-open wings
        const wingFlapSpeed = this.state === 'resting' ? 0.2 : 1.0; // Slower flapping when resting
        
        // Save context for transformations
        ctx.save();
        
        // Translate to butterfly position
        ctx.translate(this.x, this.y);
        
        // Different butterfly styles
        switch (this.butterflyStyle) {
            case 0: // Heart-shaped wings
                this.drawHeartButterfly(wingOpen);
                break;
            case 1: // Rounded wings with patterns
                this.drawRoundedButterfly(wingOpen);
                break;
            case 2: // Fairy-like wings
                this.drawFairyButterfly(wingOpen);
                break;
            case 3: // Classic butterfly shape
            default:
                this.drawClassicButterfly(wingOpen);
                break;
        }
        
        // Restore context
        ctx.restore();
    }
    
    drawHeartButterfly(wingOpen) {
        // Heart-shaped wings butterfly
        const wingScale = this.size * (0.8 + wingOpen * 0.4); // Size changes with wing flap
        const bodyWidth = this.size * 0.2;
        const bodyLength = this.size * 1.2;
        
        // Draw wings - they'll be heart-shaped
        ctx.fillStyle = this.primaryColor;
        
        // Upper wings (heart shapes)
        // Right wing
        ctx.save();
        ctx.scale(this.direction, 1); // Flip based on direction
        
        // Draw heart-shaped wing
        this.drawHeart(
            bodyWidth * 1.5, // x offset from center
            -bodyLength * 0.3, // y offset from center
            wingScale // size factor
        );
        
        // Left wing (mirror)
        this.drawHeart(
            -bodyWidth * 1.5, // opposite x offset 
            -bodyLength * 0.3,
            wingScale
        );
        
        // Lower wings (smaller hearts)
        this.drawHeart(
            bodyWidth * 1.3,
            bodyLength * 0.2,
            wingScale * 0.7
        );
        
        this.drawHeart(
            -bodyWidth * 1.3,
            bodyLength * 0.2,
            wingScale * 0.7
        );
        
        ctx.restore();
        
        // Draw patterns on wings
        ctx.save();
        ctx.scale(this.direction, 1); // Flip based on direction
        
        // Draw patterns based on pattern type
        switch (this.patternType) {
            case 0: // Dots
                ctx.fillStyle = this.patternColor;
                // Dots on upper wings
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(
                        bodyWidth * 1.5 + (i - 1) * (wingScale * 0.3),
                        -bodyLength * 0.3 + (i % 2) * (wingScale * 0.2),
                        wingScale * 0.1,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                    
                    // Mirror for left wing
                    ctx.beginPath();
                    ctx.arc(
                        -bodyWidth * 1.5 - (i - 1) * (wingScale * 0.3),
                        -bodyLength * 0.3 + (i % 2) * (wingScale * 0.2),
                        wingScale * 0.1,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
                break;
                
            case 1: // Stripes
                ctx.fillStyle = this.patternColor;
                // Stripes on upper wings
                for (let i = 0; i < 3; i++) {
                    // Right wing stripe
                    ctx.beginPath();
                    ctx.moveTo(bodyWidth * 1.2 + i * (wingScale * 0.2), -bodyLength * 0.5);
                    ctx.lineTo(bodyWidth * 1.8 + i * (wingScale * 0.2), -bodyLength * 0.1);
                    ctx.lineTo(bodyWidth * 1.8 + i * (wingScale * 0.2) + 2, -bodyLength * 0.1);
                    ctx.lineTo(bodyWidth * 1.2 + i * (wingScale * 0.2) + 2, -bodyLength * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Left wing stripe (mirrored)
                    ctx.beginPath();
                    ctx.moveTo(-bodyWidth * 1.2 - i * (wingScale * 0.2), -bodyLength * 0.5);
                    ctx.lineTo(-bodyWidth * 1.8 - i * (wingScale * 0.2), -bodyLength * 0.1);
                    ctx.lineTo(-bodyWidth * 1.8 - i * (wingScale * 0.2) - 2, -bodyLength * 0.1);
                    ctx.lineTo(-bodyWidth * 1.2 - i * (wingScale * 0.2) - 2, -bodyLength * 0.5);
                    ctx.closePath();
                    ctx.fill();
                }
                break;
                
            case 2: // Gradient/eye spots
                // Eye spots on wings
                ctx.fillStyle = this.secondaryColor;
                
                // Right wing eye spot
                ctx.beginPath();
                ctx.arc(
                    bodyWidth * 1.5,
                    -bodyLength * 0.3,
                    wingScale * 0.25,
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Left wing eye spot
                ctx.beginPath();
                ctx.arc(
                    -bodyWidth * 1.5,
                    -bodyLength * 0.3,
                    wingScale * 0.25,
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Inner eye spots
                ctx.fillStyle = this.patternColor;
                
                ctx.beginPath();
                ctx.arc(
                    bodyWidth * 1.5,
                    -bodyLength * 0.3,
                    wingScale * 0.15,
                    0, Math.PI * 2
                );
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(
                    -bodyWidth * 1.5,
                    -bodyLength * 0.3,
                    wingScale * 0.15,
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Center of eye spots
                ctx.fillStyle = 'white';
                
                ctx.beginPath();
                ctx.arc(
                    bodyWidth * 1.5,
                    -bodyLength * 0.3,
                    wingScale * 0.05,
                    0, Math.PI * 2
                );
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(
                    -bodyWidth * 1.5,
                    -bodyLength * 0.3,
                    wingScale * 0.05,
                    0, Math.PI * 2
                );
                ctx.fill();
                break;
        }
        
        ctx.restore();
        
        // Draw body
        this.drawBody(bodyWidth, bodyLength);
    }
    
    drawRoundedButterfly(wingOpen) {
        // Rounded wings butterfly with patterns
        const wingScale = this.size * (0.8 + wingOpen * 0.4);
        const bodyWidth = this.size * 0.2;
        const bodyLength = this.size * 1.2;
        
        // Draw wings - round and cute
        ctx.save();
        ctx.scale(this.direction, 1); // Flip based on direction
        
        // Upper wings
        ctx.fillStyle = this.primaryColor;
        
        // Right upper wing
        ctx.beginPath();
        ctx.ellipse(
            bodyWidth * 1.2,
            -bodyLength * 0.3,
            wingScale,
            wingScale * 1.2,
            -Math.PI * 0.2,
            0, Math.PI * 2
        );
        ctx.fill();
        
        // Left upper wing
        ctx.beginPath();
        ctx.ellipse(
            -bodyWidth * 1.2,
            -bodyLength * 0.3,
            wingScale,
            wingScale * 1.2,
            Math.PI * 0.2,
            0, Math.PI * 2
        );
        ctx.fill();
        
        // Lower wings
        ctx.fillStyle = this.secondaryColor;
        
        // Right lower wing
        ctx.beginPath();
        ctx.ellipse(
            bodyWidth * 1.0,
            bodyLength * 0.3,
            wingScale * 0.8,
            wingScale * 0.9,
            -Math.PI * 0.1,
            0, Math.PI * 2
        );
        ctx.fill();
        
        // Left lower wing
        ctx.beginPath();
        ctx.ellipse(
            -bodyWidth * 1.0,
            bodyLength * 0.3,
            wingScale * 0.8,
            wingScale * 0.9,
            Math.PI * 0.1,
            0, Math.PI * 2
        );
        ctx.fill();
        
        // Draw patterns
        ctx.fillStyle = this.patternColor;
        
        // Pattern depends on pattern type
        switch (this.patternType) {
            case 0: // Polka dots
                // Dots on right wing
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI;
                    const dotX = bodyWidth * 1.2 + Math.cos(angle) * (wingScale * 0.6);
                    const dotY = -bodyLength * 0.3 + Math.sin(angle) * (wingScale * 0.7);
                    
                    ctx.beginPath();
                    ctx.arc(dotX, dotY, wingScale * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Mirror for left wing
                    ctx.beginPath();
                    ctx.arc(-dotX, dotY, wingScale * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                }
                break;
                
            case 1: // Border trim
                // Right upper wing border
                ctx.beginPath();
                ctx.ellipse(
                    bodyWidth * 1.2,
                    -bodyLength * 0.3,
                    wingScale * 0.8,
                    wingScale,
                    -Math.PI * 0.2,
                    0, Math.PI * 2
                );
                ctx.stroke();
                
                // Left upper wing border
                ctx.beginPath();
                ctx.ellipse(
                    -bodyWidth * 1.2,
                    -bodyLength * 0.3,
                    wingScale * 0.8,
                    wingScale,
                    Math.PI * 0.2,
                    0, Math.PI * 2
                );
                ctx.stroke();
                break;
                
            case 2: // Swirls
                // Right wing swirl
                ctx.beginPath();
                ctx.moveTo(bodyWidth, -bodyLength * 0.3);
                for (let i = 0; i < 3; i++) {
                    const t = i / 3;
                    const spiralX = bodyWidth + wingScale * t * Math.cos(t * Math.PI * 4);
                    const spiralY = -bodyLength * 0.3 + wingScale * t * Math.sin(t * Math.PI * 4);
                    ctx.lineTo(spiralX, spiralY);
                }
                ctx.stroke();
                
                // Left wing swirl (mirrored)
                ctx.beginPath();
                ctx.moveTo(-bodyWidth, -bodyLength * 0.3);
                for (let i = 0; i < 3; i++) {
                    const t = i / 3;
                    const spiralX = -bodyWidth - wingScale * t * Math.cos(t * Math.PI * 4);
                    const spiralY = -bodyLength * 0.3 + wingScale * t * Math.sin(t * Math.PI * 4);
                    ctx.lineTo(spiralX, spiralY);
                }
                ctx.stroke();
                break;
        }
        
        ctx.restore();
        
        // Draw body
        this.drawBody(bodyWidth, bodyLength);
    }
    
    drawFairyButterfly(wingOpen) {
        // Fairy-like wings butterfly (more ethereal and translucent)
        const wingScale = this.size * (0.8 + wingOpen * 0.4);
        const bodyWidth = this.size * 0.3; // Slimmer body
        const bodyLength = this.size * 1.2;
        
        // Wing transparency
        ctx.globalAlpha = 0.7; // Make wings translucent
        
        ctx.save();
        ctx.scale(this.direction, 1); // Flip based on direction
        
        // Upper wings (elongated and more fairy-like)
        ctx.fillStyle = this.primaryColor;
        
        // Right wing
        ctx.beginPath();
        ctx.moveTo(0, 0); // Start at body center
        ctx.quadraticCurveTo(
            bodyWidth * 2, -bodyLength * 0.8,
            bodyWidth * 3, -bodyLength * 0.3
        );
        ctx.quadraticCurveTo(
            bodyWidth * 2.5, bodyLength * 0.1,
            0, 0
        );
        ctx.fill();
        
        // Left wing (mirrored)
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(
            -bodyWidth * 2, -bodyLength * 0.8,
            -bodyWidth * 3, -bodyLength * 0.3
        );
        ctx.quadraticCurveTo(
            -bodyWidth * 2.5, bodyLength * 0.1,
            0, 0
        );
        ctx.fill();
        
        // Lower wings
        ctx.fillStyle = this.secondaryColor;
        
        // Right lower wing
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(
            bodyWidth * 1.5, bodyLength * 0.3,
            bodyWidth * 2, bodyLength * 0.7
        );
        ctx.quadraticCurveTo(
            bodyWidth * 1, bodyLength * 0.5,
            0, 0
        );
        ctx.fill();
        
        // Left lower wing
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(
            -bodyWidth * 1.5, bodyLength * 0.3,
            -bodyWidth * 2, bodyLength * 0.7
        );
        ctx.quadraticCurveTo(
            -bodyWidth * 1, bodyLength * 0.5,
            0, 0
        );
        ctx.fill();
        
        // Add magical sparkles/fairy dust
        ctx.fillStyle = 'white';
        for (let i = 0; i < 10; i++) {
            // Random position across both wings
            const side = Math.random() < 0.5 ? 1 : -1;
            const sparkleX = side * bodyWidth * (0.5 + Math.random() * 2.5);
            const sparkleY = (Math.random() - 0.5) * bodyLength;
            
            // Vary sparkle size based on wing flap
            const sparkleSize = wingScale * 0.05 * (0.5 + wingOpen * 0.5);
            
            ctx.beginPath();
            ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Wing veins
        ctx.strokeStyle = this.patternColor;
        ctx.lineWidth = 0.5;
        
        // Draw delicate wing veins
        // Right upper wing
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(bodyWidth * 1.5, -bodyLength * 0.5);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(bodyWidth * 2, -bodyLength * 0.2);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(bodyWidth * 2, bodyLength * 0.1);
        ctx.stroke();
        
        // Left upper wing (mirrored)
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-bodyWidth * 1.5, -bodyLength * 0.5);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-bodyWidth * 2, -bodyLength * 0.2);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-bodyWidth * 2, bodyLength * 0.1);
        ctx.stroke();
        
        ctx.restore();
        ctx.globalAlpha = 1.0; // Reset transparency
        
        // Draw body - more elongated for fairy-like appearance
        this.drawFairyBody(bodyWidth, bodyLength);
    }
    
    drawClassicButterfly(wingOpen) {
        // Classic butterfly shape
        const wingScale = this.size * (0.8 + wingOpen * 0.4);
        const bodyWidth = this.size * 0.1;
        const bodyLength = this.size * 1.3;
        
        ctx.save();
        ctx.scale(this.direction, 1); // Flip based on direction
        
        // Upper wings
        ctx.fillStyle = this.primaryColor;
        
        // Right upper wing
        ctx.beginPath();
        ctx.moveTo(0, -bodyLength * 0.3);
        ctx.quadraticCurveTo(
            bodyWidth * 1.2, -bodyLength * 0.9,
            bodyWidth * 2.2, -bodyLength * 0.3
        );
        ctx.quadraticCurveTo(
            bodyWidth * 1.5, bodyLength * 0.1,
            0, 0
        );
        ctx.closePath();
        ctx.fill();
        
        // Left upper wing (mirrored)
        ctx.beginPath();
        ctx.moveTo(0, -bodyLength * 0.3);
        ctx.quadraticCurveTo(
            -bodyWidth * 1.2, -bodyLength * 0.9,
            -bodyWidth * 2.2, -bodyLength * 0.3
        );
        ctx.quadraticCurveTo(
            -bodyWidth * 1.5, bodyLength * 0.1,
            0, 0
        );
        ctx.closePath();
        ctx.fill();
        
        // Lower wings
        ctx.fillStyle = this.secondaryColor;
        
        // Right lower wing
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(
            bodyWidth * 1.2, bodyLength * 0.3,
            bodyWidth * 1.5, bodyLength * 0.8
        );
        ctx.quadraticCurveTo(
            bodyWidth * 0.5, bodyLength * 0.5,
            0, bodyLength * 0.3
        );
        ctx.closePath();
        ctx.fill();
        
        // Left lower wing
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(
            -bodyWidth * 1.2, bodyLength * 0.3,
            -bodyWidth * 1.5, bodyLength * 0.8
        );
        ctx.quadraticCurveTo(
            -bodyWidth * 0.5, bodyLength * 0.5,
            0, bodyLength * 0.3
        );
        ctx.closePath();
        ctx.fill();
        
        // Wing patterns
        ctx.fillStyle = this.patternColor;
        
        switch (this.patternType) {
            case 0: // Border pattern
                ctx.lineWidth = wingScale * 0.15;
                ctx.strokeStyle = this.patternColor;
                
                // Right upper wing border
                ctx.beginPath();
                ctx.moveTo(bodyWidth * 0.5, -bodyLength * 0.2);
                ctx.quadraticCurveTo(
                    bodyWidth * 1.0, -bodyLength * 0.6,
                    bodyWidth * 1.8, -bodyLength * 0.3
                );
                ctx.stroke();
                
                // Left upper wing border (mirrored)
                ctx.beginPath();
                ctx.moveTo(-bodyWidth * 0.5, -bodyLength * 0.2);
                ctx.quadraticCurveTo(
                    -bodyWidth * 1.0, -bodyLength * 0.6,
                    -bodyWidth * 1.8, -bodyLength * 0.3
                );
                ctx.stroke();
                break;
                
            case 1: // Spots
                // Right wing spots
                for (let i = 0; i < 3; i++) {
                    const spotX = bodyWidth * (0.5 + i * 0.5);
                    const spotY = -bodyLength * 0.2 - i * bodyLength * 0.1;
                    const spotSize = wingScale * (0.1 + i * 0.02);
                    
                    ctx.beginPath();
                    ctx.arc(spotX, spotY, spotSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Mirror spots for left wing
                    ctx.beginPath();
                    ctx.arc(-spotX, spotY, spotSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                break;
                
            case 2: // Stripes
                // Upper wing stripes
                ctx.lineWidth = wingScale * 0.1;
                ctx.strokeStyle = this.patternColor;
                
                for (let i = 0; i < 3; i++) {
                    const y = -bodyLength * 0.3 + i * bodyLength * 0.15;
                    
                    // Right wing stripe
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.quadraticCurveTo(
                        bodyWidth * 0.8, y - bodyLength * 0.1,
                        bodyWidth * 1.6, y
                    );
                    ctx.stroke();
                    
                    // Left wing stripe (mirrored)
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.quadraticCurveTo(
                        -bodyWidth * 0.8, y - bodyLength * 0.1,
                        -bodyWidth * 1.6, y
                    );
                    ctx.stroke();
                }
                break;
        }
        
        ctx.restore();
        
        // Draw body
        this.drawBody(bodyWidth, bodyLength);
    }
    
    drawBody(bodyWidth, bodyLength) {
        // Body
        ctx.fillStyle = '#555555'; // Darker body
        
        // Main body
        ctx.beginPath();
        ctx.ellipse(0, 0, bodyWidth, bodyLength * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Head
        ctx.beginPath();
        ctx.arc(0, -bodyLength * 0.4, bodyWidth * 0.8, 0, Math.PI * 2);
        ctx.fill();
        
        // Antennae
        ctx.strokeStyle = '#555555';
        ctx.lineWidth = 1;
        
        // Left antenna
        ctx.beginPath();
        ctx.moveTo(0, -bodyLength * 0.4);
        let antennaEndX = -bodyWidth * 1.5;
        let antennaEndY = -bodyLength * 0.8;
        ctx.quadraticCurveTo(
            -bodyWidth * 0.8, -bodyLength * 0.7,
            antennaEndX, antennaEndY
        );
        ctx.stroke();
        
        // Antenna ball
        ctx.beginPath();
        ctx.arc(antennaEndX, antennaEndY, bodyWidth * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Right antenna
        ctx.beginPath();
        ctx.moveTo(0, -bodyLength * 0.4);
        antennaEndX = bodyWidth * 1.5;
        ctx.quadraticCurveTo(
            bodyWidth * 0.8, -bodyLength * 0.7,
            antennaEndX, antennaEndY
        );
        ctx.stroke();
        
        // Antenna ball
        ctx.beginPath();
        ctx.arc(antennaEndX, antennaEndY, bodyWidth * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = 'white';
        
        // Left eye
        ctx.beginPath();
        ctx.arc(-bodyWidth * 0.4, -bodyLength * 0.4, bodyWidth * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Right eye
        ctx.beginPath();
        ctx.arc(bodyWidth * 0.4, -bodyLength * 0.4, bodyWidth * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Pupils
        ctx.fillStyle = 'black';
        
        // Left pupil
        ctx.beginPath();
        ctx.arc(-bodyWidth * 0.4, -bodyLength * 0.4, bodyWidth * 0.15, 0, Math.PI * 2);
        ctx.fill();
        
        // Right pupil
        ctx.beginPath();
        ctx.arc(bodyWidth * 0.4, -bodyLength * 0.4, bodyWidth * 0.15, 0, Math.PI * 2);
        ctx.fill();
        
        // Smile
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, -bodyLength * 0.35, bodyWidth * 0.3, 0.2, Math.PI - 0.2);
        ctx.stroke();
    }
    
    drawFairyBody(bodyWidth, bodyLength) {
        // Slimmer body for fairy butterfly
        ctx.fillStyle = '#555555';
        
        // Main body - slimmer
        ctx.beginPath();
        ctx.ellipse(0, 0, bodyWidth * 0.8, bodyLength * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Head - smaller
        ctx.beginPath();
        ctx.arc(0, -bodyLength * 0.4, bodyWidth * 0.7, 0, Math.PI * 2);
        ctx.fill();
        
        // Longer, more elegant antennae
        ctx.strokeStyle = '#555555';
        ctx.lineWidth = 1;
        
        // Left antenna - curved
        ctx.beginPath();
        ctx.moveTo(0, -bodyLength * 0.4);
        let antennaEndX = -bodyWidth * 2;
        let antennaEndY = -bodyLength * 1.0;
        ctx.quadraticCurveTo(
            -bodyWidth, -bodyLength * 0.8,
            antennaEndX, antennaEndY
        );
        ctx.stroke();
        
        // Small glowing dot at antenna end
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(antennaEndX, antennaEndY, bodyWidth * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Right antenna - curved
        ctx.strokeStyle = '#555555';
        ctx.beginPath();
        ctx.moveTo(0, -bodyLength * 0.4);
        antennaEndX = bodyWidth * 2;
        ctx.quadraticCurveTo(
            bodyWidth, -bodyLength * 0.8,
            antennaEndX, antennaEndY
        );
        ctx.stroke();
        
        // Small glowing dot at antenna end
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(antennaEndX, antennaEndY, bodyWidth * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Larger, more expressive eyes
        ctx.fillStyle = 'white';
        
        // Left eye
        ctx.beginPath();
        ctx.arc(-bodyWidth * 0.4, -bodyLength * 0.4, bodyWidth * 0.4, 0, Math.PI * 2);
        ctx.fill();
        
        // Right eye
        ctx.beginPath();
        ctx.arc(bodyWidth * 0.4, -bodyLength * 0.4, bodyWidth * 0.4, 0, Math.PI * 2);
        ctx.fill();
        
        // Pupils - larger and more anime-like
        ctx.fillStyle = 'black';
        
        // Left pupil
        ctx.beginPath();
        ctx.arc(-bodyWidth * 0.4, -bodyLength * 0.4, bodyWidth * 0.25, 0, Math.PI * 2);
        ctx.fill();
        
        // Right pupil
        ctx.beginPath();
        ctx.arc(bodyWidth * 0.4, -bodyLength * 0.4, bodyWidth * 0.25, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye highlights
        ctx.fillStyle = 'white';
        
        // Left eye highlight
        ctx.beginPath();
        ctx.arc(-bodyWidth * 0.5, -bodyLength * 0.45, bodyWidth * 0.1, 0, Math.PI * 2);
        ctx.fill();
        
        // Right eye highlight
        ctx.beginPath();
        ctx.arc(bodyWidth * 0.3, -bodyLength * 0.45, bodyWidth * 0.1, 0, Math.PI * 2);
        ctx.fill();
        
        // Cute smile
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(0, -bodyLength * 0.33, bodyWidth * 0.3, 0.1, Math.PI - 0.1);
        ctx.stroke();
    }
    
    drawHeart(x, y, size) {
        // Helper function to draw a heart shape
        const halfSize = size / 2;
        
        ctx.beginPath();
        ctx.moveTo(x, y + halfSize * 0.7);
        
        // Left curve
        ctx.bezierCurveTo(
            x, y,
            x - halfSize, y,
            x - halfSize, y - halfSize * 0.5
        );
        
        // Left top curve
        ctx.bezierCurveTo(
            x - halfSize, y - halfSize * 1.5,
            x, y - halfSize * 1.5,
            x, y - halfSize * 0.7
        );
        
        // Right top curve
        ctx.bezierCurveTo(
            x, y - halfSize * 1.5,
            x + halfSize, y - halfSize * 1.5,
            x + halfSize, y - halfSize * 0.5
        );
        
        // Right curve
        ctx.bezierCurveTo(
            x + halfSize, y,
            x, y,
            x, y + halfSize * 0.7
        );
        
        ctx.fill();
    }
}

class Crow {
    constructor(startX, startY, index) {
        this.x = startX;
        this.y = startY;
        this.direction = Math.random() < 0.5 ? -1 : 1;
        this.velocity = { x: 0, y: 0 };
        this.acceleration = { x: 0, y: 0 };
        this.baseSpeed = 1.2; // Faster than regular birds
        this.state = 'flying';
        this.stateTimer = 0;
        this.path = [];
        this.pathIndex = 0;
        this.target = null;
        this.pecking = false;
        this.peckTimer = 0;
        this.wingFlap = Math.random() * Math.PI * 2; // Randomize wing position
        this.isFlying = true;
        this.flockIndex = index; // Position in the murder of crows
        this.moveOffset = Math.random() * Math.PI * 2; // For synchronized movement
        this.wormsEaten = 0;
    }
    
    applyForce(force) {
        this.acceleration.x += force.x;
        this.acceleration.y += force.y;
    }
    
    findNearestWorm() {
        let closestWorm = null;
        let closestDist = Infinity;
        
        for (const worm of worms) {
            const dist = distance(this.x, this.y, worm.x, worm.y);
            if (dist < closestDist) {
                closestDist = dist;
                closestWorm = worm;
            }
        }
        
        if (closestWorm && closestDist < 500) { // Much larger vision radius
            this.target = {
                type: 'worm',
                worm: closestWorm,
                x: closestWorm.x,
                y: closestWorm.y
            };
            this.state = 'hunting';
            this.stateTimer = 0;
            return true;
        }
        
        return false;
    }
    
    generatePath(targetX, targetY) {
        // Clear existing path
        this.path = [];
        this.pathIndex = 0;
        
        // Keep target coordinates within visible bounds
        targetX = Math.max(50, Math.min(canvas.width - 50, targetX));
        targetY = Math.max(50, Math.min(canvas.height * GROUND_HEIGHT_RATIO - 20, targetY));
        
        // Start path at current position
        this.path.push({ x: this.x, y: this.y });
        
        // For longer paths, add intermediate points for more natural movement
        const dist = distance(this.x, this.y, targetX, targetY);
        
        if (dist > 100) {
            // Add proportional waypoints based on distance
            const waypoints = Math.min(3, 1 + Math.floor(dist / 200));
            
            for (let i = 0; i < waypoints; i++) {
                const progress = (i + 1) / (waypoints + 1);
                
                // Arc height for natural flight
                const arcHeight = Math.sin(progress * Math.PI) * 50;
                
                // Calculate position with arc
                const wayX = this.x + (targetX - this.x) * progress;
                const wayY = this.y + (targetY - this.y) * progress - arcHeight;
                
                this.path.push({ x: wayX, y: wayY });
            }
        }
        
        // Add target as final waypoint
        this.path.push({ x: targetX, y: targetY });
        
        // Set direction
        this.direction = targetX > this.x ? 1 : -1;
    }
    
    update(deltaTime) {

        let dx, dy, dist; // Declare once up here

        this.stateTimer += deltaTime;
        this.wingFlap += 0.2 * deltaTime / 16;
        
        // Reset acceleration each frame
        this.acceleration = { x: 0, y: 0 };
        
        // Update based on state
        switch (this.state) {
            case 'flying':
                // Follow flock path if not hunting
                this.velocity.x *= 0.97;
                this.velocity.y *= 0.97;
                
                // Check for worms periodically
                if (Math.random() < 0.05) {
                    if (this.findNearestWorm()) {
                        break; // Found a worm, switch to hunting
                    }
                }
                
                // Check for flock leader's path
                if (crows.length > 0 && this.flockIndex > 0) {
                    const leader = crows[0];
                    if (leader && leader.path && leader.path.length > 0) {
                        // Follow leader with slight offset based on flock position
                        const pathTarget = leader.path[Math.min(leader.pathIndex, leader.path.length - 1)];
                        
                        // Add periodic circular motion for flock formation
                        const circleRadius = 30 + this.flockIndex * 10;
                        const circleAngle = this.moveOffset + simulationTime * 0.0005;
                        const offsetX = Math.cos(circleAngle) * circleRadius;
                        const offsetY = Math.sin(circleAngle) * circleRadius * 0.5;
                        
                        // Move toward leader's path plus offset
                        if (pathTarget) {
                            const dx = (pathTarget.x + offsetX) - this.x;
                            const dy = (pathTarget.y + offsetY) - this.y;
                            const dir = normalize(dx, dy);
                            
                            this.applyForce({ 
                                x: dir.x * 0.02, 
                                y: dir.y * 0.01 
                            });
                            
                            // Face direction of movement
                            if (Math.abs(dx) > 2) {
                                this.direction = dx > 0 ? 1 : -1;
                            }
                        }
                    }
                } else if (this.path && this.path.length > 0 && this.pathIndex < this.path.length) {
                    // Leader or solo crow - follow own path
                    const waypoint = this.path[this.pathIndex];
                    const waypointDist = distance(this.x, this.y, waypoint.x, waypoint.y);
                    
                    if (waypointDist < 10) {
                        // Reached waypoint, move to next
                        this.pathIndex++;
                        
                        // If reached final waypoint, circle the area
                        if (this.pathIndex >= this.path.length) {
                            // Circle around current position
                            this.circleCurrent();
                        }
                    } else {
                        // Move toward waypoint
                        const dx = waypoint.x - this.x;
                        const dy = waypoint.y - this.y;
                        const dir = normalize(dx, dy);
                        
                        this.applyForce({ 
                            x: dir.x * 0.02, 
                            y: dir.y * 0.01 
                        });
                        
                        // Face direction of movement
                        if (Math.abs(dx) > 2) {
                            this.direction = dx > 0 ? 1 : -1;
                        }
                    }
                } else {
                    // No path, pick new destination
                    const groundY = canvas.height * GROUND_HEIGHT_RATIO - 30;
                    const targetX = Math.random() * canvas.width;
                    const targetY = Math.random() < 0.7 ? groundY : 100 + Math.random() * 150;
                    this.generatePath(targetX, targetY);
                }
                break;
                
            case 'hunting':
                // Check if target is valid
                if (!this.target || 
                    (this.target.type === 'worm' && worms.indexOf(this.target.worm) === -1)) {
                    // Target is gone, go back to flying
                    this.state = 'flying';
                    this.stateTimer = 0;
                    this.target = null;
                    break;
                }
                
                // Move toward target
                const huntTargetDist = distance(this.x, this.y, this.target.x, this.target.y);
                
                if (huntTargetDist < 15) {
                    // Reached target - eat it
                    if (this.target.type === 'worm') {
                        const wormIndex = worms.indexOf(this.target.worm);
                        if (wormIndex !== -1) {
                            worms.splice(wormIndex, 1);
                            this.wormsEaten++;
                            debugLog(`Crow ate worm at (${this.target.x}, ${this.target.y})`);
                        }
                    }
                    
                    // Crows immediately look for more worms
                    if (!this.findNearestWorm()) {
                        this.state = 'flying';
                        this.stateTimer = 0;
                    }
                    
                    this.target = null;
                } else {
                    // Move toward target
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const dir = normalize(dx, dy);
                    
                    // Adjust speed based on distance
                    const speedFactor = huntTargetDist < 30 ? 
                        0.3 + huntTargetDist / 30 * 0.7 : 1.0;
                    
                    this.applyForce({ 
                        x: dir.x * 0.02 * speedFactor, 
                        y: dir.y * 0.01 * speedFactor 
                    });
                    
                    // Face direction of movement
                    if (Math.abs(dx) > 2) {
                        this.direction = dx > 0 ? 1 : -1;
                    }
                    
                    // If hunting is taking too long, give up
                    if (this.stateTimer > 5000) {
                        this.state = 'flying';
                        this.stateTimer = 0;
                        this.target = null;
                    }
                }
                break;
                
            case 'circling':
                // Circle around the current position
                if (this.stateTimer > 10000) {
                    this.state = 'flying';
                    this.stateTimer = 0;
                    this.findNearestWorm();
                }
                
                const circleTime = simulationTime * 0.001;
                const circleX = Math.cos(circleTime + this.moveOffset) * 100;
                const circleY = Math.sin(circleTime + this.moveOffset) * 50;
                
                const circleCenterX = this.x - circleX;
                const circleCenterY = this.y - circleY;
                
                const dx = circleCenterX + circleX - this.x;
                const dy = circleCenterY + circleY - this.y;
                
                const dir = normalize(dx, dy);
                this.applyForce({ 
                    x: dir.x * 0.01, 
                    y: dir.y * 0.005 
                });
                
                // Check for worms while circling
                if (Math.random() < 0.05) {
                    this.findNearestWorm();
                }
                break;
        }
        
        // Update position with velocity
        this.velocity.x += this.acceleration.x * (deltaTime / 16);
        this.velocity.y += this.acceleration.y * (deltaTime / 16);
        
        // Limit speed
        const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
        if (speed > this.baseSpeed) {
            this.velocity.x = (this.velocity.x / speed) * this.baseSpeed;
            this.velocity.y = (this.velocity.y / speed) * this.baseSpeed;
        }
        
        // Update position
        this.x += this.velocity.x * (deltaTime / 16);
        this.y += this.velocity.y * (deltaTime / 16);
        
        // Keep crows in bounds
        validatePosition(this);
        
        return false; // Crow stays alive
    }
    
    circleCurrent() {
        this.state = 'circling';
        this.stateTimer = 0;
    }
    
    draw() {
        // Similar to bird drawing but black
        const sizeMultiplier = 1.05; // Slightly larger than regular birds
        
        // Determine if wings should be flapping
        const isFlapping = true; // Crows are always flying/flapping
        
        // Calculate position adjustments for flapping
        const yOffset = Math.sin(this.wingFlap * 0.5) * 1.5;
        
        // Wing position and spread
        const wingSpread = Math.abs(Math.sin(this.wingFlap)) * 1.2;
        const wingY = Math.cos(this.wingFlap) * 5;
        
        // Draw body - deep black
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.ellipse(
            this.x, 
            this.y + yOffset, 
            10 * sizeMultiplier, 
            7 * sizeMultiplier, 
            0, 0, Math.PI * 2
        );
        ctx.fill();
        
        // Draw the tail - longer for crows
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        if (this.direction > 0) {
            ctx.moveTo(this.x - 10 * sizeMultiplier, this.y + yOffset);
            ctx.lineTo(this.x - 18 * sizeMultiplier, this.y - 2 * sizeMultiplier + yOffset);
            ctx.lineTo(this.x - 18 * sizeMultiplier, this.y + 2 * sizeMultiplier + yOffset);
        } else {
            ctx.moveTo(this.x + 10 * sizeMultiplier, this.y + yOffset);
            ctx.lineTo(this.x + 18 * sizeMultiplier, this.y - 2 * sizeMultiplier + yOffset);
            ctx.lineTo(this.x + 18 * sizeMultiplier, this.y + 2 * sizeMultiplier + yOffset);
        }
        ctx.fill();

        // Draw wings with dark color
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;

        if (this.direction > 0) {
            // Wing with stroke
            ctx.beginPath();
            ctx.moveTo(this.x - 5, this.y + yOffset);
            ctx.quadraticCurveTo(
                this.x - 8 * wingSpread, 
                this.y + 2 * wingSpread + wingY,
                this.x - 10 * wingSpread * sizeMultiplier, 
                this.y + 3 * sizeMultiplier + wingY
            );
            ctx.lineTo(
                this.x - 9 * wingSpread * sizeMultiplier,
                this.y + 9 * sizeMultiplier + wingY
            );
            ctx.quadraticCurveTo(
                this.x - 7 * wingSpread,
                this.y + 7 * wingSpread + wingY,
                this.x - 5,
                this.y + 3 + yOffset
            );
            ctx.closePath();
            ctx.stroke();
            
            ctx.fillStyle = '#000000';
            ctx.fill();
        } else {
            ctx.beginPath();
            ctx.moveTo(this.x + 5, this.y + yOffset);
            ctx.quadraticCurveTo(
                this.x + 8 * wingSpread,
                this.y + 2 * wingSpread + wingY,
                this.x + 10 * wingSpread * sizeMultiplier,
                this.y + 3 * sizeMultiplier + wingY
            );
            ctx.lineTo(
                this.x + 9 * wingSpread * sizeMultiplier,
                this.y + 9 * sizeMultiplier + wingY
            );
            ctx.quadraticCurveTo(
                this.x + 7 * wingSpread,
                this.y + 7 * wingSpread + wingY,
                this.x + 5,
                this.y + 3 + yOffset
            );
            ctx.closePath();
            ctx.stroke();
            
            ctx.fillStyle = '#000000';
            ctx.fill();
        }
        
        // Draw the head
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(
            this.x + (this.direction * 8 * sizeMultiplier), 
            this.y - 2 * sizeMultiplier + yOffset, 
            6 * sizeMultiplier, 
            0, Math.PI * 2
        );
        ctx.fill();
        
        // Draw beak - gray for crow orange chnaged 
        ctx.fillStyle = '#FF8800';
        ctx.beginPath();
        if (this.direction > 0) {
            ctx.moveTo(this.x + 12 * sizeMultiplier, this.y - 3 * sizeMultiplier + yOffset);
            ctx.lineTo(this.x + 18 * sizeMultiplier, this.y - 2 * sizeMultiplier + yOffset);
            ctx.lineTo(this.x + 12 * sizeMultiplier, this.y + yOffset);
        } else {
            ctx.moveTo(this.x - 12 * sizeMultiplier, this.y - 3 * sizeMultiplier + yOffset);
            ctx.lineTo(this.x - 18 * sizeMultiplier, this.y - 2 * sizeMultiplier + yOffset);
            ctx.lineTo(this.x - 12 * sizeMultiplier, this.y + yOffset);
        }
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(
            this.x + (this.direction * 8 * sizeMultiplier), 
            this.y - 3 * sizeMultiplier + yOffset, 
            2 * sizeMultiplier,
            0, Math.PI * 2
        );
        ctx.fill();
        
        // Eye pupils - black
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(
            this.x + (this.direction * 8.5 * sizeMultiplier), 
            this.y - 3 * sizeMultiplier + yOffset, 
            1 * sizeMultiplier,
            0, Math.PI * 2
        );
        ctx.fill();
    }
}

// Function to check if we should spawn crows
function checkForCrowVisit(deltaTime) {
    // Update timer if visit is in progress
    if (crowVisitInProgress) {
        crowVisitTimer += deltaTime;
        
        // Check if visit should end
        if (crowVisitTimer >= CROW_VISIT_DURATION) {
            // Make crows leave
            makeCrowsLeave();
            crowVisitInProgress = false;
            crowVisitTimer = 0;
            debugLog("Murder of crows leaving");
        }
        return;
    }
    
    // Don't spawn crows if a scarecrow is present
    if (scarecrow) {
        return;
    }
    
    // Only check occasionally
    if (Math.random() < 0.001) { // 0.1% chance per frame
        // Check if worm population is excessive
        if (worms.length >= CROW_WORM_THRESHOLD) {
            // 20% chance to spawn crows when threshold reached
            if (Math.random() < 0.2) {
                spawnMurderOfCrows();
            }
        }
    }
}

// Spawn a murder of crows
function spawnMurderOfCrows() {
    // Don't spawn if already visiting
    if (crowVisitInProgress) return;
    
    // Clear any existing crows
    crows = [];
    
    // Dramatic effect - darken sky slightly
    addSpecialEffect({
        type: 'darkening',
        duration: 5000,
        intensity: 0.2
    });
    
    // Add a sound effect if wind chimes are enabled
    if (windChimeEnabled && audioContext) {
        // Play ominous crow sound (low notes)
        const notes = ['C2', 'G2', 'D2'];
        for (let i = 0; i < notes.length; i++) {
            setTimeout(() => {
                playNote(notes[i], 2);
            }, i * 500);
        }
    }
    
    // Decide where crows will enter from
    const entryEdge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
    
    // Entry point depends on edge
    let entryX, entryY;
    switch (entryEdge) {
        case 0: // Top
            entryX = canvas.width / 2;
            entryY = -50;
            break;
        case 1: // Right
            entryX = canvas.width + 50;
            entryY = canvas.height * 0.3;
            break;
        case 2: // Bottom
            entryX = canvas.width / 2;
            entryY = canvas.height + 50;
            break;
        case 3: // Left
            entryX = -50;
            entryY = canvas.height * 0.3;
            break;
    }
    
    // Spawn 5-7 crows
    const crowCount = 5 + Math.floor(Math.random() * 3);
    
    for (let i = 0; i < crowCount; i++) {
        const crow = new Crow(entryX, entryY, i);
        
        // Set initial target - area with worms
        const targetArea = getWormHotspot();
        const targetX = targetArea.x + (Math.random() - 0.5) * 100;
        const targetY = targetArea.y + (Math.random() - 0.5) * 50;
        
        crow.generatePath(targetX, targetY);
        crows.push(crow);
    }
    
    crowVisitInProgress = true;
    crowVisitTimer = 0;

    debugLog(`Murder of ${crowCount} crows has arrived!`);
    addDiaryEntry(`The Great Worm Feast! A murder of ${crowCount} crows descended upon the garden.`, 'visitor');
}

// Make all crows leave
function makeCrowsLeave() {
    // Choose an exit point
    const exitEdge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
    
    // Exit coordinates
    let exitX, exitY;
    switch (exitEdge) {
        case 0: // Top
            exitX = canvas.width / 2;
            exitY = -100;
            break;
        case 1: // Right
            exitX = canvas.width + 100;
            exitY = canvas.height * 0.3;
            break;
        case 2: // Bottom
            exitX = canvas.width / 2;
            exitY = canvas.height + 100;
            break;
        case 3: // Left
            exitX = -100;
            exitY = canvas.height * 0.3;
            break;
    }
    
    // Give all crows a path to exit
    for (let i = 0; i < crows.length; i++) {
        const crow = crows[i];
        // Add slight offsets for formation
        const offsetX = exitX + (Math.random() - 0.5) * 150;
        const offsetY = exitY + (Math.random() - 0.5) * 50;
        
        // Create a state for leaving
        crow.state = 'leaving';
        crow.stateTimer = 0;
        
        // Generate path with intermediate points for smoother exit
        // Start with current position
        crow.path = [{ x: crow.x, y: crow.y }];
        
        // Add mid-point for natural arc
        const midX = crow.x + (offsetX - crow.x) * 0.5;
        const midY = crow.y + (offsetY - crow.y) * 0.3 - 50; // Higher mid-point for arc
        crow.path.push({ x: midX, y: midY });
        
        // Add exit point
        crow.path.push({ x: offsetX, y: offsetY });
        
        // Reset path index
        crow.pathIndex = 0;
        
        // Set direction based on exit
        crow.direction = offsetX > crow.x ? 1 : -1;
        
        debugLog(`Crow ${i} leaving toward (${offsetX}, ${offsetY})`);
    }
    
    // Don't remove crows with timeout anymore - they'll remove themselves when off-screen
}

// Find area with most worms
function getWormHotspot() {
    if (worms.length === 0) {
        return { 
            x: canvas.width / 2, 
            y: canvas.height * GROUND_HEIGHT_RATIO 
        };
    }
    
    // Divide canvas into grid cells
    const gridSize = 100;
    const gridCols = Math.ceil(canvas.width / gridSize);
    const gridRows = Math.ceil(canvas.height / gridSize);
    const grid = Array(gridRows).fill().map(() => Array(gridCols).fill(0));
    
    // Count worms in each grid cell
    for (const worm of worms) {
        const col = Math.min(gridCols - 1, Math.max(0, Math.floor(worm.x / gridSize)));
        const row = Math.min(gridRows - 1, Math.max(0, Math.floor(worm.y / gridSize)));
        grid[row][col]++;
    }
    
    // Find cell with most worms
    let maxWorms = 0;
    let maxRow = 0;
    let maxCol = 0;
    
    for (let row = 0; row < gridRows; row++) {
        for (let col = 0; col < gridCols; col++) {
            if (grid[row][col] > maxWorms) {
                maxWorms = grid[row][col];
                maxRow = row;
                maxCol = col;
            }
        }
    }
    
    // Return center of that cell
    return {
        x: maxCol * gridSize + gridSize / 2,
        y: maxRow * gridSize + gridSize / 2
    };
}

// Add special effect (like screen darkening for crow arrival)

// ADD THIS FUNCTION HERE:
function addSpecialEffect(effect) {
    specialEffects.push(effect);
}

function drawSpecialEffects(deltaTime) {
    // Update and remove expired effects
    for (let i = specialEffects.length - 1; i >= 0; i--) {
        const effect = specialEffects[i];
        
        // Update effect timer
        if (!effect.timer) effect.timer = 0;
        effect.timer += deltaTime * 0.5; // Half speed
        
        // Remove expired effects
        if (effect.timer >= effect.duration) {
            specialEffects.splice(i, 1);
            continue;
        }
        
        // Calculate effect progress (0 to 1)
        const progress = effect.timer / effect.duration;
        
        // Draw based on effect type
        switch (effect.type) {
            case 'darkening':
                // Darken screen temporarily (like shadow of crows passing over)
                const fadeIn = progress < 0.2 ? progress / 0.2 : 1;
                const fadeOut = progress > 0.7 ? (1 - progress) / 0.3 : 1;
                const alpha = Math.min(fadeIn, fadeOut) * effect.intensity;
                
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                break;
                
            case 'sparkle':
                // Celebration sparkles
                drawSparkleEffect(effect);
                break;
                
            case 'rainbowButterfly':
                // Rainbow butterfly effect
                const opacity = progress < 0.2 ? progress / 0.2 : 
                               (progress > 0.8 ? (1 - progress) / 0.2 : 1);
                
                const wingFlap = progress * Math.PI * 10; // Fast wing flapping
                const wingOpen = Math.abs(Math.sin(wingFlap));
                
                // Draw a simple, glowing butterfly
                ctx.save();
                ctx.globalAlpha = opacity;
                
                // Draw wings
                ctx.fillStyle = effect.color;
                
                // Upper wings
                ctx.beginPath();
                ctx.ellipse(
                    effect.x + 5, 
                    effect.y - effect.size * 0.3, 
                    effect.size * wingOpen, 
                    effect.size * 1.2, 
                    -Math.PI * 0.2, 
                    0, Math.PI * 2
                );
                ctx.fill();
                
                ctx.beginPath();
                ctx.ellipse(
                    effect.x - 5, 
                    effect.y - effect.size * 0.3, 
                    effect.size * wingOpen, 
                    effect.size * 1.2, 
                    Math.PI * 0.2, 
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Body
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.ellipse(
                    effect.x, 
                    effect.y, 
                    effect.size * 0.2, 
                    effect.size * 0.7, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
                
                ctx.restore();
                break;
                
            // ADD NEW CASES HERE:
            case 'dissolve':
                // Dissolving effect for ant hill
                const dissolveProgress = effect.timer / effect.duration;
                const dissolveFadeOut = 1 - dissolveProgress;
                
                // Shrinking, fading circles
                ctx.fillStyle = `rgba(139, 69, 19, ${dissolveFadeOut * 0.7})`;
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2;
                    const distance = effect.size * (0.5 + dissolveProgress * 0.5);
                    const size = effect.size * 0.3 * (1 - dissolveProgress);
                    
                    const x = effect.x + Math.cos(angle) * distance;
                    const y = effect.y + Math.sin(angle) * distance;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                break;

            case 'foodCollection':
                // Food disappearing into hill
                const foodProgress = effect.timer / effect.duration;
                const foodFade = 1 - foodProgress;
                
                // Shrinking food particle
                ctx.fillStyle = `rgba(210, 180, 140, ${foodFade})`;
                const foodSize = 3 * (1 - foodProgress);
                
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, foodSize, 0, Math.PI * 2);
                ctx.fill();
                break;
        }
    } // <-- This closes the for loop
} // <-- Missing closing brace for the function






// Draw sparkle effects (for scarecrow creation celebration)
function drawSparkleEffect(effect) {
    const progress = effect.timer / effect.duration;
    const opacity = progress < 0.2 ? progress / 0.2 : 
                    (progress > 0.8 ? (1 - progress) / 0.2 : 1);
    
    // Draw a series of sparkles
    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
    
    for (let i = 0; i < 20; i++) {
        const angle = (i / 20) * Math.PI * 2;
        const radius = 20 + Math.sin(progress * Math.PI * 4 + i) * 10;
        
        const sparkleX = effect.x + Math.cos(angle) * radius;
        const sparkleY = effect.y + Math.sin(angle) * radius;
        const sparkleSize = 2 + Math.sin(progress * Math.PI * 8 + i * 0.7) * 2;
        
        ctx.beginPath();
        ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Add some golden sparkles
    ctx.fillStyle = `rgba(255, 215, 0, ${opacity})`;
    
    for (let i = 0; i < 15; i++) {
        const angle = (i / 15) * Math.PI * 2 + progress * Math.PI;
        const radius = 15 + Math.cos(progress * Math.PI * 3 + i) * 15;
        
        const sparkleX = effect.x + Math.cos(angle) * radius;
        const sparkleY = effect.y + Math.sin(angle) * radius;
        const sparkleSize = 1.5 + Math.cos(progress * Math.PI * 6 + i * 0.5) * 1.5;
        
        ctx.beginPath();
        ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Check if conditions are right for a rainbow
function checkForRainbow() {
    // If rain just stopped, wasRaining is true, and we have butterflies, show a rainbow
    if (wasRaining && !isRaining && butterflies.length >= 3 && !rainbowVisible) {
        createRainbow();
        debugLog("Rainbow appears after the rain!");
    }
}

class Owl {
    constructor(x, y) {
        this.x = x || (Math.random() < 0.5 ? -30 : canvas.width + 30);
        this.y = y || (canvas.height * 0.3 + Math.random() * 100);
        this.direction = this.x < canvas.width / 2 ? 1 : -1;
        this.velocity = { x: 0, y: 0 };
        this.acceleration = { x: 0, y: 0 };
        this.baseSpeed = 1.5; // Faster than birds, slower than crows
        this.state = 'hunting'; // hunting, swooping, perching, leaving
        this.stateTimer = 0;
        this.wingFlap = Math.random() * Math.PI * 2;
        this.target = null;
        this.swoopingY = 0; // For swooping animation
        this.hasKilled = false; // Track if owl killed something this visit
        this.perchTree = null; // Tree to perch in during day
        this.perchPosition = null; // Position in tree
        
        // Owl size and appearance
        this.size = 1.3; // Larger than birds
        this.bodyColor = '#8B4513'; // Brown
        this.wingColor = '#A0522D'; // Darker brown
        this.eyeColor = '#FFA500'; // Orange eyes
    }
    
    applyForce(force) {
        this.acceleration.x += force.x;
        this.acceleration.y += force.y;
    }
    
    findTarget() {
        // First priority: Rat Kings (main target!)
        for (const rat of rats) {
            if (rat.isRatKing) {
                this.target = {
                    type: 'ratKing',
                    rat: rat,
                    x: rat.x,
                    y: rat.y
                };
                this.state = 'hunting';
                this.stateTimer = 0;
                debugLog(`Owl targeting rat king at (${rat.x}, ${rat.y})`);
                return true;
            }
        }
        
        // Second priority: Regular rats
        if (rats.length > 0) {
            const randomIndex = Math.floor(Math.random() * rats.length);
            const rat = rats[randomIndex];
            this.target = {
                type: 'rat',
                rat: rat,
                x: rat.x,
                y: rat.y
            };
            this.state = 'hunting';
            this.stateTimer = 0;
            debugLog(`Owl targeting regular rat at (${rat.x}, ${rat.y})`);
            return true;
        }
        
        // Nothing found
        return false;
    }
    
    update(deltaTime) {
        let dx, dy, dist; // Declare once up here
        this.stateTimer += deltaTime;
        this.wingFlap += 0.15 * deltaTime / 16; // Slower wing flap than birds
        
        // Reset acceleration each frame
        this.acceleration = { x: 0, y: 0 };
        
        // Check day/night transition
        const isNight = timeOfDay >= 1;
        
        if (!isNight && this.state !== 'perching' && this.state !== 'leaving') {
            // Daytime - find a tree to perch in or leave
            if (trees.length > 0 && Math.random() < 0.7) {
                this.findPerchTree();
            } else {
                this.state = 'leaving';
                this.stateTimer = 0;
                debugLog("Owl leaving as day breaks");
            }
        }
        
        // State machine
        switch (this.state) {
            case 'hunting':
                // Check if target is still valid
                if (this.target) {
                    if ((this.target.type === 'rat' || this.target.type === 'ratKing') && 
                        rats.indexOf(this.target.rat) === -1) {
                        // Target is gone
                        this.target = null;
                    } else {
                        // Update target position
                        this.target.x = this.target.rat.x;
                        this.target.y = this.target.rat.y;
                    }
                }
                
                // Find new target if needed
                if (!this.target && isNight) {
                    if (!this.findTarget()) {
                        // Nothing to hunt - patrol
                        this.state = 'patrolling';
                        this.stateTimer = 0;
                    }
                }
                
                // Move toward target
                if (this.target) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 80) {
                        // Close enough to swoop down
                        this.state = 'swooping';
                        this.stateTimer = 0;
                        this.swoopingY = this.y; // Remember starting height
                    } else {
                        // Move toward target
                        const dir = normalize(dx, dy);
                        this.applyForce({ 
                            x: dir.x * 0.015, 
                            y: dir.y * 0.01 
                        });
                        
                        // Face direction of movement
                        if (Math.abs(dx) > 2) {
                            this.direction = dx > 0 ? 1 : -1;
                        }
                    }
                }
                
                // Add slight gravity
                this.applyForce({ x: 0, y: GRAVITY * 0.5 });
                
                // Check for timeout
                if (this.stateTimer > 15000) {
                    this.state = 'patrolling';
                    this.stateTimer = 0;
                    this.target = null;
                }
                break;
                
            case 'swooping':
                if (!this.target) {
                    this.state = 'patrolling';
                    this.stateTimer = 0;
                    break;
                }
                
                // Update target position
                if ((this.target.type === 'rat' || this.target.type === 'ratKing') && 
                    rats.indexOf(this.target.rat) !== -1) {
                    this.target.x = this.target.rat.x;
                    this.target.y = this.target.rat.y;
                }
                
                // Calculate swoop progress (0 to 1 and back to 0)
                const totalSwoopTime = 1500; // 1.5 seconds for a swoop
                const swoopProgress = this.stateTimer / totalSwoopTime;
                
                if (swoopProgress <= 0.5) {
                    // First half: diving down
                    const diveProgress = swoopProgress * 2; // 0 to 1
                    const targetY = this.target.y;
                    this.y = this.swoopingY + (targetY - this.swoopingY) * diveProgress;
                    
                    // Move toward target horizontally
                    const moveAmount = diveProgress * 1.5; // Accelerating approach
                    this.x = this.x + (this.target.x - this.x) * moveAmount * (deltaTime / 500);
                } else if (swoopProgress <= 1.0) {
                    // Second half: rising back up
                    const riseProgress = (swoopProgress - 0.5) * 2; // 0 to 1
                    this.y = this.target.y + (this.swoopingY - this.target.y) * riseProgress;
                    
                    // At the lowest point, check if we caught the target
                    if (swoopProgress >= 0.49 && swoopProgress <= 0.51 && !this.hasKilled) {
                        this.hasKilled = true;
                        
                        // Check if we're close enough to the target
                        const dist = distance(this.x, this.y, this.target.x, this.target.y);
                        if (dist < 30) {
                            // Caught the target!
                            if (this.target.type === 'rat' || this.target.type === 'ratKing') {
                                const ratIndex = rats.indexOf(this.target.rat);
                                if (ratIndex !== -1) {
                                    rats.splice(ratIndex, 1);
                                    
                                    // Play a sound if enabled
                                    if (windChimeEnabled && audioContext) {
                                        // Play a quick owl hoot
                                        const notes = ['G3', 'C4'];
                                        for (let i = 0; i < notes.length; i++) {
                                            setTimeout(() => {
                                                playNote(notes[i], 0.3);
                                            }, i * 100);
                                        }
                                    }
                                    
                                    // Add a special effect
                                    addSpecialEffect({
                                        type: 'sparkle',
                                        x: this.target.x,
                                        y: this.target.y,
                                        duration: 1000,
                                        intensity: 0.5
                                    });
                                    
                                    debugLog(`Owl caught ${this.target.type === 'ratKing' ? 'rat king' : 'rat'} at (${this.target.x}, ${this.target.y})`);
                                }
                            }
                        }
                    }
                } else {
                    // Swoop complete
                    this.state = this.hasKilled ? 'leaving' : 'hunting';
                    this.stateTimer = 0;
                    this.target = null;
                    this.hasKilled = false;
                }
                break;
                
            case 'patrolling':
                // Fly in large circles, looking for prey
                const patrolTime = this.stateTimer / 5000;
                const centerX = canvas.width / 2;
                const centerY = canvas.height * 0.3;
                const radius = canvas.width * 0.25;
                
                // Calculate desired position
                const targetX = centerX + Math.cos(patrolTime) * radius;
                const targetY = centerY + Math.sin(patrolTime * 0.5) * 50;
                
              // Move toward that position
dx = targetX - this.x;         // Just assignment, no const
dy = targetY - this.y;         // Just assignment, no const
const dir = normalize(dx, dy); // Keep const for dir - it's only declared once
                
                this.applyForce({ 
                    x: dir.x * 0.01, 
                    y: dir.y * 0.01 
                });
                
                // Face direction of movement
                if (Math.abs(dx) > 2) {
                    this.direction = dx > 0 ? 1 : -1;
                }
                
                // Occasionally look for a new target
                if (Math.random() < 0.02 && isNight) {
                    this.findTarget();
                }
                
                // Leave after a while of no activity or if day comes
                if (this.stateTimer > 30000 || !isNight) {
                    this.state = 'leaving';
                    this.stateTimer = 0;
                }
                break;
                
            case 'perching':
                if (!this.perchTree || !this.perchPosition || trees.indexOf(this.perchTree) === -1) {
                    // Tree is gone, find another or leave
                    if (trees.length > 0 && isNight) {
                        this.findPerchTree();
                    } else {
                        this.state = 'leaving';
                        this.stateTimer = 0;
                    }
                    break;
                }
                
                // Stay at perch position
                this.x = this.perchPosition.x;
                this.y = this.perchPosition.y;
                
                // No velocity while perched
                this.velocity = { x: 0, y: 0 };
                
                // Leave if night comes - time to hunt!
                if (isNight && this.stateTimer > 5000) {
                    this.state = 'hunting';
                    this.stateTimer = 0;
                    this.perchTree = null;
                    this.perchPosition = null;
                    debugLog("Owl leaves perch to hunt at night");
                }
                
                // Occasionally rotate direction
                if (Math.random() < 0.01) {
                    this.direction *= -1;
                }
                break;
                
            case 'leaving':
                // Pick a random edge to exit
                if (!this.target) {
                    const edge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
                    const exitX = edge === 1 ? canvas.width + 50 : (edge === 3 ? -50 : this.x);
                    const exitY = edge === 0 ? -50 : (edge === 2 ? canvas.height + 50 : this.y);
                    
                    this.target = { x: exitX, y: exitY };
                    
                    // Always face exit direction
                    this.direction = this.target.x > this.x ? 1 : -1;
                }
                
                // Move toward exit
                // Move toward exit
dx = this.target.x - this.x;         // Just assignment, no const
dy = this.target.y - this.y;         // Just assignment, no const
dist = Math.sqrt(dx * dx + dy * dy); // Also remove const here since dist is declared at the top
                
                this.applyForce({ 
                    x: dx / dist * 0.02, 
                    y: dy / dist * 0.02 
                });
                
                // Check if off-screen
                if (this.x < -50 || this.x > canvas.width + 50 || 
                    this.y < -50 || this.y > canvas.height + 50) {
                    debugLog("Owl has left the garden");
                    return true; // Remove owl
                }
                break;
        }

        
        
        // Update position with velocity
        this.velocity.x += this.acceleration.x * (deltaTime / 16);
        this.velocity.y += this.acceleration.y * (deltaTime / 16);
        
        // Limit speed
        const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
        if (speed > this.baseSpeed) {
            this.velocity.x = (this.velocity.x / speed) * this.baseSpeed;
            this.velocity.y = (this.velocity.y / speed) * this.baseSpeed;
        }
        
        this.x += this.velocity.x * (deltaTime / 16);
        this.y += this.velocity.y * (deltaTime / 16);
        
        // Apply position constraints
        validatePosition(this);
        
        return false; // Don't remove by default
    }
    
    findPerchTree() {
        if (trees.length === 0) return false;
        
        // Find a tall tree
        const tallTrees = trees.filter(tree => tree.trunkHeight > 120);
        
        if (tallTrees.length > 0) {
            // Pick a random tall tree
            this.perchTree = tallTrees[Math.floor(Math.random() * tallTrees.length)];
            
            // Get a perch position near the top
            this.perchPosition = {
                x: this.perchTree.x,
                y: this.perchTree.y - this.perchTree.trunkHeight * 0.9 * this.perchTree.scale
            };
            
            this.state = 'perching';
            this.stateTimer = 0;
            debugLog(`Owl found perch in tree at (${this.perchTree.x})`);
            return true;
        }
        
        // No suitable trees
        return false;
    }
    
    draw() {
    // Save current context
    ctx.save();
    
    // Translate to owl position
    ctx.translate(this.x, this.y);
    
    // Apply direction
    ctx.scale(this.direction, 1);
    
    // EXTREMELY REDUCED BOBBING: almost eliminated
    const bobAmount = Math.sin(this.wingFlap * 0.05) * 0.5; // Drastically reduced speed and amplitude
    
    // IMPORTANT: Fixed position for fur with NO bobbing
    const staticPosition = 0; // This is used for fur instead of bobAmount
    
    // Body - rounder, more cartoonish
    ctx.fillStyle = '#8B4513'; // Brown body
    ctx.beginPath();
    ctx.ellipse(0, bobAmount, 15, 18, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Belly/chest - cream colored like reference
    ctx.fillStyle = '#F5DEB3'; // Wheat color for belly
    ctx.beginPath();
    ctx.ellipse(0, bobAmount + 2, 10, 14, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw the face (moved up slightly for cuter proportions)
    ctx.fillStyle = '#F5DEB3'; // Cream face
    ctx.beginPath();
    ctx.arc(0, bobAmount - 10, 13, 0, Math.PI * 2);
    ctx.fill();
    
    // Big round eyes with black pupils and white highlights
    // Left eye
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(-5, bobAmount - 10, 5, 0, Math.PI * 2);
    ctx.fill();
    
    // Right eye
    ctx.beginPath();
    ctx.arc(5, bobAmount - 10, 5, 0, Math.PI * 2);
    ctx.fill();
    
    // Orange eye rings like in reference
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = '#FFA500'; // Orange
    ctx.beginPath();
    ctx.arc(-5, bobAmount - 10, 5, 0, Math.PI * 2);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.arc(5, bobAmount - 10, 5, 0, Math.PI * 2);
    ctx.stroke();
    
    // Black pupils
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(-5, bobAmount - 10, 3, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(5, bobAmount - 10, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // White highlights in eyes
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(-6, bobAmount - 11, 1.5, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(4, bobAmount - 11, 1.5, 0, Math.PI * 2);
    ctx.fill();
    
    // Cute small beak
    ctx.fillStyle = '#FFD700'; // Gold
    ctx.beginPath();
    ctx.moveTo(-2, bobAmount - 8);
    ctx.lineTo(2, bobAmount - 8);
    ctx.lineTo(0, bobAmount - 6);
    ctx.fill();
    
    // Ear tufts (simplified and more stylized)
    ctx.fillStyle = '#8B4513'; // Brown
    
    // Left ear
    ctx.beginPath();
    ctx.moveTo(-10, bobAmount - 18);
    ctx.lineTo(-8, bobAmount - 25);
    ctx.lineTo(-5, bobAmount - 18);
    ctx.fill();
    
    // Right ear
    ctx.beginPath();
    ctx.moveTo(5, bobAmount - 18);
    ctx.lineTo(8, bobAmount - 25);
    ctx.lineTo(10, bobAmount - 18);
    ctx.fill();
    
    // Draw feet when perched
    if (this.state === 'perching') {
        ctx.fillStyle = '#FFD700'; // Gold
        
        // Left foot
        ctx.beginPath();
        ctx.ellipse(-5, bobAmount + 18, 3, 2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Right foot
        ctx.beginPath();
        ctx.ellipse(5, bobAmount + 18, 3, 2, 0, 0, Math.PI * 2);
        ctx.fill();
    }
    
    if (this.state === 'swooping' && this.stateTimer / 1500 > 0.4 && this.stateTimer / 1500 < 0.6) {
        // Talons during swooping
        ctx.fillStyle = '#FFD700'; // Gold
        ctx.lineWidth = 1.5;
        
        // Spread talons
        for (let i = -1; i <= 1; i++) {
            ctx.beginPath();
            ctx.moveTo(i * 4, bobAmount + 15);
            ctx.lineTo(i * 6, bobAmount + 22);
            ctx.stroke();
        }
    }
    
    // STATIC FUR: Using fixed position with no bobbing or movement
    ctx.fillStyle = '#A0522D'; // Darker brown
    
    // Draw many more specks for a fluffy feathered look - WITH FIXED POSITION
    for (let i = 0; i < 40; i++) { // Increased to 40 for fuller appearance
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * 9; // Varied distances for fuller appearance
        const speckX = Math.cos(angle) * distance;
        
        // IMPORTANT: Using staticPosition (0) instead of bobAmount for completely static fur
        const speckY = staticPosition + 5 + Math.sin(angle) * 10;
        
        // Vary the size and shape more for a natural fur look
        const speckWidth = 0.5 + Math.random();
        const speckHeight = 1 + Math.random() * 2;
        
        
    }
    
    // Add subtle fuzzy outline for fluffier appearance - WITH FIXED POSITION
    ctx.strokeStyle = 'rgba(160, 82, 45, 0.3)'; // Transparent brown
    ctx.lineWidth = 0.5;
    for (let i = 0; i < 20; i++) { // Increased from 15 to 20 for more fur
        const fuzz_angle = (i / 20) * Math.PI * 2;
        const fuzz_x = Math.cos(fuzz_angle) * 12;
        
        // IMPORTANT: Using staticPosition (0) instead of bobAmount for completely static fur
        const fuzz_y = staticPosition + Math.sin(fuzz_angle) * 16;
        const fuzz_length = 2 + Math.random() * 3;
        
        ctx.beginPath();
        ctx.moveTo(fuzz_x, fuzz_y);
        ctx.lineTo(
            fuzz_x + Math.cos(fuzz_angle) * fuzz_length,
            fuzz_y + Math.sin(fuzz_angle) * fuzz_length
        );
        ctx.stroke();
    }
    
    // Restore context
    ctx.restore();
    
    // Draw debug info if needed
    if (debugVisuals) {
        ctx.fillStyle = 'white';
        ctx.font = '10px Arial';
        ctx.fillText(this.state, this.x - 15, this.y - 30);
    }
}

}

// Create the rainbow
function createRainbow() {
    rainbowVisible = true;
    rainbowOpacity = 0;
    rainbowTimer = 0;
    rainbowsShown++; // Increment the counter each time a rainbow is created

     // ADD THIS LINE:
     hadRainbow = true;

     // Add diary entry
     addDiaryEntry("A beautiful rainbow arcs across the sky!", 'special');
    
    // Play a magical sound if wind chimes are enabled
    if (windChimeEnabled && audioContext) {
        // Play an ascending scale for rainbow appearance
        const notes = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5'];
        for (let i = 0; i < notes.length; i++) {
            setTimeout(() => {
                playNote(notes[i], 1.5);
            }, i * 200);
        }
    }
    
    // Make butterflies dance more energetically
    for (const butterfly of butterflies) {
        butterfly.dancingAmplitude *= 1.5;
        butterfly.dancingFrequency *= 1.2;
    }
}

// Update the rainbow
function updateRainbow(deltaTime) {
    if (!rainbowVisible) return;
    
    rainbowTimer += deltaTime;
    
    // Fade in over 5 seconds
    if (rainbowTimer < 5000) {
        rainbowOpacity = Math.min(1, rainbowTimer / 5000);
    } 
    // Stay visible for most of duration
    else if (rainbowTimer < rainbowDuration - 10000) {
        rainbowOpacity = 1;
    } 
    // Fade out over last 10 seconds
    else if (rainbowTimer < rainbowDuration) {
        rainbowOpacity = Math.max(0, 1 - (rainbowTimer - (rainbowDuration - 10000)) / 10000);
    } 
    // End rainbow
    else {
        rainbowVisible = false;
        
        // Return butterflies to normal behavior
        for (const butterfly of butterflies) {
            butterfly.dancingAmplitude /= 1.5;
            butterfly.dancingFrequency /= 1.2;
        }
    }
}

// Draw the rainbow
function drawRainbow() {
    if (!rainbowVisible || rainbowOpacity <= 0) return;
    
    const canvasCenter = canvas.width / 2;
    const groundY = canvas.height * GROUND_HEIGHT_RATIO;
    const rainbowHeight = canvas.height * 1.2; // Increased from 0.8 (50% taller)
    const rainbowWidth = canvas.width * 0.95; // Increased from 0.8 (wider)
    
    // Create a smooth pulsing effect
    const pulseAmount = Math.sin(rainbowTimer / 1000) * 0.05 + 0.95;
    
    // Rainbow colors with transparency
    const rainbowColors = [
        `rgba(255, 0, 0, ${rainbowOpacity * 0.7 * pulseAmount})`,    // Red
        `rgba(255, 127, 0, ${rainbowOpacity * 0.7 * pulseAmount})`,  // Orange
        `rgba(255, 255, 0, ${rainbowOpacity * 0.7 * pulseAmount})`,  // Yellow
        `rgba(0, 255, 0, ${rainbowOpacity * 0.7 * pulseAmount})`,    // Green
        `rgba(0, 0, 255, ${rainbowOpacity * 0.7 * pulseAmount})`,    // Blue
        `rgba(75, 0, 130, ${rainbowOpacity * 0.7 * pulseAmount})`,   // Indigo
        `rgba(148, 0, 211, ${rainbowOpacity * 0.7 * pulseAmount})`   // Violet
    ];
    
    // Draw the rainbow as a series of colored arcs
    const arcWidth = 10; // Width of each color band
    const startY = groundY - rainbowHeight * 0.5;
    
    // Save context for transformation
    ctx.save();
    ctx.globalCompositeOperation = 'lighter'; // Makes colors blend nicely
    
    // Draw each color band
    for (let i = 0; i < rainbowColors.length; i++) {
        const radius = rainbowWidth / 2 - i * arcWidth;
        
        ctx.beginPath();
        ctx.strokeStyle = rainbowColors[i];
        ctx.lineWidth = arcWidth - 1; // Slight gap between colors
        
        // Draw arc centered on screen
        ctx.arc(
            canvasCenter, 
            startY + rainbowHeight, 
            radius, 
            Math.PI, 
            Math.PI * 2
        );
        
        ctx.stroke();
    }
    
    if (rainbowOpacity > 0.5 && Math.random() < 0.05) { // Reduced from 0.3 to 0.05 - much slower shimmer
    const shimmerCount = 2 + Math.floor(Math.random() * 2); // Reduced count from 3+3 to 2+2
    
    for (let i = 0; i < shimmerCount; i++) {
        const shimmerX = canvasCenter - rainbowWidth / 2 + Math.random() * rainbowWidth;
        const shimmerY = groundY - Math.random() * 10;



            const shimmerSize = 2 + Math.random() * 4;
            
            const shimmerGradient = ctx.createRadialGradient(
                shimmerX, shimmerY, 0,
                shimmerX, shimmerY, shimmerSize
            );
            
            shimmerGradient.addColorStop(0, `rgba(255, 255, 255, ${rainbowOpacity})`);
            shimmerGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = shimmerGradient;
            ctx.beginPath();
            ctx.arc(shimmerX, shimmerY, shimmerSize, 0, Math.PI * 2);
            ctx.fill();
        } // End of shimmer for loop
    } // End of rainbowOpacity > 0.5 condition
    
    // Create occasional butterflies that briefly follow the rainbow arc
    if (rainbowOpacity > 0.7 && Math.random() < 0.01) {
        const butterflyX = canvasCenter - rainbowWidth / 2 + Math.random() * rainbowWidth;
        const arcPosition = (butterflyX - (canvasCenter - rainbowWidth / 2)) / rainbowWidth;
        const arcHeight = Math.sin(arcPosition * Math.PI) * rainbowHeight;
        const butterflyY = groundY - arcHeight;
        
        // Create a special effect rather than an actual butterfly
        specialEffects.push({
            type: 'rainbowButterfly',
            x: butterflyX,
            y: butterflyY,
            size: 5 + Math.random() * 5,
            color: rainbowColors[Math.floor(Math.random() * rainbowColors.length)],
            duration: 3000,
            timer: 0
        });
    }
    
    // Reset composite operation and restore context
    ctx.globalCompositeOperation = 'source-over';
    ctx.restore();
} // End of drawRainbow function







// Check if we should create a scarecrow (with new requirements)
function checkForScarecrow() {
    // Count completed birdhouses
    const completedBirdhouses = birdhouses.filter(bh => bh.isComplete).length;
    
    // New requirements: 1 birdhouse, seen 1 rainbow, and 10 flowers
    if (completedBirdhouses >= 1 && rainbowsShown >= 1 && flowers.length >= 10 && !scarecrowCreated) {
        createScarecrow();
    }
}

// Create the scarecrow
function createScarecrow() {
    // Find position between two birdhouses
    const completedBirdhouses = birdhouses.filter(bh => bh.isComplete);
    
    // Need at least 2 birdhouses
    if (completedBirdhouses.length < 2) return;
    
    // Choose two random birdhouses
    const bh1 = completedBirdhouses[0];
    const bh2 = completedBirdhouses[1];
    
    // Position between them
    const scarecrowX = (bh1.x + bh2.x) / 2;
    const scarecrowY = canvas.height * GROUND_HEIGHT_RATIO; // On ground
    
    // Create scarecrow object
    scarecrow = {
        x: scarecrowX,
        y: scarecrowY,
        armWave: 0,
        hatWobble: 0,
        headTilt: 0,
        // Random gender - determines appearance
        isFemale: Math.random() < 0.5
    };
    
    // Mark as created
    scarecrowCreated = true;
    
    // Make any existing crows leave immediately
    makeCrowsLeave();
    
    // Show celebration effect
    addSpecialEffect({
        type: 'sparkle',
        x: scarecrowX,
        y: scarecrowY - 50,
        duration: 3000,
        intensity: 1.0
    });
    
    debugLog(`Scarecrow ${scarecrow.isFemale ? 'woman' : 'man'} created to protect the garden!`);
    
    // Play a celebratory sound if wind chimes are enabled
    if (windChimeEnabled && audioContext) {
        // Play a fanfare
        const notes = ['C4', 'E4', 'G4', 'C5'];
        for (let i = 0; i < notes.length; i++) {
            setTimeout(() => {
                playNote(notes[i], 1);
            }, i * 150);
        }
    }
}

// Update the scarecrow animations
function updateScarecrow(deltaTime) {
    if (!scarecrow) return;
    
    // Update animation values
    scarecrow.armWave += 0.01 * deltaTime;
    scarecrow.hatWobble += 0.005 * deltaTime;
    scarecrow.headTilt = Math.sin(scarecrow.armWave * 0.3) * 0.1;

    if (mushroomMode) {
        scarecrow.armWave += 0.005 * deltaTime; // Slower, more psychedelic movement
        scarecrow.hatWobble += 0.01 * deltaTime; // More subtle wobble
    }
    
    // The scarecrow prevents crows from visiting
    // Make sure no new crow visits happen
    if (crowVisitInProgress) {
        // Immediately send crows away if they appear
        makeCrowsLeave();
        crowVisitInProgress = false;
        crowVisitTimer = 0;
    }
}

function drawMushroomScarecrow() {
    if (!scarecrow) return;
    
    ctx.save();
    
    // Rainbow color cycling for psychedelic effect
    const primaryColor = `hsl(${(colorCycleTimer / 50) % 360}, 100%, 70%)`;
    const secondaryColor = `hsl(${((colorCycleTimer / 50) + 120) % 360}, 100%, 70%)`;
    
    // Animation properties
    const wingFlap = Math.sin(scarecrow.armWave * 0.05) * 0.3; // Smooth wing flapping
    const bodyBob = Math.sin(scarecrow.hatWobble * 0.07) * 5; // Gentle bobbing motion
    
    // BIRD BODY - large oval
    ctx.fillStyle = primaryColor;
    ctx.beginPath();
    ctx.ellipse(
        scarecrow.x, 
        scarecrow.y - 120 + bodyBob, 
        80, 
        120, 
        Math.sin(colorCycleTimer / 2000) * 0.001, // Slight body wobble
        0, Math.PI * 2
    );
    ctx.fill();
    
    // RAINBOW FEATHER PATTERNS - replace mushroom spots
    const featherColors = [
        `hsl(${(colorCycleTimer / 50) % 360}, 100%, 70%)`,
        `hsl(${((colorCycleTimer / 50) + 60) % 360}, 100%, 70%)`,
        `hsl(${((colorCycleTimer / 50) + 120) % 360}, 100%, 70%)`,
        `hsl(${((colorCycleTimer / 50) + 180) % 360}, 100%, 70%)`,
        `hsl(${((colorCycleTimer / 50) + 240) % 360}, 100%, 70%)`,
        `hsl(${((colorCycleTimer / 50) + 300) % 360}, 100%, 70%)`
    ];
    
    // Feather patterns on body
    for (let i = 0; i < 50; i++) {
        const angle = (i / 12) * Math.PI * 2;
        const radius = 70 + Math.sin(colorCycleTimer / 800 + i) * 10;
        const featherColor = featherColors[i % featherColors.length];
        
        ctx.fillStyle = featherColor;
        ctx.beginPath();
        
        // Feather shape - elongated oval
        const featherX = scarecrow.x + Math.cos(angle) * radius;
        const featherY = scarecrow.y - 120 + bodyBob + Math.sin(angle) * radius * 0.5;
        const featherSize = 15 + Math.sin(colorCycleTimer / 600 + i) * 5;
        
        ctx.ellipse(
            featherX,
            featherY,
            featherSize,
            featherSize * 2,
            angle,
            0, Math.PI * 2
        );
        ctx.fill();
    }
    
    // BIRD FACE
    // Face/head area - slightly lighter
    ctx.fillStyle = secondaryColor;
    ctx.beginPath();
    ctx.arc(
        scarecrow.x, 
        scarecrow.y - 170 + bodyBob, 
        50, 
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Large bird eyes
    ctx.fillStyle = 'white';
    const eyeSize = 18;
    const eyeSpacing = 20;
    
    // Left eye
    ctx.beginPath();
    ctx.arc(
        scarecrow.x - eyeSpacing, 
        scarecrow.y - 175 + bodyBob, 
        eyeSize, 
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Right eye
    ctx.beginPath();
    ctx.arc(
        scarecrow.x + eyeSpacing, 
        scarecrow.y - 175 + bodyBob, 
        eyeSize, 
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Pupils - large and black
    ctx.fillStyle = 'black';
    
    // Left pupil
    ctx.beginPath();
    ctx.arc(
        scarecrow.x - eyeSpacing, 
        scarecrow.y - 175 + bodyBob, 
        eyeSize * 0.6, 
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Right pupil
    ctx.beginPath();
    ctx.arc(
        scarecrow.x + eyeSpacing, 
        scarecrow.y - 175 + bodyBob, 
        eyeSize * 0.6, 
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Eye highlights
    ctx.fillStyle = 'white';
    
    // Left eye highlight
    ctx.beginPath();
    ctx.arc(
        scarecrow.x - eyeSpacing + 5, 
        scarecrow.y - 178 + bodyBob, 
        5, 
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Right eye highlight
    ctx.beginPath();
    ctx.arc(
        scarecrow.x + eyeSpacing + 5, 
        scarecrow.y - 178 + bodyBob, 
        5, 
        0, Math.PI * 2
    );
    ctx.fill();
    
    // Rainbow beak
    const beakColor = `hsl(${((colorCycleTimer / 100) + 30) % 360}, 100%, 60%)`;
    ctx.fillStyle = beakColor;
    ctx.beginPath();
    ctx.moveTo(scarecrow.x - 15, scarecrow.y - 155 + bodyBob);
    ctx.lineTo(scarecrow.x, scarecrow.y - 135 + bodyBob);
    ctx.lineTo(scarecrow.x + 15, scarecrow.y - 155 + bodyBob);
    ctx.closePath();
    ctx.fill();
    
    const baseAngle = -Math.PI/2.5; // Base angle for both wings
drawRainbowWing(scarecrow.x - 50, scarecrow.y + 13 + bodyBob, baseAngle - wingFlap, false);
drawRainbowWing(scarecrow.x + 30, scarecrow.y + 13 + bodyBob, baseAngle + wingFlap, true);

    
    // FEET - bird feet at the bottom
    ctx.fillStyle = beakColor;
    
    // Left foot
    ctx.beginPath();
    ctx.ellipse(
        scarecrow.x - 30,
        scarecrow.y - 10,
        20,
        10,
        0, 0, Math.PI * 2
    );
    ctx.fill();
    
    // Left toes
    for (let i = 0; i < 3; i++) {
        const angle = -Math.PI/4 + (i * Math.PI/8);
        const length = 15;
        
        ctx.beginPath();
        ctx.lineWidth = 8;
        ctx.lineCap = 'round';
        ctx.strokeStyle = beakColor;
        ctx.moveTo(scarecrow.x - 40, scarecrow.y - 10);
        ctx.lineTo(
            scarecrow.x - 40 + Math.cos(angle) * length,
            scarecrow.y - 10 + Math.sin(angle) * length
        );
        ctx.stroke();
    }
    
    // Right foot
    ctx.beginPath();
    ctx.ellipse(
        scarecrow.x + 30,
        scarecrow.y - 10,
        20,
        10,
        0, 0, Math.PI * 2
    );
    ctx.fill();
    
    // Right toes
    for (let i = 0; i < 3; i++) {
        const angle = -Math.PI + Math.PI/4 - (i * Math.PI/8);
        const length = 15;
        
        ctx.beginPath();
        ctx.lineWidth = 8;
        ctx.lineCap = 'round';
        ctx.strokeStyle = beakColor;
        ctx.moveTo(scarecrow.x + 40, scarecrow.y - 10);
        ctx.lineTo(
            scarecrow.x + 40 + Math.cos(angle) * length,
            scarecrow.y - 10 + Math.sin(angle) * length
        );
        ctx.stroke();
    }
    
    // RAINBOW TAIL FEATHERS
    for (let i = 0; i < 7; i++) {
        const tailColor = featherColors[i % featherColors.length];
        const angle = Math.PI/2 - Math.PI/6 + (i * Math.PI/18);
        const tailLength = 100 + (i % 2) * 20;
        
        ctx.fillStyle = tailColor;
        ctx.beginPath();
        ctx.ellipse(
            scarecrow.x + Math.cos(angle) * tailLength * 0.5,
            scarecrow.y + 10 + Math.sin(angle) * tailLength * 0.5,
            15,
            tailLength,
            angle + Math.PI/2,
            0, Math.PI * 2
        );
        ctx.fill();
    }
    
    // RAINBOW AURA/GLOW
    const gradient = ctx.createRadialGradient(
        scarecrow.x, scarecrow.y - 100 + bodyBob, 10,
        scarecrow.x, scarecrow.y - 100 + bodyBob, 200
    );
    gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
    gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0)');
    gradient.addColorStop(1, `hsla(${(colorCycleTimer / 100) % 360}, 100%, 70%, 0.1)`);
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(scarecrow.x, scarecrow.y - 100 + bodyBob, 200, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
    
    // Helper function to draw improved rainbow wings
    function drawRainbowWing(x, y, angle, isRight) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        
        // IMPROVED: Larger wings with more dramatic shape
        const wingLength = 150; // Increased from 120
        const wingWidth = 90;   // Increased from 50
        
        // IMPROVED: Add a glowing outline around the entire wing
        // Create a base glow effect
        const glowColor = `hsla(${(colorCycleTimer / 100) % 360}, 100%, 70%, 0.4)`;
        ctx.shadowColor = glowColor;
        ctx.shadowBlur = 15;
        
        // IMPROVED: Create a more feathered wing shape using multiple overlapping shapes
        // Draw main wing shape first as base
        ctx.fillStyle = `hsla(${(colorCycleTimer / 80) % 360}, 100%, 65%, 0.9)`;
        ctx.beginPath();
        ctx.moveTo(0, 0); // Wing base connects to body
        
        // Create a more elegant curve for the wing
        ctx.bezierCurveTo(
            wingLength * 0.3, -wingWidth * 0.5,
            wingLength * 0.7, -wingWidth * 0.7,
            wingLength, -wingWidth * 0.3
        );
        ctx.bezierCurveTo(
            wingLength * 0.8, wingWidth * 0.2,
            wingLength * 0.6, wingWidth * 0.5,
            0, 0
        );
        ctx.fill();
        
        // IMPROVED: Add rainbow-colored feather layers that overlap
        for (let i = 0; i < 7; i++) { // Added one more layer
            // Cycle through rainbow colors with offset based on position
            const hue = ((colorCycleTimer / 50) + i * 30) % 360;
            ctx.fillStyle = `hsla(${hue}, 100%, 65%, 0.8)`;
            
            // Each feather layer is positioned along the wing
            const layerPosition = (i / 7) * wingLength * 0.9;
            const featherLength = wingLength * 0.6 - (i * 5);
            const featherWidth = wingWidth * 0.4 - (i * 3);
            
            // Draw feather with a curved tip
            ctx.beginPath();
            ctx.ellipse(
                layerPosition, 
                -featherWidth,        // Position feathers along curved path
                featherWidth,         // Width of feather
                featherLength,        // Length of feather
                -Math.PI/8,           // Angle for feather direction
                0, Math.PI * 2
            );
            ctx.fill();
            
            // Add a second row of feathers for fullness
            ctx.beginPath();
            ctx.ellipse(
                layerPosition + 10,
                featherWidth * 0.5,
                featherWidth * 0.8,
                featherLength * 0.7,
                Math.PI/6,
                0, Math.PI * 2
            );
            ctx.fill();
        }
        
        // IMPROVED: Add white highlight along leading edge of wing
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(
            wingLength * 0.3, -wingWidth * 0.5,
            wingLength * 0.7, -wingWidth * 0.7,
            wingLength, -wingWidth * 0.3
        );
        ctx.stroke();
        
        // IMPROVED: More dramatic, pulsing sparkles
        const sparkleCount = 5; // Increased from 8
        for (let i = 0; i < sparkleCount; i++) {
            // Distribute sparkles more evenly across wing
            const sparkleX = (i / sparkleCount) * wingLength;
            const sparkleY = Math.sin(i / 2) * wingWidth * 0.6;
            
            // Pulsing size based on time
            const pulse = Math.sin((colorCycleTimer / 300) + i) * 0.5 + 1;
            const sparkleSize = (3 + Math.random() * 4) * pulse;
            
            // Changing colors for sparkles
            const sparkleHue = (colorCycleTimer / 30 + i * 20) % 360;
            ctx.fillStyle = `hsla(${sparkleHue}, 100%, 80%, 0.9)`;
            
            // Draw star-shaped sparkles
            drawStar(sparkleX, sparkleY, 5, sparkleSize, sparkleSize/2);
        }
        
        // Reset shadow effects
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        
        ctx.restore();
    }
    
    // Helper function to draw star-shaped sparkles
    function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
        let rot = Math.PI / 2 * 3;
        let x = cx;
        let y = cy;
        const step = Math.PI / spikes;

        ctx.beginPath();
        ctx.moveTo(cx, cy - outerRadius);
        
        for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outerRadius;
            y = cy + Math.sin(rot) * outerRadius;
            ctx.lineTo(x, y);
            rot += step;

            x = cx + Math.cos(rot) * innerRadius;
            y = cy + Math.sin(rot) * innerRadius;
            ctx.lineTo(x, y);
            rot += step;
        }
        
        ctx.lineTo(cx, cy - outerRadius);
        ctx.closePath();
        ctx.fill();
    }
}


// Draw the scarecrow
function drawScarecrow() {
    if (!scarecrow) return;
    
    const armWave = Math.sin(scarecrow.armWave);
    const hatWobble = Math.sin(scarecrow.hatWobble) * 0.1;
    
    // Calculate scarecrow measurements
    const headRadius = 15;
    const bodyHeight = 60;
    const armLength = 40;
    const legLength = 40;
    
    // Save context for transformations
    ctx.save();
    
    // Draw the supporting pole
    ctx.fillStyle = '#8B4513'; // Brown
    ctx.fillRect(scarecrow.x - 4, scarecrow.y - bodyHeight - headRadius * 2 - 10, 8, bodyHeight + headRadius * 2 + 10);
    
    // Position scarecrow on the pole
    const scarecrowCenterY = scarecrow.y - bodyHeight - headRadius;
    
    // Draw body (different shapes for male/female)
    if (scarecrow.isFemale) {
        // Female - dress shape
        ctx.fillStyle = '#E74C3C'; // Red dress
        
        // Dress (trapezoid shape)
        ctx.beginPath();
        ctx.moveTo(scarecrow.x - 15, scarecrowCenterY);
        ctx.lineTo(scarecrow.x + 15, scarecrowCenterY);
        ctx.lineTo(scarecrow.x + 25, scarecrowCenterY + bodyHeight);
        ctx.lineTo(scarecrow.x - 25, scarecrowCenterY + bodyHeight);
        ctx.closePath();
        ctx.fill();
        
        // Belt/waist
        ctx.fillStyle = '#2C3E50'; // Dark belt
        ctx.fillRect(scarecrow.x - 17, scarecrowCenterY + 10, 34, 5);
    } else {
        // Male - shirt and pants
        
        // Shirt
        ctx.fillStyle = '#3498DB'; // Blue shirt
        ctx.fillRect(scarecrow.x - 20, scarecrowCenterY, 40, bodyHeight / 2);
        
        // Pants
        ctx.fillStyle = '#2C3E50'; // Dark pants
        ctx.fillRect(scarecrow.x - 18, scarecrowCenterY + bodyHeight / 2, 36, bodyHeight / 2);
        
        // Add buttons
        ctx.fillStyle = '#ECF0F1';
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(
                scarecrow.x, 
                scarecrowCenterY + 5 + i * 10, 
                2, 0, Math.PI * 2
            );
            ctx.fill();
        }
    }
    
    // Draw head
    ctx.save();
    ctx.translate(scarecrow.x, scarecrowCenterY - headRadius);
    ctx.rotate(scarecrow.headTilt); // Head tilt animation
    
    // Draw face - burlap texture
    ctx.fillStyle = '#D4B483'; // Burlap color
    ctx.beginPath();
    ctx.arc(0, 0, headRadius, 0, Math.PI * 2);
    ctx.fill();
    
    // Eyes - different styles based on gender
    if (scarecrow.isFemale) {
        // Female - eyelashes
        ctx.fillStyle = 'black';
        
        // Left eye
        ctx.beginPath();
        ctx.arc(-5, -2, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyelashes
        ctx.beginPath();
        for (let i = 0; i < 3; i++) {
            const angle = (Math.PI / 2) + (i - 1) * (Math.PI / 8);
            ctx.moveTo(-5 + Math.cos(angle) * 3, -2 + Math.sin(angle) * 3);
            ctx.lineTo(-5 + Math.cos(angle) * 6, -2 + Math.sin(angle) * 6);
        }
        ctx.stroke();
        
        // Right eye
        ctx.beginPath();
        ctx.arc(5, -2, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyelashes
        ctx.beginPath();
        for (let i = 0; i < 3; i++) {
            const angle = (Math.PI / 2) + (i - 1) * (Math.PI / 8);
            ctx.moveTo(5 + Math.cos(angle) * 3, -2 + Math.sin(angle) * 3);
            ctx.lineTo(5 + Math.cos(angle) * 6, -2 + Math.sin(angle) * 6);
        }
        ctx.stroke();
        
        // Pink rosy cheeks
        ctx.fillStyle = 'rgba(231, 76, 60, 0.3)';
        ctx.beginPath();
        ctx.arc(-8, 3, 4, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(8, 3, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Smile with lipstick
        ctx.strokeStyle = '#C0392B';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(0, 2, 6, 0.2, Math.PI - 0.2);
        ctx.stroke();
    } else {
        // Male - button eyes
        ctx.fillStyle = 'black';
        
        // Left eye - button with cross stitch
        ctx.beginPath();
        ctx.arc(-5, -2, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#D4B483';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-7, -4);
        ctx.lineTo(-3, 0);
        ctx.moveTo(-7, 0);
        ctx.lineTo(-3, -4);
        ctx.stroke();
        
        // Right eye - button with cross stitch
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(5, -2, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#D4B483';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(3, -4);
        ctx.lineTo(7, 0);
        ctx.moveTo(3, 0);
        ctx.lineTo(7, -4);
        ctx.stroke();
        
        // Simple smile
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, 3, 5, 0.2, Math.PI - 0.2);
        ctx.stroke();
    }
    
    // Draw Hat - different hats based on gender
    if (scarecrow.isFemale) {
        // Straw sunhat for female
        ctx.fillStyle = '#F5DEB3'; // Wheat color
        
        // Wide brim
        ctx.beginPath();
        ctx.ellipse(0, -headRadius - 3, 30, 10, hatWobble, 0, Math.PI * 2);
        ctx.fill();
        
        // Hat crown
        ctx.fillStyle = '#F0E68C'; // Khaki
        ctx.beginPath();
        ctx.ellipse(0, -headRadius - 8, 12, 8, hatWobble, 0, Math.PI * 2);
        ctx.fill();
        
        // Hat band
        ctx.fillStyle = '#E74C3C'; // Red
        ctx.beginPath();
        ctx.ellipse(0, -headRadius - 6, 12.5, 2, hatWobble, 0, Math.PI * 2);
        ctx.fill();
        
        // Flower on hat
        const flowerX = 15 * Math.cos(hatWobble);
        const flowerY = -headRadius - 4 + 5 * Math.sin(hatWobble);
        
        // Flower petals
        ctx.fillStyle = '#F1C40F'; // Yellow
        for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI * 2;
            ctx.beginPath();
            ctx.ellipse(
                flowerX + Math.cos(angle) * 4,
                flowerY + Math.sin(angle) * 4,
                3, 3, 0, 0, Math.PI * 2
            );
            ctx.fill();
        }
        
        // Flower center
        ctx.fillStyle = '#E67E22'; // Orange
        ctx.beginPath();
        ctx.arc(flowerX, flowerY, 2, 0, Math.PI * 2);
        ctx.fill();
    } else {
        // Farmer hat for male
        ctx.fillStyle = '#8B4513'; // Brown
        
        // Hat body
        ctx.save();
        ctx.rotate(hatWobble);
        ctx.fillRect(-15, -headRadius - 15, 30, 10);
        
        // Hat top
        ctx.fillRect(-10, -headRadius - 25, 20, 10);
        ctx.restore();
    }
    
    // Restore head context
    ctx.restore();
    
    // Draw arms
    const shoulderY = scarecrowCenterY + 5;
    
    // Left arm
    ctx.save();
    ctx.translate(scarecrow.x - 20, shoulderY);
    ctx.rotate(Math.PI * 0.2 + armWave * 0.3); // Waving motion
    
    ctx.fillStyle = scarecrow.isFemale ? '#E74C3C' : '#3498DB'; // Match body color
    ctx.fillRect(-5, 0, 10, armLength);
    
    // Left hand
    ctx.fillStyle = '#D4B483'; // Burlap/straw color
    ctx.beginPath();
    ctx.arc(-2, armLength + 5, 7, 0, Math.PI * 2);
    ctx.fill();
    
    // Straw bits sticking out
    ctx.strokeStyle = '#F5DEB3';
    ctx.lineWidth = 1;
    for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(-2, armLength + 5);
        ctx.lineTo(
            -2 + Math.cos(angle) * 10,
            armLength + 5 + Math.sin(angle) * 10
        );
        ctx.stroke();
    }
    ctx.restore();
    
    // Right arm
    ctx.save();
    ctx.translate(scarecrow.x + 20, shoulderY);
    ctx.rotate(Math.PI * 0.8 - armWave * 0.3); // Opposite wave
    
    ctx.fillStyle = scarecrow.isFemale ? '#E74C3C' : '#3498DB'; // Match body color
    ctx.fillRect(-5, 0, 10, armLength);
    
    // Right hand
    ctx.fillStyle = '#D4B483'; // Burlap/straw color
    ctx.beginPath();
    ctx.arc(2, armLength + 5, 7, 0, Math.PI * 2);
    ctx.fill();
    
    // Straw bits sticking out
    ctx.strokeStyle = '#F5DEB3';
    ctx.lineWidth = 1;
    for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(2, armLength + 5);
        ctx.lineTo(
            2 + Math.cos(angle) * 10,
            armLength + 5 + Math.sin(angle) * 10
        );
        ctx.stroke();
    }
    ctx.restore();
    
    // Draw legs
    const hipY = scarecrowCenterY + bodyHeight;
    
    // Left leg
    ctx.fillStyle = scarecrow.isFemale ? '#E74C3C' : '#2C3E50'; // Match outfit
    ctx.fillRect(scarecrow.x - 15, hipY, 10, legLength);
    
    // Left foot/boot
    ctx.fillStyle = '#8B4513'; // Brown boot
    ctx.fillRect(scarecrow.x - 18, hipY + legLength, 16, 5);
    
    // Right leg
    ctx.fillStyle = scarecrow.isFemale ? '#E74C3C' : '#2C3E50'; // Match outfit
    ctx.fillRect(scarecrow.x + 5, hipY, 10, legLength);
    
    // Right foot/boot
    ctx.fillStyle = '#8B4513'; // Brown boot
    ctx.fillRect(scarecrow.x + 2, hipY + legLength, 16, 5);
    
    // Restore context
    ctx.restore();
    
    // For debugging - show protection radius
    if (debugVisuals) {
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
        ctx.beginPath();
        ctx.arc(scarecrow.x, scarecrow.y, 500, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        ctx.fillText('Crow Protection Zone', scarecrow.x - 70, scarecrow.y - 100);
    }
}


// Check for conditions to create an ant hill
function checkForAntHill() {
    // Don't create during rain
    if (isRaining) return;
    
    // Don't create if one already exists
    if (antHill) return;
    
    // Only check periodically
    if (Math.random() > 0.01) return;
    
    // Requirements: daytime, food on ground, some flowers
    const isDaytime = timeOfDay < 1;
    const hasFoodOnGround = foodItems.length >= 4;
    const hasFlowers = flowers.length >= 5;
    
    if (isDaytime && hasFoodOnGround && hasFlowers && dayNightCycleCount >= 2) {
        // Find a good location near food
        const location = findFoodConcentration();
        if (location) {
            createAntHill(location);
        }
   // ADD THIS LINE:
   hadAnts = true;

    }
}

// Find where food is concentrated
function findFoodConcentration() {
    if (foodItems.length < 4) return null;
    
    // Grid-based approach to find food clusters
    const gridSize = 80;
    const grid = {};
    
    // Count food items in each grid cell
    for (const food of foodItems) {
        const gridX = Math.floor(food.x / gridSize);
        const gridY = Math.floor(food.y / gridSize);
        const key = `${gridX},${gridY}`;
        
        grid[key] = (grid[key] || 0) + 1;
    }
    
    // Find grid cell with most food
    let bestCell = null;
    let maxCount = 2; // Need at least 3 items to be considered a concentration
    
    for (const key in grid) {
        if (grid[key] > maxCount) {
            maxCount = grid[key];
            bestCell = key;
        }
    }
    
    if (bestCell) {
        const [gridX, gridY] = bestCell.split(',').map(Number);
        return {
            x: (gridX + 0.5) * gridSize,
            y: canvas.height * GROUND_HEIGHT_RATIO
        };
    }
    
    return null;
}

// Create a new ant hill
function createAntHill(location) {
    antHill = {
        x: location.x,
        y: location.y,
        size: 15, // Hill size
        foodCollected: 0,
        createdAt: simulationTime,
        lastAntSpawnTime: 0,
        entranceY: location.y - 3 // Slightly above ground level
    };
    
    // Spawn initial ants
    for (let i = 0; i < 5; i++) {
        spawnAnt();
    }
    
    debugLog(`Ant hill created at (${location.x}, ${location.y})`);
}

// Spawn a new ant
function spawnAnt() {
    if (!antHill) return;
    if (ants.length >= MAX_ANTS) return;
    
    // Cooldown on ant spawning (every 5-10 seconds)
    const now = simulationTime;
    if (now - antHill.lastAntSpawnTime < 5000 + Math.random() * 5000) return;
    
    antHill.lastAntSpawnTime = now;
    
    // Create ant with randomized position around hill
    const angle = Math.random() * Math.PI * 2;
    const distance = antHill.size * 0.8;
    
    ants.push({
        x: antHill.x + Math.cos(angle) * distance,
        y: antHill.y + Math.sin(angle) * distance,
        angle: Math.random() * Math.PI * 2, // Random direction
        speed: ANT_SPEED,
        state: 'exploring', // exploring, returningWithFood
        carryingFood: null, // Reference to food being carried
        wanderTimer: 0,
        wiggle: Math.random() * Math.PI * 2, // For animation
        bounce: 0, // For cute bouncy movement
        targetX: null,
        targetY: null,
        foodX: 0, // Food position relative to ant
        foodY: -2 // Food held above ant
    });
}

// Update ant hill and ants
function updateAnts(deltaTime) {
    // Check if ant hill should disappear due to rain
    if (isRaining && antHill) {
        debugLog("Rain is dissolving the ant hill...");
        removeAntHill();
        return;
    }
    
    // Possibly create a new ant hill if conditions are right
    if (!antHill) {
        checkForAntHill();
    }
    
    // No ant hill, nothing to update
    if (!antHill) return;
    
    // Spawn new ants periodically
    if (Math.random() < 0.01 && ants.length < MAX_ANTS) {
        spawnAnt();
    }
    
    // Update each ant
    for (let i = ants.length - 1; i >= 0; i--) {
        const ant = ants[i];
        
        // Update animation timers
        ant.wiggle += 0.1 * deltaTime / 16;
        ant.bounce += 0.15 * deltaTime / 16;
        
        // Update behavior based on state
        switch (ant.state) {
            case 'exploring':
                updateExploringAnt(ant, deltaTime);
                break;
                
            case 'returningWithFood':
                updateReturningAnt(ant, deltaTime);
                break;
        }
        
        // Make sure ants stay on the ground
        ant.y = Math.min(ant.y, canvas.height * GROUND_HEIGHT_RATIO + 3);
        ant.y = Math.max(ant.y, canvas.height * GROUND_HEIGHT_RATIO - 3);
        
        // Enforce maximum distance from hill
        const distToHill = distance(ant.x, ant.y, antHill.x, antHill.y);
        if (distToHill > MAX_ANT_DISTANCE) {
            // Too far - head back to hill
            ant.state = 'returningWithFood';
            ant.carryingFood = null; // Drop food if too far
        }
    }
}

function updateExploringAnt(ant, deltaTime) {
    // Update wander timer
    ant.wanderTimer += deltaTime;
    
    // Check for nearby food
    if (!ant.carryingFood) {
        const nearbyFood = findNearbyFood(ant);
        if (nearbyFood) {
            // Found food - pick it up
            ant.carryingFood = nearbyFood;
            ant.state = 'returningWithFood';
            ant.speed = FOOD_CARRY_SPEED; // Slower when carrying
            
            // Remove food from the garden
            const foodIndex = foodItems.indexOf(nearbyFood);
            if (foodIndex !== -1) {
                foodItems.splice(foodIndex, 1);
            }
            return;
        }
    }
    
    // Change direction randomly
    if (ant.wanderTimer > 1000 + Math.random() * 2000) {
        ant.wanderTimer = 0;
        ant.angle += (Math.random() - 0.5) * Math.PI / 2; // ±45° turn
    }
    
    // Move in current direction with some wiggle
    const wiggle = Math.sin(ant.wiggle) * 0.2;
    ant.x += Math.cos(ant.angle + wiggle) * ant.speed * (deltaTime / 16);
    ant.y += Math.sin(ant.angle + wiggle) * ant.speed * 0.3 * (deltaTime / 16); // Less vertical movement
}

function updateReturningAnt(ant, deltaTime) {
    // Calculate direction to ant hill entrance
    const dx = antHill.x - ant.x;
    const dy = antHill.entranceY - ant.y; // Go to entrance, not center
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    // Update angle to face hill
    ant.angle = Math.atan2(dy, dx);
    
    // Move toward hill
    ant.x += Math.cos(ant.angle) * ant.speed * (deltaTime / 16);
    ant.y += Math.sin(ant.angle) * ant.speed * (deltaTime / 16);
    
    // Check if reached hill entrance
    if (dist < 6) { // Close to entrance
        if (ant.carryingFood) {
            // Add food collection animation
            addSpecialEffect({
                type: 'foodCollection',
                x: antHill.x,
                y: antHill.entranceY,
                duration: 800,
                color: '#D2B48C'
            });
            
            antHill.foodCollected++;
            ant.carryingFood = null;
            
            // Grow hill slightly with more food
            antHill.size = Math.min(30, antHill.size + 0.1);
        }
        
        // Reset to exploring
        ant.state = 'exploring';
        ant.speed = ANT_SPEED;
        ant.angle = Math.random() * Math.PI * 2; // Pick new direction
    }
}

function findNearbyFood(ant) {
    const searchRadius = 30; // How far ants can detect food
    
    for (const food of foodItems) {
        const dist = distance(ant.x, ant.y, food.x, food.y);
        if (dist < searchRadius) {
            return food;
        }
    }
    
    return null;
}

// Remove ant hill (when rained on)
function removeAntHill() {
    // Create a "dissolving" visual effect
    if (antHill) {
        addSpecialEffect({
            type: 'dissolve',
            x: antHill.x,
            y: antHill.y,
            size: antHill.size,
            duration: 2000,
            color: '#8B4513'
        });
    }
    
    // Clear ants and ant hill
    antHill = null;
    ants = [];
    
    debugLog("Ant hill dissolved by rain");
}

// Draw ant hill and ants
function drawAnts() {
    // Nothing to draw if no ant hill
    if (!antHill) return;
    
    // Draw the ant hill
    ctx.fillStyle = mushroomMode ? getMushroomColor('#8B4513') : '#8B4513'; // Brown
    ctx.beginPath();
    ctx.ellipse(
        antHill.x,
        antHill.y,
        antHill.size,
        antHill.size * 0.6,
        0, 0, Math.PI * 2
    );
    ctx.fill();

    // Draw ant hill entrance
    ctx.fillStyle = mushroomMode ? getMushroomColor('#3D1C02') : '#3D1C02'; // Darker brown
    ctx.beginPath();
    ctx.ellipse(
        antHill.x, 
        antHill.entranceY, 
        antHill.size * 0.3, 
        antHill.size * 0.15, 
        0, 0, Math.PI * 2
    );
    ctx.fill();
    
    // Draw each ant
    for (const ant of ants) {
        // Cute bouncy effect
        const bounceOffset = Math.sin(ant.bounce) * 0.5;
        
        // Save context for rotation
        ctx.save();
        ctx.translate(ant.x, ant.y + bounceOffset);
        ctx.rotate(ant.angle);
        
        // Draw food if carrying (underneath ant when drawn)
        if (ant.carryingFood) {
            ctx.fillStyle = mushroomMode ? getMushroomColor('#D2B48C') : '#D2B48C'; // Tan color for food
            ctx.beginPath();
            ctx.arc(ant.foodX, ant.foodY, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // Cute ant body - lighter brown
        ctx.fillStyle = mushroomMode ? getMushroomColor('#654321') : '#654321'; // Medium brown
        
        // Draw rounded body segments
        // Head
        ctx.beginPath();
        ctx.arc(3, 0, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Middle segment
        ctx.beginPath();
        ctx.arc(0, 0, 2.2, 0, Math.PI * 2);
        ctx.fill();
        
        // Back segment
        ctx.beginPath();
        ctx.arc(-3, 0, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes (small white dots)
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(4, -0.5, 0.5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(4, 0.5, 0.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Antennae
        ctx.strokeStyle = mushroomMode ? getMushroomColor('#654321') : '#654321';
        ctx.lineWidth = 0.5;
        
        ctx.beginPath();
        ctx.moveTo(3.5, -1);
        ctx.lineTo(5, -3);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(3.5, 1);
        ctx.lineTo(5, 3);
        ctx.stroke();
        
        // Legs (3 pairs)
        ctx.lineWidth = 0.7;
        
        for (let i = -1; i <= 1; i++) {
            const segmentY = i * 0.8;
            const segmentX = i * 1.5;
            
            // Left legs
            ctx.beginPath();
            ctx.moveTo(segmentX, -1.2);
            ctx.lineTo(segmentX - 1, -3);
            ctx.stroke();
            
            // Right legs
            ctx.beginPath();
            ctx.moveTo(segmentX, 1.2);
            ctx.lineTo(segmentX - 1, 3);
            ctx.stroke();
        }
        
        // Restore context
        ctx.restore();
    }
    
    
    
    // Debug information if enabled
    if (debugVisuals) {
        ctx.fillStyle = 'white';
        ctx.font = '10px Arial';
        ctx.fillText(`Ants: ${ants.length}`, antHill.x - 15, antHill.y - antHill.size - 15);
        ctx.fillText(`Food: ${antHill.foodCollected}`, antHill.x - 15, antHill.y - antHill.size - 5);
    }
}


        // V26: Reduced squirrel spawn rate
        // Core gameplay loop: More branches attract more squirrels
        function spawnSquirrels() {
            if (squirrels.length >= MAX_SQUIRRELS) return;

            // Count total branches across all trees
            let totalBranches = 0;
            trees.forEach(tree => {
                totalBranches += tree.branches ? tree.branches.length : 0;
            });

            // Base spawn chance, increased by branch count
            let spawnChance = 0.012; // Base: 1.2%
            const branchMultiplier = Math.min(totalBranches / 10, 2); // Up to 2x multiplier (caps at 20 branches)
            spawnChance = spawnChance * (1 + branchMultiplier);

            if (Math.random() < spawnChance) { // Reduced from 0.02 to dial back squirrel spawns
                const x = Math.random() < 0.5 ? -30 : canvas.width + 30;
                const y = canvas.height * GROUND_HEIGHT_RATIO - 5;

                const squirrel = new Squirrel(x, y);
                // Set initial direction based on entry point
                squirrel.direction = x < 0 ? 1 : -1;

                squirrels.push(squirrel);

                if (totalBranches > 10) {
                    debugLog(`Squirrel attracted by ${totalBranches} branches!`);
                } else {
                    debugLog(`Squirrel spawned at (${x}, ${y})`);
                }
            }
        }

        // V26: Increased rat spawn rate for better visibility
        // Core gameplay loop: More poop attracts more rats
        function spawnRats() {
            if (rats.length >= MAX_RATS) return;

            // Base spawn chance, increased by poop count
            let spawnChance = 0.04; // Base: 4%
            const poopMultiplier = Math.min(birdPoops.length / 5, 2); // Up to 2x multiplier (caps at 10 poops)
            spawnChance = spawnChance * (1 + poopMultiplier);

            if (Math.random() < spawnChance) {
                const x = Math.random() < 0.5 ? -30 : canvas.width + 30;
                const y = canvas.height * GROUND_HEIGHT_RATIO;

                // Reduced chance to spawn a rat king
                const isRatKing = rats.length > 0 && Math.random() < RAT_KING_FORMATION_CHANCE;

                // Create rat
                const rat = new Rat(x, y, isRatKing);
                rats.push(rat);

                if (birdPoops.length > 5) {
                    debugLog(`${isRatKing ? 'Rat king' : 'Rat'} attracted by ${birdPoops.length} poops!`);
                } else {
                    debugLog(`${isRatKing ? 'Rat king' : 'Rat'} spawned at (${x}, ${y})`);
                }
            }
        }

        // Spawn worms with some clustering
        function spawnWorms() {
    if (worms.length >= MAX_WORMS) return;

    if (Math.random() < 0.02) {
        const clusterSize = Math.floor(Math.random() * 3) + 1; // 1-3 worms in cluster
        const baseX = Math.random() * canvas.width;
        // Spawn worms deeper in grass (20-70px below ground) to encourage birds to land
        const baseY = canvas.height * GROUND_HEIGHT_RATIO + 20 + Math.random() * 50;
        
        for (let i = 0; i < clusterSize; i++) {
            if (worms.length < MAX_WORMS) {
                const x = baseX + (Math.random() - 0.5) * 30;
                // Ensure worms stay below ground level with Math.max
                const y = Math.max(canvas.height * GROUND_HEIGHT_RATIO, baseY + (Math.random() * 10)); 
                
                worms.push({
                    x: x,
                    y: y,
                    wiggle: Math.random() * Math.PI * 2,
                    size: 5 + Math.random() * 5
                });
            }
        }
    }
}

function spawnNightWorms() {
    if (worms.length >= MAX_WORMS) return;
    
    // Higher chance to spawn worms at night (5% instead of 2%)
    if (Math.random() < 0.05) {
        // Spawn slightly larger clusters at night (2-4 worms)
        const clusterSize = Math.floor(Math.random() * 3) + 2;
        const baseX = Math.random() * canvas.width;
        const baseY = canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 20;
        
        // Create cluster with slightly larger worms at night
        for (let i = 0; i < clusterSize; i++) {
            if (worms.length < MAX_WORMS) {
                const x = baseX + (Math.random() - 0.5) * 40; // More spread out
                const y = baseY + (Math.random() - 0.5) * 15; // This can make worms go above ground
                
                worms.push({
                    x: x,
                    y: y,
                    wiggle: Math.random() * Math.PI * 2,
                    size: 6 + Math.random() * 5, // Slightly larger worms at night
                    isNightWorm: true // Track that this is a night worm
                });
            }
        }
        
        debugLog(`Night-time worm cluster spawned (${clusterSize} worms)`);
    }
}

// Add your spawnButterflies function here
function spawnButterflies() {
    try {
        // Make sure all required variables exist
        if (typeof butterflies === 'undefined' || !Array.isArray(butterflies)) {
            console.error("butterflies array is not defined");
            return;
        }
        
        if (typeof flowers === 'undefined' || !Array.isArray(flowers)) {
            console.error("flowers array is not defined");
            return;
        }
        
        if (typeof MAX_BUTTERFLIES === 'undefined') {
            console.warn("MAX_BUTTERFLIES not defined, using default value of 10");
        }
        
        const maxButterflies = typeof MAX_BUTTERFLIES !== 'undefined' ? MAX_BUTTERFLIES : 10;
        
        // Only spawn butterflies if there are 5 or more flowers
        if (flowers.length >= 5) {
            if (butterflies.length < maxButterflies && Math.random() < 0.3) {  // Reduced chance for more stability
                // Choose a random flower to spawn butterfly near
                const targetFlower = flowers[Math.floor(Math.random() * flowers.length)];
                
                // Create butterfly near but not exactly on the flower
                const x = targetFlower.x + (Math.random() - 0.5) * 50;
                const y = targetFlower.y - 50 - Math.random() * 50; // Above the flower
                
                const butterfly = new Butterfly(x, y);
                butterflies.push(butterfly);
                
                if (typeof debugLog === 'function') {
                    debugLog(`Butterfly spawned at (${x}, ${y}) near flower`);
                } else {
                    console.log(`Butterfly spawned at (${x}, ${y}) near flower`);
                }
            }
        } else if (butterflies.length > 0) {
            // If flowers drop below 3, make butterflies gradually leave
            if (Math.random() < 0.1) {
                const randomIndex = Math.floor(Math.random() * butterflies.length);
                butterflies[randomIndex].state = 'leaving';
                butterflies[randomIndex].stateTimer = 0;
                
                if (typeof debugLog === 'function') {
                    debugLog(`Butterfly leaving due to lack of flowers`);
                } else {
                    console.log(`Butterfly leaving due to lack of flowers`);
                }
            }
        }
    } catch (e) {
        console.error("Error in spawnButterflies:", e);
    }
}


function checkForMagicMushroom() {
    // If mushroom already exists or has been activated, don't create another
    if (magicMushroomAppeared || magicMushroom || mushroomMode) return;
    
    // Check if all conditions are met
    const hasFlower = flowers.length >= 1;
    const hasBirdhouse = birdhouses.length >= 1;
    
    if (hasFlower && hasBirdhouse && hadRainbow && hadAnts) {
        // Create the magic mushroom
        const groundY = canvas.height * GROUND_HEIGHT_RATIO;
        
        // Find a nice open spot away from trees
        let mushroomX = canvas.width / 2;
        let validPosition = false;
        let attempts = 0;
        
        while (!validPosition && attempts < 20) {
            mushroomX = 100 + Math.random() * (canvas.width - 200);
            validPosition = trees.every(tree => Math.abs(tree.x - mushroomX) > 80);
            attempts++;
        }
        
        magicMushroom = {
            x: mushroomX,
            y: groundY,
            size: 25,
            glowSize: 0,
            glowOpacity: 0,
            pulseTimer: 0,
            clicked: false
        };
        
        magicMushroomAppeared = true;
        debugLog("A magic mushroom has appeared in the garden!");
    }
}


// Add owl spawning functionality
function spawnOwls() {
    // Don't spawn if at max
    if (owls.length >= MAX_OWLS) return;
    
    // Check if it's night time
    const isNight = timeOfDay >= 1;
    
    // Only spawn at night
    if (!isNight) return;
    
    // Check for rat kings - they attract owls
    const ratKingPresent = rats.some(rat => rat.isRatKing);
    let spawnChance = OWL_SPAWN_CHANCE;
    
    if (ratKingPresent) {
        spawnChance += RAT_KING_OWL_ATTRACTION;
        debugLog("Rat king is attracting owls!");
    }
    
    if (Math.random() < spawnChance) {
        // Create new owl
        const owl = new Owl();
        owls.push(owl);
        
        // Play owl hoot if wind chimes enabled
        if (windChimeEnabled && audioContext) {
            // Play owl hoot sound
            const notes = ['C3', 'G3'];
            for (let i = 0; i < notes.length; i++) {
                setTimeout(() => {
                    playNote(notes[i], 0.8);
                }, i * 500);
            }
        }
        
        debugLog(`Owl spawned at (${owl.x}, ${owl.y})${ratKingPresent ? ' attracted by rat king' : ''}`);
    }
}

        // Spawn twigs - occasionally special twigs
        function spawnTwigs() {
            if (twigs.length >= MAX_TWIGS) return;
            
            if (Math.random() < 0.1) {
                // Find a spot near a tree if possible
                let x, y;
                
                if (trees.length > 0 && Math.random() < 0.7) {
                    // Pick a random tree
                    const randomTree = trees[Math.floor(Math.random() * trees.length)];
                    x = randomTree.x + (Math.random() - 0.5) * 100;
                    y = canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 5;
                } else {
                    // Random spot on ground
                    x = Math.random() * canvas.width;
                    y = canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 10;
                }
                
                // Small chance of special twig
                const isSpecial = Math.random() < 0.05;
                
                twigs.push({
                    x: x,
                    y: y,
                    size: 10 + Math.random() * 8,
                    angle: Math.PI / 4 + Math.random() * Math.PI / 2,
                    isSpecial: isSpecial,
                    offshoots: []
                });
                
                if (isSpecial) {
                    debugLog(`Special twig spawned at (${x}, ${y})`);
                }
            }
        }

        // Draw rain
        function drawRain(deltaTime) {
            if (isRaining) {
                // Add new raindrops at the top of the screen
                for (let i = 0; i < 5; i++) {
                    raindrops.push({
                        x: Math.random() * canvas.width,
                        y: -20,
                        length: 10 + Math.random() * 20,
                        speed: 5 + Math.random() * 10
                    });
                }
                
                // Update and draw existing raindrops
                ctx.strokeStyle = isThundering ? 'rgba(200, 210, 255, 0.7)' : 'rgba(200, 210, 255, 0.5)';
                ctx.lineWidth = 1;
                
                for (let i = raindrops.length - 1; i >= 0; i--) {
                    const drop = raindrops[i];
                    
                    // Update position
                    drop.y += drop.speed * (deltaTime / 16);
                    
                    // Draw raindrop
                    ctx.beginPath();
                    ctx.moveTo(drop.x, drop.y);
                    ctx.lineTo(drop.x, drop.y + drop.length);
                    ctx.stroke();
                    
                    // Remove raindrops that have fallen beyond the ground
                    if (drop.y > canvas.height * GROUND_HEIGHT_RATIO) {
                        // Occasionally create a ripple on a puddle
                        const nearbyPuddle = puddles.find(puddle => 
                            Math.abs(puddle.x - drop.x) < 30
                        );
                        
                        if (nearbyPuddle && Math.random() < 0.1) {
                            nearbyPuddle.ripples.push({
                                size: 2,
                                maxSize: 5 + Math.random() * 5,
                                speed: 0.05 + Math.random() * 0.05
                            });
                        }
                        
                        raindrops.splice(i, 1);
                    }
                }
                
                // Add fogging/mist effect
                ctx.fillStyle = isThundering ? 
                    'rgba(210, 220, 255, 0.05)' : 
                    'rgba(220, 230, 255, 0.03)';
                ctx.fillRect(0, 0, canvas.width, canvas.height * GROUND_HEIGHT_RATIO);
            } else {
                // Clear raindrops if not raining
                raindrops = [];
            }
        }

        // V26: Improved wind chime system with more balanced volume and timing
        function initializeAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Define wind chime frequencies based on pentatonic scale
                windChimeSounds = {
                    'C': 261.63, // C4
                    'D': 293.66, // D4
                    'E': 329.63, // E4
                    'G': 392.00, // G4
                    'A': 440.00  // A4
                };
                
                debugLog("Audio context initialized");
            } catch (e) {
                console.error("Error initializing audio:", e);
                windChimeEnabled = false;
            }
        }

        // V26: Wind chime playback with reduced volume
        // Simple test function to verify audio is working (call from console)
        window.testAudio = function() {
            console.log("Testing basic audio...");
            if (!audioContext) {
                initializeAudio();
            }
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            console.log("Audio context state:", audioContext ? audioContext.state : "null");

            if (!audioContext) {
                console.error("Cannot initialize audio context");
                return;
            }

            // Play a simple tone
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.frequency.value = 440; // A4
            osc.type = 'sine';

            gain.gain.value = 0;

            osc.connect(gain);
            gain.connect(audioContext.destination);

            const now = audioContext.currentTime;
            osc.start(now);
            gain.gain.linearRampToValueAtTime(0.3, now + 0.01);
            gain.gain.linearRampToValueAtTime(0, now + 0.5);
            osc.stop(now + 0.5);

            console.log("Test tone should play now (440Hz for 0.5s)");
        };

        // Hidden console command: playthehits
        // Makes birds chirp melodic patterns inspired by popular songs
        window.playthehits = function() {
            console.log("🎵 Playing the hits! Birds will chirp popular melodies...");

            if (!audioContext) {
                initializeAudio();
            }
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            if (!audioContext) {
                console.error("Cannot initialize audio context");
                return;
            }

            // Check if muted
            if (isMuted) {
                console.log("Audio is muted, unmute to hear the hits!");
                return;
            }

            // Check if already playing
            if (playingTheHits) {
                console.log("Already playing the hits! Wait for the current song to finish.");
                return;
            }

            // Melodic patterns (rhythm and note patterns inspired by songs)
            const melodies = [
                // "Call Me Maybe" pattern - upbeat and catchy
                { name: "Call Me Maybe", notes: [659, 587, 523, 587, 659, 698, 783], durations: [0.15, 0.15, 0.2, 0.15, 0.15, 0.2, 0.3] },
                // "Who Let the Dogs Out" pattern - rhythmic and repetitive
                { name: "Who Let the Dogs Out", notes: [523, 523, 587, 659, 523, 523, 587, 659], durations: [0.12, 0.12, 0.12, 0.25, 0.12, 0.12, 0.12, 0.25] },
                // "Sittin' On The Dock of the Bay" pattern - relaxed whistling
                { name: "Sittin' On The Dock of the Bay", notes: [523, 587, 659, 698, 659, 587, 523], durations: [0.2, 0.2, 0.25, 0.3, 0.25, 0.2, 0.3] },
                // "Me and Julio" pattern - playful and light
                { name: "Me and Julio Down by the Schoolyard", notes: [587, 659, 698, 783, 698, 659, 587], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.25] },
                // "Young Folks" pattern - whistling melody
                { name: "Young Folks", notes: [880, 783, 698, 783, 880, 987, 880], durations: [0.2, 0.15, 0.15, 0.2, 0.2, 0.25, 0.3] },
                // "Pumped Up Kicks" pattern - mellow whistle
                { name: "Pumped Up Kicks", notes: [659, 698, 783, 698, 659, 587, 659], durations: [0.2, 0.2, 0.3, 0.2, 0.2, 0.2, 0.3] },
                // "Don't Worry Be Happy" pattern - cheerful whistling
                { name: "Don't Worry Be Happy", notes: [523, 659, 783, 880, 783, 659, 523], durations: [0.2, 0.2, 0.2, 0.3, 0.2, 0.2, 0.3] },
                // "Walk Like an Egyptian" pattern - quirky melody
                { name: "Walk Like an Egyptian", notes: [587, 523, 587, 698, 783, 698, 587], durations: [0.15, 0.15, 0.15, 0.2, 0.25, 0.2, 0.3] },
                // "Whistle While You Work" pattern - classic Disney whistle
                { name: "Whistle While You Work", notes: [523, 587, 659, 698, 783, 698, 659, 587, 523], durations: [0.15, 0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.15, 0.3] },
                // "Happy" by Pharrell - upbeat and cheerful
                { name: "Happy", notes: [659, 659, 698, 783, 880, 783, 698], durations: [0.15, 0.15, 0.2, 0.2, 0.3, 0.2, 0.3] },
                // "Somewhere Over the Rainbow" - classic dreamy melody
                { name: "Somewhere Over the Rainbow", notes: [523, 659, 783, 880, 987, 880, 783, 659], durations: [0.2, 0.2, 0.25, 0.3, 0.3, 0.25, 0.2, 0.3] },
                // "Lean on Me" - soulful and warm
                { name: "Lean on Me", notes: [587, 659, 698, 659, 587, 523], durations: [0.2, 0.25, 0.3, 0.25, 0.2, 0.3] },
                // "Three Little Birds" - reggae feel
                { name: "Three Little Birds", notes: [523, 587, 659, 698, 659, 587, 523], durations: [0.2, 0.2, 0.2, 0.25, 0.2, 0.2, 0.3] },
                // "What a Wonderful World" - gentle and sweet
                { name: "What a Wonderful World", notes: [523, 587, 659, 783, 880, 783, 659], durations: [0.25, 0.2, 0.25, 0.3, 0.3, 0.25, 0.3] },
                // 1980s and 90s classics
                { name: "Livin' On A Prayer", notes: [659, 698, 783, 880, 783, 698, 659], durations: [0.15, 0.15, 0.2, 0.3, 0.2, 0.15, 0.3] },
                { name: "Don't Stop Believin'", notes: [523, 587, 659, 698, 783, 698, 659], durations: [0.2, 0.2, 0.2, 0.25, 0.3, 0.25, 0.3] },
                { name: "Sweet Child O' Mine", notes: [587, 659, 698, 783, 698, 659, 587], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.3] },
                { name: "Take On Me", notes: [783, 880, 987, 1046, 987, 880, 783], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.3] },
                { name: "Africa", notes: [587, 659, 698, 783, 698, 659, 587, 523], durations: [0.2, 0.2, 0.2, 0.3, 0.2, 0.2, 0.2, 0.3] },
                { name: "Every Breath You Take", notes: [659, 698, 783, 880, 783, 698, 659], durations: [0.2, 0.2, 0.25, 0.3, 0.25, 0.2, 0.3] },
                { name: "I Wanna Dance with Somebody", notes: [698, 783, 880, 987, 880, 783, 698], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.3] },
                { name: "Girls Just Want to Have Fun", notes: [659, 698, 783, 698, 659, 587, 523], durations: [0.15, 0.15, 0.2, 0.2, 0.15, 0.15, 0.3] },
                { name: "Purple Rain", notes: [523, 587, 659, 698, 783, 698, 659], durations: [0.25, 0.25, 0.25, 0.3, 0.35, 0.3, 0.35] },
                { name: "Under Pressure", notes: [587, 659, 698, 659, 587, 523, 587], durations: [0.15, 0.15, 0.25, 0.2, 0.15, 0.15, 0.3] },
                { name: "Billie Jean", notes: [659, 698, 783, 698, 659, 587, 659], durations: [0.15, 0.15, 0.2, 0.2, 0.15, 0.15, 0.3] },
                { name: "Beat It", notes: [523, 587, 659, 698, 659, 587, 523], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.3] },
                { name: "Faith", notes: [587, 659, 698, 783, 880, 783, 698], durations: [0.15, 0.15, 0.2, 0.2, 0.25, 0.2, 0.3] },
                { name: "Wonderwall", notes: [587, 659, 698, 783, 698, 659, 587], durations: [0.2, 0.2, 0.25, 0.3, 0.25, 0.2, 0.3] }
            ];

            // Pick ONE random melody
            const melody = melodies[Math.floor(Math.random() * melodies.length)];
            console.log(`🎶 Playing: "${melody.name}"`);

            // Disable random chirping during performance
            playingTheHits = true;

            if (birds.length === 0) {
                console.log("No birds in the garden to sing!");
                playingTheHits = false;
                return;
            }

            // Divide the melody among available birds
            const availableBirds = birds.slice(0, Math.min(birds.length, melody.notes.length));
            const notesPerBird = Math.ceil(melody.notes.length / availableBirds.length);

            console.log(`🐦 ${availableBirds.length} birds will share the melody (${melody.notes.length} notes)`);

            let currentTime = audioContext.currentTime + 0.2; // Small delay to start
            let totalDuration = 0;

            // Each bird gets a portion of the melody
            availableBirds.forEach((bird, birdIndex) => {
                const startNote = birdIndex * notesPerBird;
                const endNote = Math.min(startNote + notesPerBird, melody.notes.length);

                for (let i = startNote; i < endNote; i++) {
                    const freq = melody.notes[i];
                    const duration = melody.durations[i];

                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    const filter = audioContext.createBiquadFilter();

                    osc.type = 'sine';
                    osc.frequency.value = freq;

                    filter.type = 'bandpass';
                    filter.frequency.value = freq;
                    filter.Q.value = 3;

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(audioContext.destination);

                    gain.gain.value = 0;
                    gain.gain.setValueAtTime(0, currentTime);
                    gain.gain.linearRampToValueAtTime(0.18, currentTime + 0.01);
                    gain.gain.linearRampToValueAtTime(0, currentTime + duration);

                    osc.start(currentTime);
                    osc.stop(currentTime + duration + 0.01);

                    currentTime += duration + 0.08; // Small gap between notes
                    totalDuration = currentTime - audioContext.currentTime;
                }
            });

            // Re-enable chirping after the song finishes
            setTimeout(() => {
                playingTheHits = false;
                console.log("🎵 Song finished! Regular chirping resumed.");
            }, totalDuration * 1000 + 500);
        };

        // Get all 24 melodies for hourly chimes - 1980s and 90s classics
        function getAllMelodies() {
            return [
                { name: "Sweet Child O' Mine", notes: [587, 659, 698, 783, 698, 659, 587], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.3] },
                { name: "Take On Me", notes: [783, 880, 987, 1046, 987, 880, 783], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.3] },
                { name: "Livin' On A Prayer", notes: [659, 698, 783, 880, 783, 698, 659], durations: [0.15, 0.15, 0.2, 0.3, 0.2, 0.15, 0.3] },
                { name: "Don't Stop Believin'", notes: [523, 587, 659, 698, 783, 698, 659], durations: [0.2, 0.2, 0.2, 0.25, 0.3, 0.25, 0.3] },
                { name: "Africa", notes: [587, 659, 698, 783, 698, 659, 587, 523], durations: [0.2, 0.2, 0.2, 0.3, 0.2, 0.2, 0.2, 0.3] },
                { name: "Every Breath You Take", notes: [659, 698, 783, 880, 783, 698, 659], durations: [0.2, 0.2, 0.25, 0.3, 0.25, 0.2, 0.3] },
                { name: "I Wanna Dance with Somebody", notes: [698, 783, 880, 987, 880, 783, 698], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.3] },
                { name: "Girls Just Want to Have Fun", notes: [659, 698, 783, 698, 659, 587, 523], durations: [0.15, 0.15, 0.2, 0.2, 0.15, 0.15, 0.3] },
                { name: "Purple Rain", notes: [523, 587, 659, 698, 783, 698, 659], durations: [0.25, 0.25, 0.25, 0.3, 0.35, 0.3, 0.35] },
                { name: "Under Pressure", notes: [587, 659, 698, 659, 587, 523, 587], durations: [0.15, 0.15, 0.25, 0.2, 0.15, 0.15, 0.3] },
                { name: "Walk Like an Egyptian", notes: [587, 523, 587, 698, 783, 698, 587], durations: [0.15, 0.15, 0.15, 0.2, 0.25, 0.2, 0.3] },
                { name: "Billie Jean", notes: [659, 698, 783, 698, 659, 587, 659], durations: [0.15, 0.15, 0.2, 0.2, 0.15, 0.15, 0.3] },
                { name: "Beat It", notes: [523, 587, 659, 698, 659, 587, 523], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.3] },
                { name: "Faith", notes: [587, 659, 698, 783, 880, 783, 698], durations: [0.15, 0.15, 0.2, 0.2, 0.25, 0.2, 0.3] },
                { name: "Careless Whisper", notes: [659, 698, 783, 880, 987, 880, 783], durations: [0.2, 0.2, 0.25, 0.3, 0.35, 0.3, 0.35] },
                { name: "Nothing Compares 2 U", notes: [523, 587, 659, 698, 783, 698, 659], durations: [0.25, 0.25, 0.25, 0.3, 0.35, 0.3, 0.35] },
                { name: "Wonderwall", notes: [587, 659, 698, 783, 698, 659, 587], durations: [0.2, 0.2, 0.25, 0.3, 0.25, 0.2, 0.3] },
                { name: "Smells Like Teen Spirit", notes: [523, 587, 523, 659, 698, 659, 587], durations: [0.15, 0.15, 0.15, 0.2, 0.25, 0.2, 0.3] },
                { name: "Mr. Brightside", notes: [659, 698, 783, 880, 783, 698, 659], durations: [0.15, 0.15, 0.2, 0.25, 0.2, 0.15, 0.3] },
                { name: "Don't You (Forget About Me)", notes: [587, 659, 698, 783, 880, 783, 698], durations: [0.2, 0.2, 0.2, 0.25, 0.3, 0.25, 0.3] },
                { name: "Everybody Wants to Rule the World", notes: [523, 587, 659, 698, 783, 698, 659, 587], durations: [0.2, 0.2, 0.2, 0.25, 0.3, 0.25, 0.2, 0.3] },
                { name: "The Power of Love", notes: [523, 659, 783, 880, 987, 880, 783, 659], durations: [0.25, 0.25, 0.25, 0.3, 0.35, 0.3, 0.25, 0.3] },
                { name: "Time After Time", notes: [659, 698, 783, 880, 783, 698, 659, 587], durations: [0.2, 0.2, 0.25, 0.3, 0.25, 0.2, 0.2, 0.3] },
                { name: "Don't Stop Believin'", notes: [523, 587, 659, 698, 783, 698, 659], durations: [0.2, 0.2, 0.2, 0.25, 0.3, 0.25, 0.3] }
            ];
        }

        // Shuffle array using Fisher-Yates algorithm
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Initialize hourly melody playlist
        function initializeHourlyPlaylist() {
            hourlyMelodyPlaylist = shuffleArray(getAllMelodies());
            melodyPlaylistIndex = 0;
            debugLog("Hourly melody playlist initialized and shuffled");
        }

        // Play hourly chime melody
        function playHourlyChime() {
            if (!clockEnabled || !audioContext || playingTheHits) return;
            if (isMuted) return;

            // Get next melody from playlist
            const melody = hourlyMelodyPlaylist[melodyPlaylistIndex];
            melodyPlaylistIndex = (melodyPlaylistIndex + 1) % hourlyMelodyPlaylist.length;

            // If we've cycled through all 24, reshuffle
            if (melodyPlaylistIndex === 0) {
                hourlyMelodyPlaylist = shuffleArray(getAllMelodies());
                debugLog("Reshuffled hourly melody playlist");
            }

            debugLog(`🕐 Hourly chime: "${melody.name}"`);

            // Disable random chirping during chime
            playingTheHits = true;

            if (birds.length === 0) {
                playingTheHits = false;
                return;
            }

            // Use available birds to play the melody
            const availableBirds = birds.slice(0, Math.min(birds.length, melody.notes.length));
            const notesPerBird = Math.ceil(melody.notes.length / availableBirds.length);

            let currentTime = audioContext.currentTime + 0.1;
            let totalDuration = 0;

            availableBirds.forEach((bird, birdIndex) => {
                const startNote = birdIndex * notesPerBird;
                const endNote = Math.min(startNote + notesPerBird, melody.notes.length);

                for (let i = startNote; i < endNote; i++) {
                    const freq = melody.notes[i];
                    const duration = melody.durations[i];

                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    const filter = audioContext.createBiquadFilter();

                    osc.type = 'sine';
                    osc.frequency.value = freq;

                    filter.type = 'bandpass';
                    filter.frequency.value = freq;
                    filter.Q.value = 3;

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(audioContext.destination);

                    gain.gain.value = 0;
                    gain.gain.setValueAtTime(0, currentTime);
                    gain.gain.linearRampToValueAtTime(0.15, currentTime + 0.01); // Slightly quieter than manual playthehits
                    gain.gain.linearRampToValueAtTime(0, currentTime + duration);

                    osc.start(currentTime);
                    osc.stop(currentTime + duration + 0.01);

                    currentTime += duration + 0.08;
                    totalDuration = currentTime - audioContext.currentTime;
                }
            });

            // Re-enable chirping after chime
            setTimeout(() => {
                playingTheHits = false;
            }, totalDuration * 1000 + 300);
        }

        // Check for hour change and play chime
        function checkHourlyChime() {
            if (!clockEnabled) return;

            const now = new Date();
            const currentHour = now.getHours();

            if (currentHour !== lastHourChimed) {
                lastHourChimed = currentHour;
                playHourlyChime();
            }
        }

        // Musical scales for bird chirps (frequencies in Hz)
        const BIRD_SCALES = {
            // Pentatonic scale (very melodic, used in many bird songs)
            pentatonic: [523.25, 587.33, 659.25, 783.99, 880.00, 1046.50, 1174.66, 1318.51], // C5-E6
            // Major scale (bright and cheerful)
            major: [523.25, 587.33, 659.25, 698.46, 783.99, 880.00, 987.77, 1046.50], // C5-C6
            // Minor pentatonic (more exotic)
            minorPentatonic: [440.00, 523.25, 587.33, 659.25, 783.99, 880.00, 1046.50], // A4-C6
            // High melodic (like a songbird)
            highMelodic: [783.99, 880.00, 987.77, 1046.50, 1174.66, 1318.51, 1396.91, 1567.98] // G5-G6
        };

        // Musical bird chirp synthesis with different voices per bird
        function synthBirdChirp(volume = 0.3, birdId = null) {
            console.log("synthBirdChirp called - volume:", volume, "birdId:", birdId);

            // Check if muted first
            if (isMuted) {
                console.log("Audio is muted, skipping chirp");
                return;
            }

            // Initialize audio context if needed
            if (!audioContext) {
                console.log("Initializing audio context...");
                initializeAudio();
            }

            // Resume audio context if suspended (required by browsers)
            if (audioContext && audioContext.state === 'suspended') {
                console.log("Resuming suspended audio context...");
                audioContext.resume();
            }

            if (!audioContext) {
                console.error("Audio context not available for bird chirp");
                return;
            }

            console.log("Audio context state:", audioContext.state);

            try {
                // Determine bird's unique voice based on ID
                let scale, oscType, pitchVariation;

                if (birdId !== null && birdId !== undefined && typeof birdId === 'number') {
                    // Give each bird a consistent voice based on their ID
                    const voiceIndex = birdId % 4;
                    const voiceTypes = [
                        { scale: BIRD_SCALES.pentatonic, type: 'sine', variation: 1.0, name: 'Melodic' },
                        { scale: BIRD_SCALES.major, type: 'triangle', variation: 1.05, name: 'Bright' },
                        { scale: BIRD_SCALES.minorPentatonic, type: 'sine', variation: 0.98, name: 'Exotic' },
                        { scale: BIRD_SCALES.highMelodic, type: 'sine', variation: 1.02, name: 'Songbird' }
                    ];

                    const voice = voiceTypes[voiceIndex];
                    scale = voice.scale;
                    oscType = voice.type;
                    pitchVariation = voice.variation;
                    console.log("Using bird voice:", voice.name, "for bird ID:", birdId);
                } else {
                    // Random voice if no bird ID provided
                    console.log("Using random voice (birdId was:", birdId, ")");
                    const scaleKeys = Object.keys(BIRD_SCALES);
                    scale = BIRD_SCALES[scaleKeys[Math.floor(Math.random() * scaleKeys.length)]];
                    oscType = Math.random() < 0.7 ? 'sine' : 'triangle';
                    pitchVariation = 0.98 + Math.random() * 0.04;
                }

                // Pick random notes from the bird's scale
                const noteIndex = Math.floor(Math.random() * scale.length);
                const baseFreq = scale[noteIndex] * pitchVariation;

                // Chirp pattern: pick 1-3 notes for variety
                const chirpPattern = Math.floor(Math.random() * 3) + 1;
                const chirpLength = 0.08 + Math.random() * 0.12;

                // Create oscillator
                const osc = audioContext.createOscillator();
                osc.type = oscType;
                osc.frequency.value = baseFreq;

                // Create gain node
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0;

                // Filter to shape the sound
                const filter = audioContext.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = baseFreq;
                filter.Q.value = 3;

                // Connect nodes
                osc.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // Start sound
                const now = audioContext.currentTime;
                console.log("Starting oscillator - baseFreq:", baseFreq, "type:", oscType, "pattern:", chirpPattern);
                osc.start(now);

                // Create musical chirp envelope with scale-based pitch changes
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + 0.01);
                console.log("Chirp playing - volume:", volume, "length:", chirpLength);

                // Musical frequency modulation - jump to scale tones
                if (chirpPattern === 1) {
                    // Single note with vibrato
                    osc.frequency.setValueAtTime(baseFreq, now);
                    osc.frequency.linearRampToValueAtTime(baseFreq * 1.05, now + chirpLength * 0.3);
                    osc.frequency.linearRampToValueAtTime(baseFreq, now + chirpLength);
                } else if (chirpPattern === 2) {
                    // Two note pattern (interval jump)
                    const nextNoteIndex = Math.min(noteIndex + 2, scale.length - 1);
                    const nextFreq = scale[nextNoteIndex] * pitchVariation;
                    osc.frequency.setValueAtTime(baseFreq, now);
                    osc.frequency.linearRampToValueAtTime(nextFreq, now + chirpLength * 0.5);
                    osc.frequency.linearRampToValueAtTime(nextFreq * 0.95, now + chirpLength);
                } else {
                    // Three note trill
                    const nextNote1 = scale[Math.min(noteIndex + 1, scale.length - 1)] * pitchVariation;
                    const nextNote2 = scale[Math.min(noteIndex + 3, scale.length - 1)] * pitchVariation;
                    osc.frequency.setValueAtTime(baseFreq, now);
                    osc.frequency.linearRampToValueAtTime(nextNote1, now + chirpLength * 0.3);
                    osc.frequency.linearRampToValueAtTime(nextNote2, now + chirpLength * 0.7);
                    osc.frequency.linearRampToValueAtTime(nextNote2 * 0.95, now + chirpLength);
                }

                // End the chirp
                gainNode.gain.linearRampToValueAtTime(0, now + chirpLength);
                osc.stop(now + chirpLength + 0.01);

                // Continue with a sequence of chirps (30% chance)
                if (Math.random() < 0.3) {
                    setTimeout(() => {
                        synthBirdChirp(volume * 0.85, birdId);
                    }, (chirpLength + 0.08 + Math.random() * 0.15) * 1000);
                }
            } catch (e) {
                console.error("Error playing bird chirp:", e);
            }
        }

        function playNote(note, duration = 4) {
            if (!audioContext) return;

            try {
                // Create oscillator for main tone
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                // Create a second oscillator for harmonics (metallic quality)
                const harmonicOsc = audioContext.createOscillator();
                const harmonicGain = audioContext.createGain();

                // Set type and frequency
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(windChimeSounds[note], audioContext.currentTime);

                // Harmonic oscillator (higher frequency for metallic sound)
                harmonicOsc.type = 'sine';
                harmonicOsc.frequency.setValueAtTime(windChimeSounds[note] * 2.7, audioContext.currentTime); // Upper harmonic
                harmonicGain.gain.setValueAtTime(0, audioContext.currentTime);
                harmonicGain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.1); // Reduced from 0.07 (25% reduction)
                harmonicGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);

                // Connect nodes
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                harmonicOsc.connect(harmonicGain);
                harmonicGain.connect(audioContext.destination);

                // Set envelope for wind chime sound with 25% reduced volume
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.2); // Reduced from 0.2 (25% reduction)
                gainNode.gain.exponentialRampToValueAtTime(0.0075, audioContext.currentTime + duration * 0.8); // Reduced from 0.01
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);

                // Start and stop
                oscillator.start();
                harmonicOsc.start();
                oscillator.stop(audioContext.currentTime + duration);
                harmonicOsc.stop(audioContext.currentTime + duration);
            } catch (e) {
                console.error("Error playing note:", e);
            }
        }

        // V26: Wind chime playback with adjusted timing
        function playWindChimes() {
    if (!windChimeEnabled) return;

    if (audioContext && audioContext.state === 'suspended') audioContext.resume();
    
    // Initialize audio context if needed
    if (!audioContext) initializeAudio();
    
    // IMPORTANT FIX: Check if audio context is suspended and resume it
    if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
            debugLog("Audio context resumed");
        }).catch(err => {
            console.error("Error resuming audio context:", err);
        });
    }
    
    // Update wind chime state
    const now = Date.now();
    
    // IMPROVED TIMING: Less frequent chimes for more natural sound (15-25 seconds)
    if (now - lastWindChimeTime > 15000 + Math.random() * 10000) {
        // Notes for wind chimes (pentatonic scale for more pleasant sound)
        const notes = ['C', 'D', 'E', 'G', 'A'];
        
        // Choose what to play - single note, harmonic interval, or chord
        const playType = Math.random();
        
        // DEBUG LOG to confirm wind chimes are playing
        debugLog(`Playing wind chimes (${now - windChimeStartTime}ms since started)`);
        
        if (playType < 0.5) {
            // Play a single note
            const note = notes[Math.floor(Math.random() * notes.length)];
            debugLog(`Wind chime sound: ${note}`);
            playNote(note, 4);
        } else if (playType < 0.8) {
            // Play harmonic intervals (two notes)
            const note1 = notes[Math.floor(Math.random() * notes.length)];
            const note2 = notes[(notes.indexOf(note1) + 2) % notes.length]; // Musical interval
            
            debugLog(`Wind chime harmony: ${note1}-${note2}`);
            playNote(note1, 4);
            setTimeout(() => { playNote(note2, 4); }, 200);
        } else {
            // Play a chord with slight timing differences for realism
            const rootIndex = Math.floor(Math.random() * notes.length);
            const note1 = notes[rootIndex];
            const note2 = notes[(rootIndex + 2) % notes.length];
            const note3 = notes[(rootIndex + 4) % notes.length];
            
            debugLog(`Wind chime chord: ${note1}-${note2}-${note3}`);
            
            // Stagger notes slightly for natural wind effect
            playNote(note1, 5);
            setTimeout(() => { playNote(note2, 4.5); }, 50 + Math.random() * 100);
            setTimeout(() => { playNote(note3, 4); }, 150 + Math.random() * 150);
        }
        
        lastWindChimeTime = now;
        
        // Schedule next chime (with debug log to confirm the timeout is working)
        clearTimeout(windChimeTimeout); // Clear any existing timeout to be safe
        
        debugLog(`Scheduling next wind chime in ~20 seconds`);
        // Use a recurring interval instead of a single timeout for more reliability
        windChimeTimeout = setInterval(() => {
            // The interval will call this function every 5 seconds
            // But we'll only actually play a chime when it's time
            const checkNow = Date.now();
            if (checkNow - lastWindChimeTime > 15000 + (Math.random() * 5000)) {
                debugLog("Wind chime timer triggered - time to play");
                // Don't call playWindChimes() recursively - that could stack
                // Instead, directly play the chime sounds here
                
                // Notes for wind chimes (pentatonic scale for more pleasant sound)
                const notes = ['C', 'D', 'E', 'G', 'A'];
                
                // Choose what to play - single note, harmonic interval, or chord
                const playType = Math.random();
                
                if (playType < 0.5) {
                    // Play a single note
                    const note = notes[Math.floor(Math.random() * notes.length)];
                    debugLog(`Wind chime sound: ${note}`);
                    playNote(note, 4);
                } else if (playType < 0.8) {
                    // Play harmonic intervals (two notes)
                    const note1 = notes[Math.floor(Math.random() * notes.length)];
                    const note2 = notes[(notes.indexOf(note1) + 2) % notes.length]; // Musical interval
                    
                    debugLog(`Wind chime harmony: ${note1}-${note2}`);
                    playNote(note1, 4);
                    setTimeout(() => { playNote(note2, 4); }, 200);
                } else {
                    // Play a chord with slight timing differences for realism
                    const rootIndex = Math.floor(Math.random() * notes.length);
                    const note1 = notes[rootIndex];
                    const note2 = notes[(rootIndex + 2) % notes.length];
                    const note3 = notes[(rootIndex + 4) % notes.length];
                    
                    debugLog(`Wind chime chord: ${note1}-${note2}-${note3}`);
                    
                    // Stagger notes slightly for natural wind effect
                    playNote(note1, 5);
                    setTimeout(() => { playNote(note2, 4.5); }, 50 + Math.random() * 100);
                    setTimeout(() => { playNote(note3, 4); }, 150 + Math.random() * 150);
                }
                
                lastWindChimeTime = checkNow;
            }
        }, 5000); // Check every 5 seconds, but only play at appropriate intervals
        
        // Add it to animation timers for proper cleanup
        addTimer(windChimeTimeout, true); // true = is interval (not timeout)
    }
    
    // Check if wind chimes
    
    // Directly turn off wind chimes instead of calling non-existent function
    windChimeEnabled = false;
    
    // Stop any pending wind chimes
    if (windChimeTimeout) {
        clearTimeout(windChimeTimeout);
        windChimeTimeout = null;
    }
    
    windChimeStartTime = 0;
    lastWindChimeTime = 0;
    
    // Update button text
    const toggleWindChimeBtn = document.getElementById('toggleWindChimeBtn');
    if (toggleWindChimeBtn) {
        toggleWindChimeBtn.textContent = '🔔 Wind Chimes: OFF';
        toggleWindChimeBtn.style.background = '#f44336'; // Red background
    }
    
    debugLog("Wind chimes disabled due to timeout");
}

        // Draw visual music notes for chirps (accessibility feature for hearing impaired)
        function drawChirpMusicNotes(now) {
            activeChirps.forEach(chirp => {
                const age = now - chirp.timestamp;
                const maxAge = 2000;
                const progress = age / maxAge;

                // Fade out and float up
                const opacity = 1 - progress;
                const floatUp = progress * (mushroomMode ? 60 : 30); // Float higher in mushroom mode

                // Different note styles based on chirp type
                let noteSymbol = '♪';
                let noteColor = '#000000';
                let noteSize = 16;

                switch(chirp.type) {
                    case CHIRP_TYPES.SOCIAL:
                        noteSymbol = '♪';
                        noteColor = '#4CAF50'; // Green
                        noteSize = 14;
                        break;
                    case CHIRP_TYPES.FOOD_CALL:
                        noteSymbol = '♫';
                        noteColor = '#FF9800'; // Orange
                        noteSize = 18;
                        break;
                    case CHIRP_TYPES.CONTACT_CALL:
                        noteSymbol = '♪';
                        noteColor = '#2196F3'; // Blue
                        noteSize = 12;
                        break;
                    case CHIRP_TYPES.ALERT:
                        noteSymbol = '♬';
                        noteColor = '#F44336'; // Red
                        noteSize = 20;
                        break;
                    case CHIRP_TYPES.TERRITORIAL:
                        noteSymbol = '♩';
                        noteColor = '#9C27B0'; // Purple
                        noteSize = 16;
                        break;
                    case CHIRP_TYPES.VICTORY:
                        noteSymbol = '♫♪';
                        noteColor = '#FFD700'; // Gold
                        noteSize = 20;
                        break;
                }

                // Mushroom mode: MUCH larger notes with dynamic expansion
                if (mushroomMode) {
                    // Start at 2x size and expand to 4x, then shrink back
                    const expansionCurve = Math.sin(progress * Math.PI); // 0 -> 1 -> 0
                    const sizeMultiplier = 2 + (expansionCurve * 2); // 2x to 4x to 2x
                    noteSize = noteSize * sizeMultiplier;

                    // Rainbow cycling color
                    const hue = (colorCycleTimer / 50 + chirp.timestamp / 100) % 360;
                    noteColor = `hsl(${hue}, 100%, 60%)`;
                }

                // Draw music note
                ctx.save();
                ctx.globalAlpha = opacity;
                ctx.font = `bold ${noteSize}px Arial`;
                ctx.fillStyle = noteColor;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Add wobble (more dramatic in mushroom mode)
                const wobbleAmount = mushroomMode ? 10 : 3;
                const wobble = Math.sin(age / 100) * wobbleAmount;

                // Rotation in mushroom mode
                if (mushroomMode) {
                    ctx.translate(chirp.x + wobble, chirp.y - 20 - floatUp);
                    ctx.rotate((progress * 360 * Math.PI) / 180); // Full rotation
                    ctx.fillText(noteSymbol, 0, 0);
                } else {
                    ctx.fillText(noteSymbol, chirp.x + wobble, chirp.y - 20 - floatUp);
                }

                // Add glow effect (enhanced in mushroom mode)
                const glowIntensity = mushroomMode ? 15 : 5;
                if (chirp.intensity > 1 || mushroomMode) {
                    ctx.shadowColor = noteColor;
                    ctx.shadowBlur = glowIntensity * (chirp.intensity || 1);
                    if (mushroomMode) {
                        ctx.fillText(noteSymbol, 0, 0);
                    } else {
                        ctx.fillText(noteSymbol, chirp.x + wobble, chirp.y - 20 - floatUp);
                    }
                }

                ctx.restore();
            });
        }

        // Update and draw all elements
        // Weather Forecast System - ACCURATE for next 3 minutes
        function generateWeatherForecast() {
            const currentTime = Date.now();
            const threeMinutesFromNow = currentTime + (3 * 60 * 1000); // 3 minutes

            nextWeatherEvents = [];

            // Check if currently raining
            if (isRaining) {
                nextWeatherEvents.push({
                    type: isThundering ? 'thunder' : 'rain',
                    icon: isThundering ? '⛈️' : '🌧️',
                    time: currentTime
                });
            }

            // Check if rain is scheduled within next 3 minutes
            if (window.nextScheduledRainTime) {
                const timeUntilRain = window.nextScheduledRainTime - currentTime;

                if (timeUntilRain > 0 && timeUntilRain <= 180000) { // Within 3 minutes
                    const willThunder = window.nextRainWillThunder || false;
                    nextWeatherEvents.push({
                        type: willThunder ? 'thunder' : 'rain',
                        icon: willThunder ? '⛈️' : '🌧️',
                        time: window.nextScheduledRainTime
                    });
                }
            }

            // Fill remaining slots with clear weather if less than 3 events
            while (nextWeatherEvents.length < 3) {
                nextWeatherEvents.push({
                    type: 'clear',
                    icon: '☀️',
                    time: currentTime + (60000 * (nextWeatherEvents.length + 1)) // 1, 2, 3 minutes out
                });
            }

            // Only show first 3
            nextWeatherEvents = nextWeatherEvents.slice(0, 3);
        }

        // Draw large transparent clock in sky with forecast
        function drawClock() {
            if (!clockEnabled) return;

            const now = new Date();
            const hours = now.getHours();
            const minutes = now.getMinutes();
            const seconds = now.getSeconds();

            // Format time (24-hour format)
            const hourStr = hours.toString().padStart(2, '0');
            const minuteStr = minutes.toString().padStart(2, '0');

            // Large transparent clock in upper sky - DOUBLED SIZE
            const clockY = canvas.height * 0.2;
            const clockCenterX = canvas.width / 2;

            // Subtle shadow for visibility
            ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            // Base opacity for clock
            const timeOpacity = mushroomMode ? 0.25 : 0.2;

            // Draw time - now MUCH LARGER (280px instead of 140px)
            const fontSize = 280;
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Build the time string and draw each character individually
            const timeText = `${hourStr}:${minuteStr}`;
            const charWidth = 160; // approximate width per character (doubled from 80)
            const totalWidth = timeText.length * charWidth;
            const startTextX = clockCenterX - (totalWidth / 2);

            // Check which birds are perched on clock numbers
            const birdsOnClock = [];
            if (window.clockNumberPositions) {
                birds.forEach(bird => {
                    if (bird.perchTarget && bird.perchTarget.isClock) {
                        birdsOnClock.push({
                            birdX: bird.x,
                            birdY: bird.y
                        });
                    }
                });
            }

            // Store clock number positions for bird landing
            window.clockNumberPositions = [];

            // Store previous time for spook detection
            if (!window.previousClockTime) {
                window.previousClockTime = timeText;
            }

            // Draw each character with individual opacity based on bird presence
            for (let i = 0; i < timeText.length; i++) {
                const char = timeText[i];
                const charX = startTextX + (i * charWidth);
                const charY = clockY;

                // Check if a bird is near this character
                let birdNearby = false;

                // Store position for perching (including colon!)
                window.clockNumberPositions.push({
                    x: charX,
                    y: clockY - 100, // top of numbers (adjusted for larger size)
                    width: charWidth,
                    charIndex: i,
                    char: char,
                    isColon: char === ':'
                });

                // Check if any bird is perched on this character
                birdNearby = birdsOnClock.some(birdPos => {
                    const dist = Math.sqrt(
                        Math.pow(birdPos.birdX - charX, 2) +
                        Math.pow(birdPos.birdY - (clockY - 100), 2)
                    );
                    return dist < charWidth;
                });

                // Increase opacity if bird is nearby
                const charOpacity = birdNearby ? timeOpacity * 3 : timeOpacity; // 3x more opaque with bird
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.min(charOpacity, 0.7)})`; // cap at 0.7

                // Draw this character
                ctx.fillText(char, charX, charY);
            }

            // Detect time change and spook birds
            if (window.previousClockTime !== timeText) {
                // Time has changed! Spook any birds on the clock
                birds.forEach(bird => {
                    if (bird.perchTarget && bird.perchTarget.isClock) {
                        // Bird is on clock - get spooked!
                        bird.state = BIRD_STATES.FLEEING;
                        bird.stateTimer = 0;
                        bird.perchTarget = null;

                        // Fly away in random direction
                        const fleeX = bird.x + (Math.random() - 0.5) * 400;
                        const fleeY = bird.y - 100 - Math.random() * 100;
                        bird.generatePath(fleeX, fleeY);

                        debugLog(`Bird spooked by clock change! ${window.previousClockTime} -> ${timeText}`);
                    }
                });
                window.previousClockTime = timeText;
            }

            // Draw weather forecast icons below clock
            const forecastY = clockY + 180;
            const iconSpacing = 120; // Slightly larger spacing
            const startX = clockCenterX - iconSpacing;

            ctx.font = '60px Arial'; // Slightly larger icons
            ctx.shadowBlur = 5;

            for (let i = 0; i < Math.min(3, nextWeatherEvents.length); i++) {
                const event = nextWeatherEvents[i];
                const x = startX + (i * iconSpacing);

                // Draw icon with slight transparency
                ctx.fillStyle = `rgba(255, 255, 255, ${timeOpacity * 1.2})`;
                ctx.fillText(event.icon, x, forecastY);
            }

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
        }

        // Update forecast periodically
        let lastForecastUpdate = 0;
        function updateWeatherForecast() {
            const now = Date.now();
            if (now - lastForecastUpdate > 60000) { // Update every minute
                generateWeatherForecast();
                lastForecastUpdate = now;
            }
        }

        // ===== GARDEN DIARY SYSTEM =====

        // Add a diary entry
        function addDiaryEntry(event, type = 'general') {
            const entry = {
                day: dayNightCycleCount,
                event: event,
                timestamp: Date.now(),
                type: type
            };
            diaryEntries.push(entry);

            // Keep only last 50 entries
            if (diaryEntries.length > 50) {
                diaryEntries.shift();
            }

            updateDiaryDisplay();
            debugLog(`Diary: ${event}`);
        }

        // Get or assign a name to a bird
        function getBirdName(bird) {
            if (!birdFamilies.has(bird.id)) {
                // This is a new bird, assign a name
                const baseName = BIRD_NAME_POOL[Math.floor(Math.random() * BIRD_NAME_POOL.length)];

                // Check if name is already used, add suffix if needed
                let finalName = baseName;
                let suffix = 2;
                const existingNames = Array.from(birdFamilies.values()).map(f => f.name);

                while (existingNames.includes(finalName)) {
                    finalName = `${baseName} ${suffix}`;
                    suffix++;
                }

                birdFamilies.set(bird.id, {
                    name: finalName,
                    generation: 1,
                    parents: null,
                    birdType: bird.birdType.name
                });
            }

            return birdFamilies.get(bird.id).name;
        }

        // Register a baby bird with parents
        function registerBabyBird(baby, parent) {
            if (!baby || !parent) return;

            const parentInfo = birdFamilies.get(parent.id);
            if (!parentInfo) {
                // Parent doesn't have a name yet, give them one
                getBirdName(parent);
            }

            const parentData = birdFamilies.get(parent.id);
            const baseName = parentData.name.split(' ')[0]; // Get base name without suffix
            const generation = parentData.generation + 1;

            // Create generational name
            let babyName = baseName;
            if (generation === 2) {
                babyName = `${baseName} Jr.`;
            } else if (generation > 2) {
                // Use roman numerals for generation 3+
                const romanNumerals = ['', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X'];
                babyName = `${baseName} ${romanNumerals[Math.min(generation, 10)]}`;
            }

            birdFamilies.set(baby.id, {
                name: babyName,
                generation: generation,
                parents: [parentData.name],
                birdType: baby.birdType.name
            });

            return babyName;
        }

        // Update diary display
        function updateDiaryDisplay() {
            const diaryEntriesDiv = document.getElementById('diaryEntries');
            const birdFamiliesDiv = document.getElementById('birdFamilies');
            const diaryDayCount = document.getElementById('diaryDayCount');

            if (!diaryEntriesDiv) return;

            // Update day count
            if (diaryDayCount) {
                diaryDayCount.textContent = dayNightCycleCount;
            }

            // Update diary entries (newest first)
            if (diaryEntries.length > 0) {
                let entriesHTML = '';
                const sortedEntries = [...diaryEntries].reverse();

                sortedEntries.forEach(entry => {
                    const icon = entry.type === 'birth' ? '🐣' :
                                entry.type === 'nest' ? '🏠' :
                                entry.type === 'weather' ? '⛈️' :
                                entry.type === 'visitor' ? '🦅' :
                                entry.type === 'special' ? '✨' :
                                entry.type === 'milestone' ? '🎯' : '📝';

                    entriesHTML += `<p style="margin: 8px 0; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px;">
                        ${icon} <strong>Day ${entry.day}:</strong> ${entry.event}
                    </p>`;
                });

                diaryEntriesDiv.innerHTML = entriesHTML;
            }

            // Update bird families
            if (birdFamiliesDiv && birdFamilies.size > 0) {
                let familiesHTML = '';
                const familyGroups = new Map();

                // Group birds by base name
                for (const [id, info] of birdFamilies.entries()) {
                    const baseName = info.name.split(' ')[0];
                    if (!familyGroups.has(baseName)) {
                        familyGroups.set(baseName, []);
                    }
                    familyGroups.get(baseName).push(info);
                }

                // Display families
                for (const [baseName, members] of familyGroups.entries()) {
                    if (members.length > 1) {
                        // This is a lineage
                        const sorted = members.sort((a, b) => a.generation - b.generation);
                        familiesHTML += `<div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.03); border-radius: 4px;">
                            <strong>The ${baseName} Family</strong> (${sorted[0].birdType})
                            <ul style="margin: 5px 0; padding-left: 20px; font-size: 0.9em;">`;

                        sorted.forEach(member => {
                            const genText = member.generation === 1 ? '(Founder)' :
                                          member.generation === 2 ? '(Child)' :
                                          `(Gen ${member.generation})`;
                            familiesHTML += `<li>${member.name} ${genText}</li>`;
                        });

                        familiesHTML += `</ul></div>`;
                    }
                }

                if (familiesHTML) {
                    birdFamiliesDiv.innerHTML = familiesHTML;
                } else {
                    birdFamiliesDiv.innerHTML = '<p style="color: #999; font-style: italic;">Bird lineages will appear as families grow...</p>';
                }
            }
        }

        function updateAndDraw(timestamp) {
    if (!animationRunning) return;

    // Calculate delta time with a max to prevent large jumps
    const now = Date.now();
    let deltaTime = Math.min(100, now - lastTime);
    lastTime = now;

    // Update simulation time
    simulationTime += deltaTime;

// Update color cycling for mushroom mode
if (mushroomMode) {
        colorCycleTimer += deltaTime;
    }

    // Update weather forecast on the minute (every 60 seconds)
    if (!window.lastForecastUpdate) {
        window.lastForecastUpdate = now;
        generateWeatherForecast();
    }
    const timeSinceLastForecastUpdate = now - window.lastForecastUpdate;
    if (timeSinceLastForecastUpdate >= 60000) { // 60 seconds = 1 minute
        generateWeatherForecast();
        window.lastForecastUpdate = now;
        debugLog("Weather forecast updated (on the minute)");
    }

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Update day/night cycle
    updateDayNightCycle(deltaTime);

    // Update rainbow if active
    updateRainbow(deltaTime);
    
    // Check for conditions for rainbow
    if (wasRaining && !isRaining) {
        checkForRainbow();
    }
    
    // ADD THIS LINE RIGHT HERE after rainbow checks:
    // Check for magic mushroom spawning
    checkForMagicMushroom();




    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Update day/night cycle
    updateDayNightCycle(deltaTime);

    // Update rainbow if active
    updateRainbow(deltaTime);
    
    // Check for conditions for rainbow
    if (wasRaining && !isRaining) {
        checkForRainbow();
    }
    
    // Check for scarecrow creation
    checkForScarecrow();
    
    // Update scarecrow animation
    updateScarecrow(deltaTime);

    // ===== BACKGROUND LAYER =====
    // Draw the sky background with day/night changes
    drawBackground();

    // Draw rainbow if visible (behind most elements)
    if (rainbowVisible) {
        drawRainbow();
    }

    // Draw curtains (if enabled)
    if (showCurtains) {
        drawCurtains();
    }

    // ===== MIDDLE GROUND LAYER =====
    // Draw trees in proper depth order (back to front)
    drawTrees(deltaTime);
    
    // Draw puddles under everything else
    updatePuddles(deltaTime);
    drawPuddles();

    // Update and draw ponds, frogs, and koi
    updatePonds(deltaTime);
    drawPonds();
    updateKoi(deltaTime);
    drawKoi();
    updateFrogs(deltaTime);
    drawFrogs();

    // Draw ground elements
    drawTwigs();
    drawFlowers();
    drawMagicMushroom();
    drawFood(deltaTime);
    drawBirdPoops(deltaTime);
    drawWorms();

    // ===== BUILT STRUCTURES LAYER =====
    // Draw birdhouses (they should be behind nests)
    for (const birdhouse of birdhouses) {
        birdhouse.draw();
    }

    // Draw nests (they should be on trees but behind birds)
    for (const nest of nests) {
        nest.draw();
    }

    // Draw scarecrow (behind moving animals)
if (mushroomMode) {
    drawMushroomScarecrow();
} else {
    drawScarecrow(); // Original scarecrow drawing
}

    // Update and draw ant hill and ants
updateAnts(deltaTime);
drawAnts();

    // ===== ANIMALS LAYER =====
    // Draw rats (usually on ground level)
    for (let i = rats.length - 1; i >= 0; i--) {
        const remove = rats[i].update(deltaTime);
        if (remove) {
            rats.splice(i, 1);
        } else {
            rats[i].draw();
        }
    }

    // Draw squirrels 
    for (let i = squirrels.length - 1; i >= 0; i--) {
        const remove = squirrels[i].update(deltaTime);
        if (remove) {
            squirrels.splice(i, 1);
        } else {
            squirrels[i].draw();
        }
    }
    
    // Update and draw baby birds
    for (let i = babyBirds.length - 1; i >= 0; i--) {
        const remove = babyBirds[i].update(deltaTime);
        if (remove) {
            babyBirds.splice(i, 1);
        } else {
            babyBirds[i].draw();
        }
    }

    // Update stuck birds logic
    resetStuckBirds();
    
    // Update and draw birds (they should be above most elements)
    for (let i = birds.length - 1; i >= 0; i--) {
        const remove = birds[i].update(deltaTime);
        if (remove) {
            // Remove from any occupied birdhouse
            for (const birdhouse of birdhouses) {
                birdhouse.removeOccupant(birds[i]);
            }
            birds.splice(i, 1);
        } else {
            birds[i].draw();
        }
    }


// ADD updateBirdTrails() RIGHT HERE, just after the birds loop 👇
updateBirdTrails();

drawBirdTrails();

    // Update and draw butterflies
    for (let i = butterflies.length - 1; i >= 0; i--) {
        const remove = butterflies[i].update(deltaTime);
        if (remove) {
            butterflies.splice(i, 1);
        } else {
            butterflies[i].draw();
        }
    }
// Update and draw gameboy
updateGameboy(deltaTime);



    // Update and draw owls
for (let i = owls.length - 1; i >= 0; i--) {
    const remove = owls[i].update(deltaTime);
    if (remove) {
        owls.splice(i, 1);
    } else {
        owls[i].draw();
    }
}
    
    // Check and update crow visit logic
    checkForCrowVisit(deltaTime);

    // Update and draw crows (they should be on top of birds)
    for (let i = crows.length - 1; i >= 0; i--) {
        const remove = crows[i].update(deltaTime);
        if (remove) {
            crows.splice(i, 1);
        } else {
            crows[i].draw();
        }
    }

    // ===== WEATHER/EFFECTS LAYER (always on top) =====
    // Draw rain if raining
    if (isRaining) {
        drawRain(deltaTime);
    }

    // Draw lightning strikes if present
    updateLightningStrikes(deltaTime);
    drawLightningStrikes();

    // Draw special effects
    drawSpecialEffects(deltaTime);

    // ===== CLOCK AND FORECAST LAYER =====
    // Update and draw clock if enabled
    if (clockEnabled) {
        updateWeatherForecast();
        drawClock();
        checkHourlyChime(); // Check if it's a new hour and play melody
    }

    // ===== DEBUG LAYER (very top) =====
    // Draw off-screen indicators in debug mode
    drawOffscreenIndicators();

    // Draw debug visuals after everything else
    drawDebugVisuals();

    // ===== PERIODIC UPDATES =====
    // Do periodic spawning and checks
    if (simulationTime % TWIG_SPAWN_RATE < 16) {
        spawnTwigs();
    }
    
    if (simulationTime % BIRD_SPAWN_RATE < 16) { 
        if (birds.length < MAX_BIRDS && dayNightCycleCount > 0) {
            spawnBird();
            debugLog(`Scheduled bird spawning check - current count: ${birds.length}`);
        }
    }

    if (simulationTime % 15000 < 16) {
        if (timeOfDay >= 1) { // It's night time
            spawnNightWorms();
        }
    }

    if (simulationTime % 15000 < 16) {
    spawnOwls();
}

    if (simulationTime % 30000 < 16) {
        const currentTime = Date.now();
        for (const nest of nests) {
            nest.checkReadyForNewBabies(currentTime);
        }
    }

    if (simulationTime % 3000 < 16) {
        checkAndAlertForHungryBabies();
    }

    if (simulationTime % WILD_BIRD_SPAWN_RATE < 16) {
        spawnWildBird();
    }

    if (simulationTime % WORM_SPAWN_RATE < 16) {
        spawnWorms();
    }

    if (simulationTime % 5000 < 16) {
        spawnSquirrels();
    }

    if (simulationTime % 8000 < 16) {
        spawnRats();
    }

    if (simulationTime % 5000 < 16) {
        spawnButterflies();
    }

    if (simulationTime % TREE_REGROWTH_RATE < 16) {
        regrowTrees();
    }

    // === NEW BEHAVIOR SYSTEM UPDATES ===
    // Process synchronized chirping (reuse 'now' from line 13091)
    activeChirps = activeChirps.filter(chirp => now - chirp.timestamp < 2000); // Keep chirps for 2 seconds

    // Draw visual music notes for chirps (accessibility feature)
    drawChirpMusicNotes(now);

    // Synchronized chirping - social chirps trigger nearby birds to chirp
    if (activeChirps.length > 0 && Math.random() < 0.05) {
        const recentChirps = activeChirps.filter(c =>
            c.type === CHIRP_TYPES.SOCIAL && now - c.timestamp < 500
        );

        recentChirps.forEach(chirp => {
            // Find nearby birds to potentially trigger
            const nearbyBirds = birds.filter(b =>
                distance(b.x, b.y, chirp.x, chirp.y) < 150 &&
                b.id !== chirp.birdId &&
                !b.defeatedRecently
            );

            nearbyBirds.forEach(bird => {
                // 10% chance to chirp in response (cascade effect)
                if (Math.random() < 0.1 && now - bird.lastChirp > 2000) {
                    bird.chirp(CHIRP_TYPES.SOCIAL, 0.6);
                }
            });
        });
    }

    // Clean up old danger zones
    dangerZones = dangerZones.filter(d => now - d.timestamp < DANGER_MEMORY_DURATION);

    // Clean up old shared food knowledge
    sharedFoodKnowledge = sharedFoodKnowledge.filter(f => now - f.timestamp < FOOD_KNOWLEDGE_DURATION);

    // Clean up completed mobbings
    activeMobbings = activeMobbings.filter(m => now - m.startTime < MOBBING_DURATION);

    // Clean up old territorial disputes
    territorialDisputes = territorialDisputes.filter(d => now - d.startTime < 10000);

    if (simulationTime % GUARANTEED_TREE_CHECK_RATE < 16) {
        checkEcosystemHealth();
    }

    if (simulationTime % BRANCH_GROWTH_INTERVAL < 16 && Math.random() < 0.5) {
        // Find a healthy tree to add a branch to
        const healthyTrees = trees.filter(tree => tree.health > 70 && tree.branches.length < 5);
        if (healthyTrees.length > 0) {
            const randomTree = healthyTrees[Math.floor(Math.random() * healthyTrees.length)];
            addBranchToTree(randomTree);
        }
    }

    // Update stats once per second
    if (now - lastStatsUpdate > 1000) {
        updateStats();
        lastStatsUpdate = now;
    }

    // Update advanced debug if enabled
    updateAdvancedDebug(deltaTime);

    // Request next frame
    requestAnimationFrame(updateAndDraw);
}


// Add this new function for taking screenshots
function takeScreenshot() {
    try {
        // Temporarily hide the info panel for the screenshot
        const infoPanel = document.getElementById('infoPanel');
        const wasVisible = infoPanel.style.display !== 'none';
        if (wasVisible) infoPanel.style.display = 'none';
        
        // Hide debug visuals temporarily if they're showing
        const debugActive = debugVisuals;
        if (debugActive) debugVisuals = false;
        
        // Redraw the canvas without these elements
        drawFullScene();
        
        // Convert canvas to data URL
        const dataUrl = canvas.toDataURL('image/png');
        
        // Create a link element to download the image
        const link = document.createElement('a');
        link.download = `garden-view-${new Date().toISOString().slice(0,10)}.png`;
        link.href = dataUrl;
        link.click();
        
        // Show a message
        const message = document.getElementById('screenshotMessage');
        message.style.display = 'block';
        setTimeout(() => {
            message.style.display = 'none';
        }, 2000);
        
        // Restore the info panel if it was visible
        if (wasVisible) infoPanel.style.display = 'block';
        
        // Restore debug visuals if they were active
        if (debugActive) debugVisuals = true;
        
        debugLog("Screenshot taken and saved");
    } catch (e) {
        console.error("Error taking screenshot:", e);
    }
}

// Helper function to draw the full scene for the screenshot
function drawFullScene() {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw all elements in the correct order
    drawBackground();
    
    if (rainbowVisible) {
        drawRainbow();
    }
    
    if (showCurtains) {
        drawCurtains();
    }
    
    // Draw trees
    const sortedTrees = [...trees].sort((a, b) => b.depth - a.depth);
    for (const tree of sortedTrees) {
        tree.draw();
    }
    
    // Draw elements in proper layer order
    drawPuddles();
    drawTwigs();
    drawFlowers();
    drawFood(0);
    drawBirdPoops(0);
    
    // Draw birdhouses and nests
    for (const birdhouse of birdhouses) {
        birdhouse.draw();
    }
    
    for (const nest of nests) {
        nest.draw();
    }
    
    if (mushroomMode) {
    drawMushroomScarecrow();
} else {
    drawScarecrow(); // Original scarecrow drawing
}
    
// Draw ant hill and ants
if (antHill) {
    drawAnts();
}


    // Draw worms
    drawWorms();
    
    // Draw animals in correct order
    for (const rat of rats) {
        rat.draw();
    }
    
    for (const squirrel of squirrels) {
        squirrel.draw();
    }
    
    for (const baby of babyBirds) {
        baby.draw();
    }
    
    for (const bird of birds) {
        bird.draw();
    }
    
    for (const butterfly of butterflies) {
        butterfly.draw();
    }

     // Add owls to drawing order
     for (const owl of owls) {
        owl.draw();
    }
    
    for (const crow of crows) {
        crow.draw();
    }
    
    // Draw weather effects
    if (isRaining) {
        drawRain(0);
    }
    
    drawLightningStrikes();
    drawSpecialEffects(0);
}


        // Start animation
        function startAnimation() {
            if (animationRunning) return;
            
            // Create initial trees
            const initialTreeCount = 5 + Math.floor(Math.random() * 3);
            for (let i = 0; i < initialTreeCount; i++) {
                const x = 100 + (i * (canvas.width - 200) / initialTreeCount) + 
                    (Math.random() - 0.5) * 100;
                
                // Varied tree sizes
                const isTall = Math.random() < 0.2;
                const trunkHeight = isTall ? 
                    150 + Math.random() * 60 : 
                    100 + Math.random() * 40;
                const trunkWidth = isTall ? 
                    20 + Math.random() * 10 : 
                    15 + Math.random() * 8;
                const leafRadius = isTall ? 
                    50 + Math.random() * 20 : 
                    40 + Math.random() * 15;
                
                if (isTall) tallTreeCount++;
                
                // Always include some branches
                trees.push(new Tree(
                    x, 
                    trunkWidth, 
                    trunkHeight, 
                    leafRadius, 
                    true // Always include branches for initial trees
                ));
            }
            
            // Add initial birds with staggered entry
            const initialBirds = 3; // Ensure 3 initial birds
            let delay = 2000; // Start after 2 seconds
            for (let i = 0; i < initialBirds; i++) {
                setTimeout(() => {
                    // Create bird at random edge
                    const bird = new Bird();
                    
                    // Position bird just off-screen
                    const isHorizontal = Math.random() < 0.5;
                    if (isHorizontal) {
                        bird.x = Math.random() < 0.5 ? -20 : canvas.width + 20;
                        bird.y = 100 + Math.random() * 150;
                    } else {
                        bird.x = 100 + Math.random() * (canvas.width - 200);
                        bird.y = -20;
                    }
                    
                    // Give bird a path to fly into the garden
                    bird.state = BIRD_STATES.FLYING;
                    bird.direction = bird.x < 0 ? 1 : -1;
                    
                    // Target middle of screen
                    const targetX = canvas.width / 2 + (Math.random() - 0.5) * 200;
                    const targetY = 100 + Math.random() * 150;
                    bird.generatePath(targetX, targetY);
                    
                    birds.push(bird);
                    debugLog(`Initial bird ${i+1} added with path`);
                }, delay);
                delay += 5000 + Math.random() * 3000; // 5-8 seconds between birds
            }

            // Initial twigs
            const initialTwigCount = 5;
            for (let i = 0; i < initialTwigCount; i++) {
                let x, y;
                if (trees.length > 0 && Math.random() < 0.7) {
                    const randomTree = trees[Math.floor(Math.random() * trees.length)];
                    x = randomTree.x + (Math.random() - 0.5) * 100;
                    y = canvas.height * 0.8 + Math.random() * 5; // Ground level
                } else {
                    x = Math.random() * canvas.width;
                    y = canvas.height * 0.8 + Math.random() * 10;
                }
                const size = 10 + Math.random() * 8;
                const angle = Math.PI / 4 + Math.random() * Math.PI / 2;
                const isSpecial = Math.random() < 0.05;
                const offshoots = [];
                for (let j = 0; j < 3; j++) {
                    offshoots.push({
                        position: Math.random() * size,
                        length: 2 + Math.random() * 4,
                        angle: (Math.random() - 0.5) * Math.PI / 2
                    });
                }
                twigs.push({ x, y, size, angle, isSpecial, offshoots });
                if (isSpecial) console.log(`Initial special twig at (${x}, ${y})`);
            }
            
            // Initial food
            for (let i = 0; i < 3; i++) {
                const x = Math.random() * canvas.width;
                const y = canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 5;
                foodItems.push({
                    x: x,
                    y: y,
                    type: ['seed', 'berry', 'crumb'][Math.floor(Math.random() * 3)],
                    timer: 0
                });
            }
            
            // Initial worms
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * canvas.width;
                const y = canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 20;
                worms.push({
                    x: x,
                    y: y,
                    wiggle: Math.random() * Math.PI * 2,
                    size: 5 + Math.random() * 5
                });
            }

            // 10% chance to spawn a pond on initial load
            if (Math.random() < 0.1) {
                const pondWidth = 80 + Math.random() * 40;
                const pondHeight = 50 + Math.random() * 30;
                const pondX = 100 + Math.random() * (canvas.width - 200);
                const pondY = canvas.height * GROUND_HEIGHT_RATIO;

                ponds.push({
                    x: pondX,
                    y: pondY,
                    width: pondWidth,
                    height: pondHeight,
                    ripples: []
                });

                // Add 2 koi to the pond
                for (let i = 0; i < 2; i++) {
                    koi.push({
                        x: pondX,
                        y: pondY,
                        color: ['#FF6B35', '#FFD23F', '#FFFFFF', '#FF006E'][Math.floor(Math.random() * 4)],
                        swimAngle: Math.random() * Math.PI * 2,
                        pondIndex: ponds.length - 1
                    });
                }

                // Add 1 frog to the pond
                frogs.push({
                    x: pondX + (Math.random() - 0.5) * pondWidth * 0.8,
                    y: canvas.height * GROUND_HEIGHT_RATIO,
                    jumping: false,
                    jumpTimer: 0,
                    tongueOut: false,
                    tongueTarget: null
                });

                debugLog(`Initial pond spawned at (${pondX}, ${pondY}) with koi and frog`);
            }
            
            // Schedule first rain
            scheduleRain();
            
            // Start animation loop
            lastTime = Date.now();
            animationRunning = true;
            requestAnimationFrame(updateAndDraw);
            
            debugLog("Animation started");
        }

        // Event handlers for buttons
        function setupEventHandlers() {
            // Basic control buttons
            const addBirdBtn = document.getElementById('addBirdBtn');
            addBirdBtn.addEventListener('click', () => {
                const bird = new Bird();
                birds.push(bird);
                debugLog("Bird added manually");
            });


             // Add this new handler
    // Screenshot button handler
    const screenshotBtn = document.getElementById('screenshotBtn');
    if (screenshotBtn) {
        screenshotBtn.addEventListener('click', takeScreenshot);
    }

    // Instruction manual toggle
    const manualBtn = document.getElementById('manualBtn');
    const instructionManual = document.getElementById('instructionManual');
    const closeManualBtn = document.getElementById('closeManualBtn');

    if (manualBtn && instructionManual) {
        manualBtn.addEventListener('click', () => {
            instructionManual.style.display = 'block';
            debugLog("Instruction manual opened");
        });
    }

    if (closeManualBtn && instructionManual) {
        closeManualBtn.addEventListener('click', () => {
            instructionManual.style.display = 'none';
            debugLog("Instruction manual closed");
        });
    }

    // Close manual when clicking outside of it
    if (instructionManual) {
        instructionManual.addEventListener('click', (e) => {
            if (e.target === instructionManual) {
                instructionManual.style.display = 'none';
                debugLog("Instruction manual closed (clicked outside)");
            }
        });
    }

    // Mute button toggle
    const muteBtn = document.getElementById('muteBtn');

    if (muteBtn) {
        muteBtn.addEventListener('click', () => {
            isMuted = !isMuted;

            if (isMuted) {
                // Mute audio by suspending context
                if (audioContext && audioContext.state === 'running') {
                    audioContext.suspend();
                }
                // Also disable wind chimes when muting
                windChimeEnabled = false;
                muteBtn.textContent = '🔇 Unmute';
                muteBtn.classList.add('muted');
                debugLog("Audio muted");
            } else {
                // Unmute audio by resuming context
                if (!audioContext) {
                    initializeAudio();
                }
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                muteBtn.textContent = '🔊 Mute';
                muteBtn.classList.remove('muted');
                debugLog("Audio unmuted");
            }
        });
    }

    // Clock toggle handler
    const clockToggle = document.getElementById('clockToggle');
    if (clockToggle) {
        clockToggle.addEventListener('change', () => {
            clockEnabled = clockToggle.checked;
            debugLog(`Clock display ${clockEnabled ? 'enabled' : 'disabled'}`);
        });
    }

    // Garden Diary handlers
    const diaryToggle = document.getElementById('diaryToggle');
    const gardenDiary = document.getElementById('gardenDiary');
    const closeDiaryBtn = document.getElementById('closeDiaryBtn');

    if (diaryToggle && gardenDiary) {
        diaryToggle.addEventListener('change', () => {
            if (diaryToggle.checked) {
                gardenDiary.style.display = 'block';
                updateDiaryDisplay();
                debugLog("Garden diary opened");
            } else {
                gardenDiary.style.display = 'none';
                debugLog("Garden diary closed");
            }
        });
    }

    if (closeDiaryBtn && gardenDiary && diaryToggle) {
        closeDiaryBtn.addEventListener('click', () => {
            gardenDiary.style.display = 'none';
            diaryToggle.checked = false;
            debugLog("Garden diary closed");
        });
    }

    // Close diary when clicking outside
    if (gardenDiary) {
        gardenDiary.addEventListener('click', (e) => {
            if (e.target === gardenDiary) {
                gardenDiary.style.display = 'none';
                debugLog("Garden diary closed (clicked outside)");
            }
        });
    }

            const addFoodBtn = document.getElementById('addFoodBtn');
            addFoodBtn.addEventListener('click', () => {
                scatterFood(canvas.width/2, canvas.height * GROUND_HEIGHT_RATIO, 10);
                debugLog("Food scattered manually");
            });
            
            const toggleRainBtn = document.getElementById('toggleRainBtn');
toggleRainBtn.addEventListener('click', () => {
    // Toggle rain state
    isRaining = !isRaining;
    
    if (!isRaining) {
        // Explicitly set wasRaining to true when rain stops
        wasRaining = true;
        
        // Create puddles
        createPuddles();
        
        // Check for rainbow conditions
        checkForRainbow();
        
        debugLog(`Rain stopped - creating puddles and checking for rainbow`);
    } else {
        // Reset wasRaining when rain starts
        wasRaining = false;
        
        debugLog(`Rain started manually`);
    }
});




            const toggleMushroomModeBtn = document.getElementById('toggleMushroomModeBtn');
if (toggleMushroomModeBtn) {
    toggleMushroomModeBtn.addEventListener('click', () => {
        // Toggle mushroom mode
        mushroomMode = !mushroomMode;
        
        // Update button text and styling
        toggleMushroomModeBtn.textContent = mushroomMode ? '🍄 Normal Mode' : '🍄 Mushroom Mode';
        toggleMushroomModeBtn.style.backgroundColor = mushroomMode ? '#FF00FF' : '#f8f8f8';
        toggleMushroomModeBtn.style.color = mushroomMode ? '#FFFFFF' : '#000000';
        
        // If activating, trigger special effects
        if (mushroomMode) {
            colorCycleTimer = 0;
            birdTrails = []; // Reset trails when starting
            
            // Add special effects for activation
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    addSpecialEffect({
                        type: 'sparkle',
                        x: canvas.width / 2,
                        y: canvas.height / 2,
                        duration: 3000,
                        intensity: 0.8
                    });
                }, i * 300);
            }
            
            // Also update the hidden toggle button state if it exists
            const toggleMushroom = document.getElementById('toggleMushroom');
            if (toggleMushroom) {
                toggleMushroom.style.display = 'block';
                toggleMushroom.textContent = '🍄 Normal Mode';
                toggleMushroom.style.backgroundColor = '#FF00FF';
                toggleMushroom.style.color = '#FFFFFF';
            }
        } else {
            // Clean up when deactivating
            birdTrails = []; // Clear trails
            
            // Update the hidden toggle button state if it exists
            const toggleMushroom = document.getElementById('toggleMushroom');
            if (toggleMushroom) {
                toggleMushroom.textContent = '🍄 Mushroom Mode';
                toggleMushroom.style.backgroundColor = '#f8f8f8';
                toggleMushroom.style.color = '#000000';
            }
        }
        
        debugLog(`Mushroom mode ${mushroomMode ? 'activated' : 'deactivated'}!`);
    });
}







            const spawnWormBtn = document.getElementById('spawnWormBtn');
    spawnWormBtn.addEventListener('click', () => {
        // Spawn a cluster of worms
        const wormCount = 10; // Spawn 10 worms at once for testing
        const groundY = canvas.height * GROUND_HEIGHT_RATIO;
        
        // Create worms in a small area
        const centerX = canvas.width / 2;
        const spreadX = 100; // Spread across 200px area
        
        for (let i = 0; i < wormCount; i++) {
            // Calculate position with some randomness
            const x = centerX + (Math.random() - 0.5) * spreadX * 2;
            const y = groundY + Math.random() * 20; // Slightly below ground
            
            // Add worm if below max limit
            if (worms.length < MAX_WORMS) {
                worms.push({
                    x: x,
                    y: y,
                    wiggle: Math.random() * Math.PI * 2,
                    size: 5 + Math.random() * 5
                });
            }
        }
        
        debugLog(`Manually spawned ${wormCount} worms`);
    });

    const spawnAntsBtn = document.getElementById('spawnAntsBtn');
    spawnAntsBtn.addEventListener('click', () => {
        // Create ant hill if it doesn't exist
        if (!antHill) {
            const groundY = canvas.height * GROUND_HEIGHT_RATIO;
            antHill = {
                x: canvas.width / 2,
                y: groundY + 5,
                entranceY: groundY + 2,
                size: 20,
                ants: [],
                lastAntSpawnTime: 0,
                food: 0
            };
            debugLog(`Ant hill created at (${antHill.x}, ${antHill.y})`);
        }

        // Spawn 10 ants at once for testing
        const antCount = 10;
        for (let i = 0; i < antCount; i++) {
            if (ants.length < 50) { // Reasonable max
                spawnAnt();
            }
        }

        debugLog(`Manually spawned ${antCount} ants`);
    });

    const toggleMushroom = document.getElementById('toggleMushroom');
if (toggleMushroom) {
    toggleMushroom.addEventListener('click', () => {
        // Toggle mushroom mode
        mushroomMode = !mushroomMode;
        
        // Update button text and styling
        toggleMushroom.textContent = mushroomMode ? '🍄 Normal Mode' : '🍄 Mushroom Mode';
        toggleMushroom.style.backgroundColor = mushroomMode ? '#FF00FF' : '#f8f8f8';
        toggleMushroom.style.color = mushroomMode ? '#FFFFFF' : '#000000';
        
        // Sync the main button state
        const toggleMushroomModeBtn = document.getElementById('toggleMushroomModeBtn');
        if (toggleMushroomModeBtn) {
            toggleMushroomModeBtn.textContent = mushroomMode ? '🍄 Normal Mode' : '🍄 Mushroom Mode';
            toggleMushroomModeBtn.style.backgroundColor = mushroomMode ? '#FF00FF' : '#f8f8f8';
            toggleMushroomModeBtn.style.color = mushroomMode ? '#FFFFFF' : '#000000';
        }
        
        // Same code for cleanup/setup as in the main button
        if (mushroomMode) {
            colorCycleTimer = 0;
            birdTrails = []; // Reset trails when starting
        } else {
            birdTrails = []; // Clear trails
        }
        
        debugLog(`Mushroom mode ${mushroomMode ? 'activated' : 'deactivated'}!`);
    });
}

            
            // Debug control buttons
            const addBabyBirdBtn = document.getElementById('addBabyBirdBtn');
            addBabyBirdBtn.addEventListener('click', () => {
                // Always create a new nest for the baby bird
                let nestForBaby = null;
                
                // Create nest in a tree if possible
                if (trees.length > 0) {
                    // Find a suitable tree with more relaxed criteria
                    const potentialTrees = trees.filter(tree => 
                        !tree.nest && tree.health > 30
                    );
                    
                    if (potentialTrees.length > 0) {
                        // Sort trees by health to pick healthier trees first
                        potentialTrees.sort((a, b) => b.health - a.health);
                        
                        // Pick one of the healthiest trees
                        const treeIndex = Math.floor(Math.random() * Math.min(3, potentialTrees.length));
                        const tree = potentialTrees[treeIndex];
                        
                        // Create a new nest
                        const nestX = tree.x + (Math.random() * 20 - 10) * tree.scale;
                        const nestY = tree.y - tree.trunkHeight * 0.8 * tree.scale;
                        
                        const newNest = new Nest(tree, nestX, nestY);
                        newNest.materialsCollected = NEST_MATERIALS_NEEDED; // Fully built nest
                        newNest.isComplete = true;
                        newNest.readyForBabies = true;
                        nests.push(newNest);
                        tree.nest = newNest;
                        
                        nestForBaby = newNest;
                        
                        // Create baby bird at nest
                        const babyBird = new BabyBird(nestX, nestY, null, newNest);
                        babyBirds.push(babyBird);
                        
                        // Alert nearby birds to feed the baby
                        alertBirdsToFeedBaby(babyBird);
                        
                        debugLog(`Created complete nest at (${nestX}, ${nestY}) with baby bird`);
                    } else {
                        // No suitable trees - create baby bird in random position
                        const x = 100 + Math.random() * (canvas.width - 200);
                        const y = canvas.height * 0.3 + Math.random() * 100;
                        babyBirds.push(new BabyBird(x, y));
                        debugLog(`Baby bird added at (${x}, ${y}) without nest (no suitable trees)`);
                    }
                } else {
                    // No trees - create baby bird in random position
                    const x = 100 + Math.random() * (canvas.width - 200);
                    const y = canvas.height * 0.3 + Math.random() * 100;
                    babyBirds.push(new BabyBird(x, y));
                    debugLog(`Baby bird added at (${x}, ${y}) without nest (no trees available)`);
                }
            });
            
            const addSquirrelBtn = document.getElementById('addSquirrelBtn');
            addSquirrelBtn.addEventListener('click', () => {
                const x = Math.random() < 0.5 ? -30 : canvas.width + 30;
                const y = canvas.height * GROUND_HEIGHT_RATIO - 5;
                
                const squirrel = new Squirrel(x, y);
                // Set initial direction based on entry point
                squirrel.direction = x < 0 ? 1 : -1;
                
                squirrels.push(squirrel);
                debugLog("Squirrel added manually");
            });
            
            const addRatKingBtn = document.getElementById('addRatKingBtn');
            addRatKingBtn.addEventListener('click', () => {
                const x = Math.random() < 0.5 ? -30 : canvas.width + 30;
                const y = canvas.height * GROUND_HEIGHT_RATIO;
                
                const ratKing = new Rat(x, y, true); // true = rat king
                rats.push(ratKing);
                debugLog("Rat King added manually");
            });
            
            const addSpecialTwigBtn = document.getElementById('addSpecialTwigBtn');
            addSpecialTwigBtn.addEventListener('click', () => {
                const x = 100 + Math.random() * (canvas.width - 200);
                const y = canvas.height * GROUND_HEIGHT_RATIO + Math.random() * 10;
                
                twigs.push({
                    x: x,
                    y: y,
                    size: 15 + Math.random() * 10, // Larger special twigs
                    angle: Math.random() * Math.PI,
                    isSpecial: true,
                    offshoots: []
                });
                
                // Generate random offshoots
                const offshootCount = 2 + Math.floor(Math.random() * 3);
                for (let j = 0; j < offshootCount; j++) {
                    twigs[twigs.length - 1].offshoots.push({
                        position: Math.random() * twigs[twigs.length - 1].size,
                        length: 3 + Math.random() * 5,
                        angle: (Math.random() - 0.5) * Math.PI
                    });
                }
                
                debugLog("Special twig added manually");
            });
            
            const addBirdhouseBtn = document.getElementById('addBirdhouseBtn');
            addBirdhouseBtn.addEventListener('click', () => {
                // Find a valid position
                const validSpaces = [];
                const minDistance = 100; // Minimum distance from other birdhouses
                
                // Find valid placement spots
                for (let x = 100; x < canvas.width - 100; x += 50) {
                    let valid = true;
                    
                    // Check if too close to other birdhouses
                    for (const birdhouse of birdhouses) {
                        if (Math.abs(birdhouse.x - x) < minDistance) {
                            valid = false;
                            break;
                        }
                    }
                    
                    if (valid) validSpaces.push(x);
                }
                
                // Pick random valid position
                if (validSpaces.length > 0) {
                    const x = validSpaces[Math.floor(Math.random() * validSpaces.length)];
                    const y = canvas.height * GROUND_HEIGHT_RATIO;
                    
                    const newBirdhouse = new Birdhouse(x, y);
                    // CHANGE THIS LINE (make it incomplete so birds can build it):
                    newBirdhouse.isComplete = false; // Was true, now false
                    newBirdhouse.materialsCollected = Math.floor(BIRDHOUSE_MATERIALS_NEEDED / 0); // Half built
                    birdhouses.push(newBirdhouse);
                    
                    // Direct a bird to build it
                    const availableBird = birds.find(bird => !bird.isWild && bird.state !== BIRD_STATES.BUILDING);
                    if (availableBird) {
                        availableBird.buildingBirdhouse = newBirdhouse;
                        availableBird.state = BIRD_STATES.BUILDING_BIRDHOUSE;
                        availableBird.stateTimer = 0;
                        debugLog(`Bird assigned to complete birdhouse at (${x})`);
                    }
                    
                    debugLog(`Birdhouse added at (${x}, ${y})`);
                } else {
                    debugLog("Could not find valid position for birdhouse");
                }
            });
            

            const spawnOwlBtn = document.getElementById('spawnOwlBtn');
spawnOwlBtn.addEventListener('click', () => {
    // Create new owl at a random edge
    const side = Math.random() < 0.5 ? 'left' : 'right';
    const x = side === 'left' ? -30 : canvas.width + 30;
    const y = canvas.height * 0.3 + Math.random() * 100;
    
    const owl = new Owl(x, y);
    owls.push(owl);
    
    // If daytime, set to hunting mode immediately
    if (timeOfDay < 1) {
        owl.state = 'hunting';
    }
    
    debugLog("Owl manually spawned");
});

const spawnScarecrowBtn = document.getElementById('spawnScarecrowBtn');
spawnScarecrowBtn.addEventListener('click', () => {
    // If scarecrow already exists, remove it first
    if (scarecrow) {
        scarecrow = null;
        scarecrowCreated = false;
    }
    
    // Find position for scarecrow
    let scarecrowX = canvas.width / 2;
    
    // If birdhouses exist, place between them
    if (birdhouses.length >= 2) {
        const bh1 = birdhouses[0];
        const bh2 = birdhouses[1];
        scarecrowX = (bh1.x + bh2.x) / 2;
    }
    
    const scarecrowY = canvas.height * GROUND_HEIGHT_RATIO;
    
    // Create scarecrow object
    scarecrow = {
        x: scarecrowX,
        y: scarecrowY,
        armWave: 0,
        hatWobble: 0,
        headTilt: 0,
        isFemale: Math.random() < 0.5
    };
    
    // Mark as created
    scarecrowCreated = true;
    
    // Make any existing crows leave immediately
    if (typeof makeCrowsLeave === 'function') {
        makeCrowsLeave();
    }
    
    // Show celebration effect
    if (typeof addSpecialEffect === 'function') {
        addSpecialEffect({
            type: 'sparkle',
            x: scarecrowX,
            y: scarecrowY - 50,
            duration: 3000,
            intensity: 1.0
        });
    }
    
    debugLog(`Scarecrow ${scarecrow.isFemale ? 'woman' : 'man'} manually created!`);
});

const spawnGameboyBtn = document.getElementById('spawnGameboyBtn');
spawnGameboyBtn.addEventListener('click', () => {
    // Only spawn if one doesn't already exist
    if (!gameboy) {
        spawnGameboy();
    } else {
        debugLog("Gameboy already exists in the garden");
    }
});

// Trigger pecking behavior for testing
const triggerPeckingBtn = document.getElementById('triggerPeckingBtn');
triggerPeckingBtn.addEventListener('click', () => {
    if (birds.length > 0) {
        const bird = birds[Math.floor(Math.random() * birds.length)];
        bird.startPecking();
        debugLog(`Triggered pecking for bird at (${bird.x.toFixed(0)}, ${bird.y.toFixed(0)})`);
    } else {
        debugLog("No birds available to trigger pecking");
    }
});

// Test all chirp types
const testChirpBtn = document.getElementById('testChirpBtn');
testChirpBtn.addEventListener('click', () => {
    if (birds.length > 0) {
        const bird = birds[0];
        const chirpTypes = [
            CHIRP_TYPES.SOCIAL,
            CHIRP_TYPES.FOOD_CALL,
            CHIRP_TYPES.CONTACT_CALL,
            CHIRP_TYPES.ALERT,
            CHIRP_TYPES.TERRITORIAL,
            CHIRP_TYPES.VICTORY
        ];

        chirpTypes.forEach((type, i) => {
            setTimeout(() => {
                bird.chirp(type, 1.0);
                debugLog(`Testing chirp type: ${Object.keys(CHIRP_TYPES).find(k => CHIRP_TYPES[k] === type)}`);
            }, i * 1000);
        });
    } else {
        debugLog("No birds available to test chirps");
    }
});

// Add a regular rat (not rat king)
const addRatBtn = document.getElementById('addRatBtn');
addRatBtn.addEventListener('click', () => {
    const x = Math.random() < 0.5 ? -30 : canvas.width + 30;
    const y = canvas.height * GROUND_HEIGHT_RATIO;
    const rat = new Rat(x, y, false);
    rats.push(rat);
    debugLog(`Regular rat spawned at (${x}, ${y})`);
});

// Spawn a pond
const spawnPondBtn = document.getElementById('spawnPondBtn');
spawnPondBtn.addEventListener('click', () => {
    // Create pond at random location
    const x = 100 + Math.random() * (canvas.width - 200);
    const width = 80 + Math.random() * 40;
    const height = 40 + Math.random() * 20;

    // Position pond so top edge aligns with ground (appears to be in the ground)
    const y = canvas.height * GROUND_HEIGHT_RATIO + height / 2;

    if (!ponds) ponds = [];

    ponds.push({
        x: x,
        y: y,
        width: width,
        height: height,
        rippleTimer: 0,
        ripples: []
    });

    debugLog(`Pond spawned at (${x}, ${y}), size: ${width}x${height}`);
});

// Spawn a frog
const spawnFrogBtn = document.getElementById('spawnFrogBtn');
spawnFrogBtn.addEventListener('click', () => {
    if (!frogs) frogs = [];

    const x = 100 + Math.random() * (canvas.width - 200);
    const y = canvas.height * GROUND_HEIGHT_RATIO;

    frogs.push({
        x: x,
        y: y,
        jumpTimer: 0,
        tongueOut: false
    });

    debugLog(`Frog spawned at (${x}, ${y})`);
});

// Spawn a koi fish
const spawnKoiBtn = document.getElementById('spawnKoiBtn');
spawnKoiBtn.addEventListener('click', () => {
    if (ponds && ponds.length > 0) {
        if (!koi) koi = [];

        const pond = ponds[0];
        koi.push({
            x: pond.x + pond.width / 2,
            y: pond.y + pond.height / 2,
            pondIndex: 0,
            swimAngle: Math.random() * Math.PI * 2,
            color: '#FF6B00'
        });

        debugLog(`Koi spawned in pond`);
    } else {
        debugLog("No ponds available - spawn a pond first!");
    }
});

// Trigger rainbow manually
const triggerRainbowBtn = document.getElementById('triggerRainbowBtn');
triggerRainbowBtn.addEventListener('click', () => {
    if (typeof createRainbow === 'function') {
        // Directly create rainbow regardless of conditions
        createRainbow();
        debugLog("Rainbow triggered manually");
    } else {
        debugLog("createRainbow function not found");
    }
});

const toggleWindChimeBtn = document.getElementById('toggleWindChimeBtn');
if (toggleWindChimeBtn) {
    toggleWindChimeBtn.addEventListener('click', () => {
        // Toggle to opposite state
        windChimeEnabled = !windChimeEnabled;
        
        if (windChimeEnabled) {
    // Start wind chimes
    windChimeStartTime = Date.now();
    lastWindChimeTime = 0; // Set to 0 to trigger immediate chime
    
    // Initialize audio context if needed
    if (!audioContext) {
        try {
            initializeAudio();
            // User gesture is required to create audio context in many browsers
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        } catch (e) {
            console.error("Could not initialize audio:", e);
        }
    }
    
    // Cancel any existing timeout/interval to be safe
    if (windChimeTimeout) {
        if (typeof windChimeTimeout === 'number') {
            clearTimeout(windChimeTimeout);
        } else {
            clearInterval(windChimeTimeout);
        }
        windChimeTimeout = null;
    }
    
    // Call playWindChimes directly to start immediately
    playWindChimes();
    
    // Update button text
    toggleWindChimeBtn.textContent = '🔔 Wind Chimes: ON';
    toggleWindChimeBtn.style.background = '#4CAF50'; // Green background
    
    debugLog("Wind chimes enabled with improved timer logic");
} else {
    // Turn off wind chimes
    toggleWindChimeBtn.textContent = '🔔 Wind Chimes: OFF';
    toggleWindChimeBtn.style.background = '#f44336'; // Red background
    debugLog("Wind chimes disabled");
}
        
        // Force a user interaction with audio context (needed for browsers)
        if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                debugLog("Audio context resumed from button click");
            });
        }
    });
}

 // Add event handler for the "Close(Keep Debug Visuals)" button
 const keepVisualsBtn = document.getElementById('keepVisualsBtn');
            if (keepVisualsBtn) {
                keepVisualsBtn.addEventListener('click', () => {
                    // Create a marker element to track this state
                    if (!document.getElementById('keepVisualsActive')) {
                        const keepVisualElem = document.createElement('div');
                        keepVisualElem.id = 'keepVisualsActive';
                        keepVisualElem.style.display = 'none'; // Hidden element
                        document.body.appendChild(keepVisualElem);
                    }
        const controlPanel = document.getElementById('controlPanel');
        if (controlPanel) {
            controlPanel.style.display = 'none';
        }
        
        // Keep debug visuals on
        debugVisuals = true;
        
        debugLog("Control panel hidden, debug visuals retained. Press 'C' to restore panel.");
    });
}


            
          // Triple click detection variables - ADD THIS CODE HERE
let clickCount = 0;
let lastClickTime = 0;
const clickTimeout = 500; // ms between clicks to count as multi-click

// Canvas click for food and triple-click detection
canvas.addEventListener('click', (e) => {
    // Initialize audio on first click (required by browsers)
    if (!audioContext) {
        initializeAudio();
    }
    if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume();
    }

    // Prevent any default behaviors and stop propagation
    e.preventDefault();
    e.stopPropagation();

    // Get the correct bounding rectangle, accounting for scrolling
    const rect = canvas.getBoundingClientRect();
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    
    // Calculate the correct coordinates, accounting for scroll position
    const x = e.clientX - rect.left - scrollLeft;
    const y = e.clientY - rect.top - scrollTop;

    // Scale coordinates if needed
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const scaledX = x * scaleX;
    const scaledY = y * scaleY;

    // Restore show info button if it was hidden by Escape key
    const toggleInfo = document.getElementById('toggleInfo');
    if (window.showInfoButtonHidden && toggleInfo) {
        toggleInfo.style.display = 'block';
        window.showInfoButtonHidden = false;
        debugLog("Show info button restored on click");
    }
    
    // Triple-click detection logic
    const currentTime = Date.now();
    if (currentTime - lastClickTime < clickTimeout) {
        clickCount++;
    } else {
        clickCount = 1;
    }
    lastClickTime = currentTime;
    
    // Check for triple click in top third of screen (mobile-friendly)
    if (clickCount === 3) {
        // Check if click is in the top third of the screen
        const topThird = canvas.height / 3;
        const inTopThird = scaledY < topThird;
        
        if (inTopThird) {
            // Toggle debug control panel
            const controlPanel = document.getElementById('controlPanel');
            if (controlPanel) {
                controlPanel.style.display = controlPanel.style.display === 'none' ? 'block' : 'none';
                debugLog(`Debug control panel ${controlPanel.style.display === 'none' ? 'hidden' : 'shown'} via triple-click in top third of screen`);
            }
            
            // Also toggle debug visuals
            debugVisuals = controlPanel.style.display === 'block';
            
            // Reset click counter
            clickCount = 0;
            return; // Skip food scattering
        }
    }

// Check if gameboy was clicked
if (gameboy) {
    const wasClicked = checkGameboyClicks(scaledX, scaledY);
    if (wasClicked) {
        return; // Skip food scattering
    }
}



    // ADD THIS CODE: Check if magic mushroom was clicked
    if (magicMushroom && !mushroomMode) {
        const distance = Math.sqrt(
            Math.pow(scaledX - magicMushroom.x, 2) + 
            Math.pow(scaledY - magicMushroom.y, 2)
        );
        
        if (distance < magicMushroom.size * 2) {
            // Add a special effect when mushroom is clicked
            addSpecialEffect({
                type: 'sparkle',
                x: magicMushroom.x,
                y: magicMushroom.y,
                duration: 2000,
                intensity: 1.0
            });
            
            activateMushroomMode();
            magicMushroom.clicked = true;
            
            // Play a magical sound if wind chimes are enabled
            if (windChimeEnabled && audioContext) {
                const notes = ['C4', 'E4', 'G4', 'C5'];
                for (let i = 0; i < notes.length; i++) {
                    setTimeout(() => {
                        playNote(notes[i], 1);
                    }, i * 150);
                }
            }
            
            return; // Skip food scattering
        }
    }
    
    // Use the scaled coordinates
    scatterFood(scaledX, scaledY, 3);
    debugLog(`Food scattered at web coordinates (${scaledX}, ${scaledY})`);
});
            
// Touch events for mobile
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); // Prevent scrolling
    if (e.touches.length > 0) {
        const rect = canvas.getBoundingClientRect();
        const x = e.touches[0].clientX - rect.left;
        const y = e.touches[0].clientY - rect.top;
        
        scatterFood(x, y, 5);
        debugLog(`Food scattered via touch at (${x}, ${y})`);
    }
});


        }







        
        // Initialize the simulation
        function initialize() {
            // Update canvas size
            resizeCanvas();

            // Generate initial stars
            generateStars();

            // Generate initial weather forecast
            generateWeatherForecast();

            // Initialize hourly melody playlist
            initializeHourlyPlaylist();

            // Setup event handlers
            setupEventHandlers();

            // Update debug visuals
            updateDebugVisuals();

            // Start animation
            startAnimation();
        }

        // Initialize when page is loaded
        window.addEventListener('load', () => {
            initialize();
        });
    </script>
</body>
</html>
